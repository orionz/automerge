{"version":3,"sources":["webpack://Automerge/webpack/universalModuleDefinition","webpack://Automerge/webpack/bootstrap","webpack://Automerge/./backend/columnar.js","webpack://Automerge/./backend/encoding.js","webpack://Automerge/./backend/index.js","webpack://Automerge/./backend/op_set.js","webpack://Automerge/./backend/skip_list.js","webpack://Automerge/./frontend/apply_patch.js","webpack://Automerge/./frontend/constants.js","webpack://Automerge/./frontend/context.js","webpack://Automerge/./frontend/counter.js","webpack://Automerge/./frontend/index.js","webpack://Automerge/./frontend/proxies.js","webpack://Automerge/./frontend/table.js","webpack://Automerge/./frontend/text.js","webpack://Automerge/./node_modules/base64-js/index.js","webpack://Automerge/./node_modules/fast-sha256/sha256.js","webpack://Automerge/./node_modules/ieee754/index.js","webpack://Automerge/./node_modules/immutable/dist/immutable.js","webpack://Automerge/./node_modules/isarray/index.js","webpack://Automerge/./node_modules/node-libs-browser/node_modules/buffer/index.js","webpack://Automerge/./node_modules/safe-buffer/index.js","webpack://Automerge/./node_modules/string_decoder/lib/string_decoder.js","webpack://Automerge/./node_modules/transit-immutable-js/index.js","webpack://Automerge/./node_modules/transit-js/transit.js","webpack://Automerge/./node_modules/uuid/lib/bytesToUuid.js","webpack://Automerge/./node_modules/uuid/lib/rng-browser.js","webpack://Automerge/./node_modules/uuid/v4.js","webpack://Automerge/(webpack)/buildin/global.js","webpack://Automerge/./src/automerge.js","webpack://Automerge/./src/common.js","webpack://Automerge/./src/uuid.js"],"names":["require","ROOT_ID","copyObject","parseOpId","equalBytes","hexStringToBytes","bytesToHexString","Encoder","Decoder","RLEEncoder","RLEDecoder","DeltaEncoder","DeltaDecoder","BooleanEncoder","BooleanDecoder","Hash","MAGIC_BYTES","Uint8Array","of","COLUMN_TYPE","GROUP_CARD","ACTOR_ID","INT_RLE","INT_DELTA","BOOLEAN","STRING_RLE","VALUE_LEN","VALUE_RAW","VALUE_TYPE","NULL","FALSE","TRUE","LEB128_UINT","LEB128_INT","IEEE754","UTF8","BYTES","COUNTER","TIMESTAMP","MIN_UNKNOWN","MAX_UNKNOWN","ACTIONS","COMMON_COLUMNS","objActor","objCtr","keyActor","keyCtr","keyStr","idActor","idCtr","insert","action","valLen","valRaw","chldActor","chldCtr","CHANGE_COLUMNS","Object","assign","predNum","predActor","predCtr","DOC_OPS_COLUMNS","succNum","succActor","succCtr","DOC_OPS_COLUMNS_REV","entries","reduce","acc","k","v","DOCUMENT_COLUMNS","actor","seq","maxOp","time","message","depsNum","depsIndex","maybeParseOpId","value","undefined","indexOf","actorIdToActorNum","opId","actorIds","actorId","counter","actorNum","RangeError","parseAllOpIds","changes","single","actors","newChanges","change","ops","map","op","obj","key","child","pred","push","keys","sort","concat","filter","i","length","id","startOp","encodeObjectId","columns","appendValue","JSON","stringify","encodeOperationKey","encodeOperationAction","actionCode","encodeInteger","typeTag","numBytes","appendInt53","appendUint53","encodeValue","appendRawString","ArrayBuffer","isView","appendRawBytes","buffer","datatype","Number","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","buf32","view32","DataView","setFloat32","getFloat32","buf64","view64","setFloat64","decodeValue","lenColumn","rawColumn","sizeTag","readValue","readRawString","bytes","readRawBytes","valDecoder","readUint53","readInt53","view","byteOffset","byteLength","getFloat64","decodeValueColumns","colIndex","result","columnId","columnName","decoder","encodeOps","forDocument","succ","columnList","name","encoder","a","b","decodeOps","newOps","newOp","valLen_datatype","encoderByColumnId","decoderByColumnId","makeDecoders","columnSpec","emptyBuf","decoders","column","find","_","toString","parseInt","decodeColumns","parsedRows","some","col","done","row","groupId","groupCols","values","count","colOffset","readColumns","numColumns","lastColumnId","readUint32","columnBuf","readPrefixedBytes","decodeChangeHeader","readHexString","readPrefixedString","deps","numActorIds","numDeps","encodeContainer","chunkType","encodeHeaderCallback","CHECKSUM_SIZE","HEADER_SPACE","body","appendPrefixedBytes","bodyBuf","header","appendByte","headerBuf","sha256","update","subarray","hash","digest","checksum","set","decodeContainerHeader","computeHash","expectedHash","hashStartOffset","offset","readByte","chunkLength","chunkData","buf","binaryHash","encodeChange","changeObj","appendHexString","appendPrefixedString","slice","Array","isArray","TypeError","hexHash","decodeChangeColumns","chunkDecoder","decodeChange","decodeChangeMeta","meta","splitContainers","chunks","startOffset","decodeChanges","binaryChanges","decoded","binaryChange","chunk","decodeDocument","sortOpIds","a_","b_","groupDocumentOps","byObjectId","byReference","objectType","objectId","startsWith","ref","predId","stack","pop","groupChangeOps","changesByActor","opsById","actorChanges","left","right","index","Math","floor","op1","op2","expectedId","encodeDocumentChanges","indexByHash","heads","dep","changesColumns","decodeDocumentChanges","expectedHeads","d","actualHeads","headsEqual","join","encodeDocument","opsColumns","numChangesColumns","head","decodeDocumentHeader","documentDecoder","numActors","numHeads","addPatchProperty","objects","property","actionName","succId","childId","objId","props","type","edits","constructPatch","documentBuffer","objType","makeMap","makeList","makeText","makeTable","seekToOp","docCols","consecutiveOps","objActorD","objCtrD","keyActorD","keyCtrD","keyStrD","idActorD","idCtrD","insertD","actionD","skipCount","nextObjActor","nextObjCtr","nextIdActor","nextIdCtr","nextKeyStr","skipValues","copyColumns","outCols","inCols","actorTable","inIndex","lastGroup","lastCardinality","valueColumn","valueBytes","outCol","inCol","colCount","copyFrom","sumValues","sumShift","idActorIndex","options","lookupTable","blankValue","readOperation","operation","colValue","appendOperation","console","log","idx","groupRelatedOps","changeCols","currentActor","objIdSeen","firstOp","lastOp","opSequences","opIdCtr","thisOp","directCopy","BackendDoc","doc","docColumns","numOps","opCount","opsAppended","docOp","docOpsConsumed","changeOp","takeDocOp","takeChangeOp","dropChangeOp","j","splice","beforeCount","allCols","newOpsCount","remainingOps","mergeDocChangeOps","expectedCols","changeBuffer","getAllColumns","getActorTable","actorIndex","reset","applyOps","module","exports","stringToUtf8","utf8ToString","TextEncoder","TextDecoder","utf8encoder","utf8decoder","string","encode","decode","Buffer","StringDecoder","from","end","Error","test","match","hex","minSize","newSize","newBuf","grow","max","ceil","clz32","high32","low32","appendUint64","appendInt64","appendUint32","appendInt32","data","finish","shift","nextByte","readUint64","readInt64","start","state","lastValue","literal","repetitions","_appendValue","flush","remaining","sum","firstValue","endOffset","firstRun","readRecord","numValues","min","skipRawValues","readRawValue","mappedValue","appendRawValue","numSkip","consume","num","skip","absoluteValue","nulls","firstCopy","numCopied","Map","List","OpSet","SkipList","backendState","backend","frozen","fillInPred","opSet","myOps","forEach","fieldOps","getFieldOps","fieldOp","get","toJS","processChangeRequest","request","objectIds","objectTypes","elemIds","assignments","has","getIn","insertAfter","keyOf","removeKey","includes","init","versionObj","version","localOnly","versions","clone","free","makePatch","diffs","isIncremental","last","clock","seqs","size","toJSON","canUndo","canRedo","isEmpty","patch","apply","isUndoable","addLocalChange","addChange","finalizePatch","applyChanges","applyLocalChange","requestType","undo","redo","undoable","save","getChanges","load","loadChanges","newState","getPatch","getChangesForActor","haveDeps","getMissingChanges","getMissingDeps","undoPos","undoOps","redoOps","withMutations","getOperationKey","remove","getUndoStack","getRedoStack","Set","fromJS","causallyReady","hasIn","getPath","path","first","unshift","getObjectType","objInit","applyMake","getChildId","object","_init","_inbound","_keys","setIn","applyInsert","updateIn","list","updateListElement","elemId","removeIndex","setValue","prevId","getPrevious","insertIndex","recordUndoHistory","undoLocal","isChildOp","applyAssign","constructObject","overwritten","other","priorOpsOverwritten","groupBy","old","add","lamportCompare","reverse","setPatchProps","initializePatch","pathOp","newProps","newObjects","localPatch","opWithId","merge","contains","applyChange","expectedSeq","maxOpId","depHash","future","queue","sameActorDep","changeInfo","depsPast","toSet","depsFuture","prior","subtract","history","applyQueuedOps","pushUndoHistory","seenHashes","forActor","afterSeq","missing","inQueue","getParent","insertion","time1","time2","insertionsAfter","parentId","childKey","getNext","children","ancestor","siblings","constructField","constructMap","constructList","maxCounter","randomLevel","next","rand","random","level","Node","prevKey","nextKey","prevCount","nextCount","newKey","newLevel","fromLevel","distance","maxLevel","removedLevel","newKeys","distances","randomSource","makeInstance","predecessor","preKeys","preCounts","preKey","node","_nodes","successor","sucKeys","sucCounts","sucKey","_randomSource","headNode","predecessors","successors","preLevel","sucLevel","updateLevel","nodes","insertBefore","removedNode","removeAfter","removeBefore","mode","rval","Symbol","iterator","instance","create","prototype","isObject","OPTIONS","OBJECT_ID","CONFLICTS","Text","instantiateText","Table","instantiateTable","Counter","getValue","updated","interpretPatch","Date","ts1","ts2","regex","applyProperties","conflicts","opIds","subpatch","iterateEdits","insertCallback","removeCallback","splicePos","deletions","insertions","edit","cloneMapObject","originalObject","defineProperty","updateMapObject","updateTableObject","_clone","_set","byId","cloneListObject","originalList","updateListObject","blanks","updateTextObject","elems","oldValue","cloneRootObject","root","CACHE","STATE","CHANGE","getWriteableCounter","uuid","Context","applyPatch","cache","getTime","getValueDescription","getObject","pathElem","getValuesDescriptions","nextOpId","getPropertyValue","subpath","instantiateObject","addOp","insertListItems","nested","valuePatch","createNestedObjects","description","callback","getSubpatch","applyAtPath","newObject","rowId","table","delta","freeze","valueOf","WriteableCounter","context","increment","rootObjectProxy","checkActorId","updateRootObject","newDoc","_freeze","makeChange","getActorId","round","applyPatchToDoc","queuedRequest","before","requests","fromBackend","deferActorId","initialState","emptyChange","baseDoc","isUndoRedoInFlight","req","getObjectId","getObjectById","setActorId","getDeps","getConflicts","getBackendState","parseListIndex","isNaN","Infinity","listMethods","listId","methods","deleteAt","numDelete","fill","setListIndex","insertAt","getObjectField","deleteCount","deleted","n","method","args","item","call","MapHandler","target","readonly","setMapKey","deleteProperty","deleteMapKey","getOwnPropertyDescriptor","configurable","enumerable","ownKeys","ListHandler","writable","mapProxy","Proxy","listProxy","instantiateProxy","getWriteable","compareRows","properties","row1","row2","prop","prop1","prop2","thisArg","rows","arg","isFrozen","WriteableTable","ids","entry","addTableRow","deleteTableRow","text","split","str","elem","spans","chars","array","transit","Frontend","changeOpts","localDoc","remoteDoc","getAllChanges","oldDoc","oldState","equals","val1","val2","keys1","keys2","getHistory","snapshot","setDefaultBackend","newBackend","Backend","copy","exec","array1","array2","defaultFactory","replace","factory","makeUuid","setFactory","newFactory"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;;;;;;;;;;eClFuDA,mBAAOA,CAAC,sCAAR,C;IAA/CC,O,YAAAA,O;IAASC,U,YAAAA,U;IAAYC,S,YAAAA,S;IAAWC,U,YAAAA,U;;gBAIpCJ,mBAAOA,CAAC,yCAAR,C;IAFFK,gB,aAAAA,gB;IAAkBC,gB,aAAAA,gB;IAClBC,O,aAAAA,O;IAASC,O,aAAAA,O;IAASC,U,aAAAA,U;IAAYC,U,aAAAA,U;IAAYC,Y,aAAAA,Y;IAAcC,Y,aAAAA,Y;IAAcC,c,aAAAA,c;IAAgBC,c,aAAAA,c;;AAGxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;gBACiBd,mBAAOA,CAAC,yDAAR,C;IAATe,I,aAAAA,I;;AAER;;;AACA,IAAMC,cAAcC,WAAWC,EAAX,CAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,CAApB;;AAEA,IAAMC,cAAc;AAClBC,cAAY,CADM,EACHC,UAAU,CADP,EACUC,SAAS,CADnB,EACsBC,WAAW,CADjC,EACoCC,SAAS,CAD7C;AAElBC,cAAY,CAFM,EAEHC,WAAW,CAFR,EAEWC,WAAW;AAFtB,CAApB;;AAKA,IAAMC,aAAa;AACjBC,QAAM,CADW,EACRC,OAAO,CADC,EACEC,MAAM,CADR,EACWC,aAAa,CADxB,EAC2BC,YAAY,CADvC,EAC0CC,SAAS,CADnD;AAEjBC,QAAM,CAFW,EAERC,OAAO,CAFC,EAEEC,SAAS,CAFX,EAEcC,WAAW,CAFzB,EAE4BC,aAAa,EAFzC,EAE6CC,aAAa;;AAG7E;AALmB,CAAnB,CAMA,IAAMC,UAAU,CAAC,SAAD,EAAY,KAAZ,EAAmB,UAAnB,EAA+B,KAA/B,EAAsC,UAAtC,EAAkD,KAAlD,EAAyD,WAAzD,EAAsE,MAAtE,CAAhB;;AAEA,IAAMC,iBAAiB;AACrBC,YAAW,KAAK,CAAL,GAASxB,YAAYE,QADX;AAErBuB,UAAW,KAAK,CAAL,GAASzB,YAAYG,OAFX;AAGrBuB,YAAW,KAAK,CAAL,GAAS1B,YAAYE,QAHX;AAIrByB,UAAW,KAAK,CAAL,GAAS3B,YAAYI,SAJX;AAKrBwB,UAAW,KAAK,CAAL,GAAS5B,YAAYM,UALX;AAMrBuB,WAAW,KAAK,CAAL,GAAS7B,YAAYE,QANX;AAOrB4B,SAAW,KAAK,CAAL,GAAS9B,YAAYI,SAPX;AAQrB2B,UAAW,KAAK,CAAL,GAAS/B,YAAYK,OARX;AASrB2B,UAAW,KAAK,CAAL,GAAShC,YAAYG,OATX;AAUrB8B,UAAW,KAAK,CAAL,GAASjC,YAAYO,SAVX;AAWrB2B,UAAW,KAAK,CAAL,GAASlC,YAAYQ,SAXX;AAYrB2B,aAAW,KAAK,CAAL,GAASnC,YAAYE,QAZX;AAarBkC,WAAW,KAAK,CAAL,GAASpC,YAAYI;AAbX,CAAvB;;AAgBA,IAAMiC,iBAAiBC,OAAOC,MAAP,CAAc;AACnCC,WAAW,KAAK,CAAL,GAASxC,YAAYC,UADG;AAEnCwC,aAAW,KAAK,CAAL,GAASzC,YAAYE,QAFG;AAGnCwC,WAAW,KAAK,CAAL,GAAS1C,YAAYI;AAHG,CAAd,EAIpBmB,cAJoB,CAAvB;;AAMA,IAAMoB,kBAAkBL,OAAOC,MAAP,CAAc;AACpCK,WAAW,KAAK,CAAL,GAAS5C,YAAYC,UADI;AAEpC4C,aAAW,KAAK,CAAL,GAAS7C,YAAYE,QAFI;AAGpC4C,WAAW,KAAK,CAAL,GAAS9C,YAAYI;AAHI,CAAd,EAIrBmB,cAJqB,CAAxB;;AAMA,IAAMwB,sBAAsBT,OAAOU,OAAP,CAAeL,eAAf,EACzBM,MADyB,CAClB,UAACC,GAAD,QAAiB;AAAA;AAAA,MAAVC,CAAU;AAAA,MAAPC,CAAO;;AAACF,MAAIE,CAAJ,IAASD,CAAT,CAAY,OAAOD,GAAP;AAAW,CADvB,EACyB,EADzB,CAA5B;;AAGA,IAAMG,mBAAmB;AACvBC,SAAW,KAAK,CAAL,GAAStD,YAAYE,QADT;AAEvBqD,OAAW,KAAK,CAAL,GAASvD,YAAYI,SAFT;AAGvBoD,SAAW,KAAK,CAAL,GAASxD,YAAYI,SAHT;AAIvBqD,QAAW,KAAK,CAAL,GAASzD,YAAYI,SAJT;AAKvBsD,WAAW,KAAK,CAAL,GAAS1D,YAAYM,UALT;AAMvBqD,WAAW,KAAK,CAAL,GAAS3D,YAAYC,UANT;AAOvB2D,aAAW,KAAK,CAAL,GAAS5D,YAAYI;;AAGlC;;;;;AAVyB,CAAzB,CAeA,SAASyD,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,MAAIA,UAAUC,SAAd,EAAyB,OAAO,EAAP;AACzB;AACA;AACA,SAAQD,MAAME,OAAN,CAAc,GAAd,KAAsB,CAAvB,GAA4BhF,UAAU8E,KAAV,CAA5B,GAA+C,EAACA,YAAD,EAAtD;AACD;;AAED;;;;;AAKA,SAASG,iBAAT,CAA2BC,IAA3B,EAAiCC,QAAjC,EAA2C;AACzC,MAAI,CAACD,KAAKE,OAAV,EAAmB,OAAOF,IAAP;AACnB,MAAMG,UAAUH,KAAKG,OAArB;AACA,MAAMC,WAAWH,SAASH,OAAT,CAAiBE,KAAKE,OAAtB,CAAjB;AACA,MAAIE,WAAW,CAAf,EAAkB,MAAM,IAAIC,UAAJ,CAAe,iBAAf,CAAN,CAJuB,CAIiB;AAC1D,SAAO,EAACF,gBAAD,EAAUC,kBAAV,EAAoBF,SAASF,KAAKE,OAAlC,EAAP;AACD;;AAED;;;;;;;;;;;AAWA,SAASI,aAAT,CAAuBC,OAAvB,EAAgCC,MAAhC,EAAwC;AACtC,MAAMC,SAAS,EAAf;AAAA,MAAmBC,aAAa,EAAhC;AADsC;AAAA;AAAA;;AAAA;AAEtC,yBAAmBH,OAAnB,8HAA4B;AAAA,UAAnBI,MAAmB;;AAC1BA,eAAS9F,WAAW8F,MAAX,CAAT;AACAF,aAAOE,OAAOvB,KAAd,IAAuB,IAAvB;AACAuB,aAAOC,GAAP,GAAaD,OAAOC,GAAP,CAAWC,GAAX,CAAe,cAAM;AAChCC,aAAKjG,WAAWiG,EAAX,CAAL;AACAA,WAAGC,GAAH,GAASpB,eAAemB,GAAGC,GAAlB,CAAT;AACAD,WAAGE,GAAH,GAASrB,eAAemB,GAAGE,GAAlB,CAAT;AACAF,WAAGG,KAAH,GAAWtB,eAAemB,GAAGG,KAAlB,CAAX;AACA,YAAIH,GAAGI,IAAP,EAAaJ,GAAGI,IAAH,GAAUJ,GAAGI,IAAH,CAAQL,GAAR,CAAY/F,SAAZ,CAAV;AACb,YAAIgG,GAAGC,GAAH,CAAOb,OAAX,EAAoBO,OAAOK,GAAGC,GAAH,CAAOb,OAAd,IAAyB,IAAzB;AACpB,YAAIY,GAAGE,GAAH,CAAOd,OAAX,EAAoBO,OAAOK,GAAGE,GAAH,CAAOd,OAAd,IAAyB,IAAzB;AACpB,YAAIY,GAAGG,KAAH,CAASf,OAAb,EAAsBO,OAAOK,GAAGG,KAAH,CAASf,OAAhB,IAA2B,IAA3B;AARU;AAAA;AAAA;;AAAA;AAShC,gCAAiBY,GAAGI,IAApB;AAAA,gBAASA,IAAT;AAA0BT,mBAAOS,KAAKhB,OAAZ,IAAuB,IAAvB;AAA1B;AATgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUhC,eAAOY,EAAP;AACD,OAXY,CAAb;AAYAJ,iBAAWS,IAAX,CAAgBR,MAAhB;AACD;AAlBqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBtC,MAAIV,WAAW7B,OAAOgD,IAAP,CAAYX,MAAZ,EAAoBY,IAApB,EAAf;AACA,MAAIb,MAAJ,EAAY;AACVP,eAAW,CAACM,QAAQ,CAAR,EAAWnB,KAAZ,EAAmBkC,MAAnB,CAA0BrB,SAASsB,MAAT,CAAgB;AAAA,aAASnC,UAAUmB,QAAQ,CAAR,EAAWnB,KAA9B;AAAA,KAAhB,CAA1B,CAAX;AACD;AAvBqC;AAAA;AAAA;;AAAA;AAwBtC,0BAAmBsB,UAAnB,mIAA+B;AAAA,UAAtBC,OAAsB;;AAC7BA,cAAOP,QAAP,GAAkBH,SAASH,OAAT,CAAiBa,QAAOvB,KAAxB,CAAlB;AACA,WAAK,IAAIoC,IAAI,CAAb,EAAgBA,IAAIb,QAAOC,GAAP,CAAWa,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C,YAAIV,KAAKH,QAAOC,GAAP,CAAWY,CAAX,CAAT;AACAV,WAAGY,EAAH,GAAQ,EAACvB,SAASQ,QAAOgB,OAAP,GAAiBH,CAA3B,EAA8BpB,UAAUO,QAAOP,QAA/C,EAAyDF,SAASS,QAAOvB,KAAzE,EAAR;AACA0B,WAAGC,GAAH,GAAShB,kBAAkBe,GAAGC,GAArB,EAA0Bd,QAA1B,CAAT;AACAa,WAAGE,GAAH,GAASjB,kBAAkBe,GAAGE,GAArB,EAA0Bf,QAA1B,CAAT;AACAa,WAAGG,KAAH,GAAWlB,kBAAkBe,GAAGG,KAArB,EAA4BhB,QAA5B,CAAX;AACAa,WAAGI,IAAH,GAAUJ,GAAGI,IAAH,CAAQL,GAAR,CAAY;AAAA,iBAAQd,kBAAkBmB,IAAlB,EAAwBjB,QAAxB,CAAR;AAAA,SAAZ,CAAV;AACD;AACF;AAlCqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmCtC,SAAO,EAACM,SAASG,UAAV,EAAsBT,kBAAtB,EAAP;AACD;;AAED;;;;AAIA,SAAS2B,cAAT,CAAwBd,EAAxB,EAA4Be,OAA5B,EAAqC;AACnC,MAAIf,GAAGC,GAAH,CAAOnB,KAAP,KAAiBhF,OAArB,EAA8B;AAC5BiH,YAAQvE,QAAR,CAAiBwE,WAAjB,CAA6B,IAA7B;AACAD,YAAQtE,MAAR,CAAeuE,WAAf,CAA2B,IAA3B;AACD,GAHD,MAGO,IAAIhB,GAAGC,GAAH,CAAOX,QAAP,IAAmB,CAAnB,IAAwBU,GAAGC,GAAH,CAAOZ,OAAP,GAAiB,CAA7C,EAAgD;AACrD0B,YAAQvE,QAAR,CAAiBwE,WAAjB,CAA6BhB,GAAGC,GAAH,CAAOX,QAApC;AACAyB,YAAQtE,MAAR,CAAeuE,WAAf,CAA2BhB,GAAGC,GAAH,CAAOZ,OAAlC;AACD,GAHM,MAGA;AACL,UAAM,IAAIE,UAAJ,qCAAiD0B,KAAKC,SAAL,CAAelB,GAAGC,GAAlB,CAAjD,CAAN;AACD;AACF;;AAED;;;;AAIA,SAASkB,kBAAT,CAA4BnB,EAA5B,EAAgCe,OAAhC,EAAyC;AACvC,MAAIf,GAAGE,GAAH,CAAOpB,KAAP,KAAiB,OAAjB,IAA4BkB,GAAGjD,MAAnC,EAA2C;AACzCgE,YAAQrE,QAAR,CAAiBsE,WAAjB,CAA6B,CAA7B;AACAD,YAAQpE,MAAR,CAAeqE,WAAf,CAA2B,CAA3B;AACAD,YAAQnE,MAAR,CAAeoE,WAAf,CAA2B,IAA3B;AACD,GAJD,MAIO,IAAIhB,GAAGE,GAAH,CAAOpB,KAAX,EAAkB;AACvBiC,YAAQrE,QAAR,CAAiBsE,WAAjB,CAA6B,IAA7B;AACAD,YAAQpE,MAAR,CAAeqE,WAAf,CAA2B,IAA3B;AACAD,YAAQnE,MAAR,CAAeoE,WAAf,CAA2BhB,GAAGE,GAAH,CAAOpB,KAAlC;AACD,GAJM,MAIA,IAAIkB,GAAGE,GAAH,CAAOZ,QAAP,IAAmB,CAAnB,IAAwBU,GAAGE,GAAH,CAAOb,OAAP,GAAiB,CAA7C,EAAgD;AACrD0B,YAAQrE,QAAR,CAAiBsE,WAAjB,CAA6BhB,GAAGE,GAAH,CAAOZ,QAApC;AACAyB,YAAQpE,MAAR,CAAeqE,WAAf,CAA2BhB,GAAGE,GAAH,CAAOb,OAAlC;AACA0B,YAAQnE,MAAR,CAAeoE,WAAf,CAA2B,IAA3B;AACD,GAJM,MAIA;AACL,UAAM,IAAIzB,UAAJ,gCAA4C0B,KAAKC,SAAL,CAAelB,GAAGE,GAAlB,CAA5C,CAAN;AACD;AACF;;AAED;;;AAGA,SAASkB,qBAAT,CAA+BpB,EAA/B,EAAmCe,OAAnC,EAA4C;AAC1C,MAAMM,aAAa/E,QAAQ0C,OAAR,CAAgBgB,GAAGhD,MAAnB,CAAnB;AACA,MAAIqE,cAAc,CAAlB,EAAqB;AACnBN,YAAQ/D,MAAR,CAAegE,WAAf,CAA2BK,UAA3B;AACD,GAFD,MAEO,IAAI,OAAOrB,GAAGhD,MAAV,KAAqB,QAAzB,EAAmC;AACxC+D,YAAQ/D,MAAR,CAAegE,WAAf,CAA2BhB,GAAGhD,MAA9B;AACD,GAFM,MAEA;AACL,UAAM,IAAIuC,UAAJ,mCAA+CS,GAAGhD,MAAlD,CAAN;AACD;AACF;;AAED;;;;;;AAMA,SAASsE,aAAT,CAAuBxC,KAAvB,EAA8ByC,OAA9B,EAAuCR,OAAvC,EAAgD;AAC9C,MAAIS,iBAAJ;AACA,MAAI1C,QAAQ,CAAR,IAAayC,UAAU,CAA3B,EAA8B;AAC5BC,eAAWT,QAAQ7D,MAAR,CAAeuE,WAAf,CAA2B3C,KAA3B,CAAX;AACA,QAAI,CAACyC,OAAL,EAAcA,UAAU9F,WAAWK,UAArB;AACf,GAHD,MAGO;AACL0F,eAAWT,QAAQ7D,MAAR,CAAewE,YAAf,CAA4B5C,KAA5B,CAAX;AACAyC,cAAU9F,WAAWI,WAArB;AACD;AACDkF,UAAQ9D,MAAR,CAAe+D,WAAf,CAA2BQ,YAAY,CAAZ,GAAgBD,OAA3C;AACD;;AAED;;;;AAIA,SAASI,WAAT,CAAqB3B,EAArB,EAAyBe,OAAzB,EAAkC;AAChC,MAAKf,GAAGhD,MAAH,KAAc,KAAd,IAAuBgD,GAAGhD,MAAH,KAAc,KAAtC,IAAgDgD,GAAGlB,KAAH,KAAa,IAAjE,EAAuE;AACrEiC,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BvF,WAAWC,IAAtC;AACD,GAFD,MAEO,IAAIsE,GAAGlB,KAAH,KAAa,KAAjB,EAAwB;AAC7BiC,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BvF,WAAWE,KAAtC;AACD,GAFM,MAEA,IAAIqE,GAAGlB,KAAH,KAAa,IAAjB,EAAuB;AAC5BiC,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BvF,WAAWG,IAAtC;AACD,GAFM,MAEA,IAAI,OAAOoE,GAAGlB,KAAV,KAAoB,QAAxB,EAAkC;AACvC,QAAM0C,WAAWT,QAAQ7D,MAAR,CAAe0E,eAAf,CAA+B5B,GAAGlB,KAAlC,CAAjB;AACAiC,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BQ,YAAY,CAAZ,GAAgB/F,WAAWO,IAAtD;AACD,GAHM,MAGA,IAAI6F,YAAYC,MAAZ,CAAmB9B,GAAGlB,KAAtB,CAAJ,EAAkC;AACvC,QAAM0C,YAAWT,QAAQ7D,MAAR,CAAe6E,cAAf,CAA8B,IAAIjH,UAAJ,CAAekF,GAAGlB,KAAH,CAASkD,MAAxB,CAA9B,CAAjB;AACAjB,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BQ,aAAY,CAAZ,GAAgB/F,WAAWQ,KAAtD;AACD,GAHM,MAGA,IAAI+D,GAAGiC,QAAH,KAAgB,SAAhB,IAA6B,OAAOjC,GAAGlB,KAAV,KAAoB,QAArD,EAA+D;AACpEwC,kBAActB,GAAGlB,KAAjB,EAAwBrD,WAAWS,OAAnC,EAA4C6E,OAA5C;AACD,GAFM,MAEA,IAAIf,GAAGiC,QAAH,KAAgB,WAAhB,IAA+B,OAAOjC,GAAGlB,KAAV,KAAoB,QAAvD,EAAiE;AACtEwC,kBAActB,GAAGlB,KAAjB,EAAwBrD,WAAWU,SAAnC,EAA8C4E,OAA9C;AACD,GAFM,MAEA,IAAI,OAAOf,GAAGiC,QAAV,KAAuB,QAAvB,IAAmCjC,GAAGiC,QAAH,IAAexG,WAAWW,WAA7D,IACA4D,GAAGiC,QAAH,IAAexG,WAAWY,WAD1B,IACyC2D,GAAGlB,KAAH,YAAoBhE,UADjE,EAC6E;AAClF,QAAM0G,aAAWT,QAAQ7D,MAAR,CAAe6E,cAAf,CAA8B/B,GAAGlB,KAAjC,CAAjB;AACAiC,YAAQ9D,MAAR,CAAe+D,WAAf,CAA2BQ,cAAY,CAAZ,GAAgBxB,GAAGiC,QAA9C;AACD,GAJM,MAIA,IAAIjC,GAAGiC,QAAP,EAAiB;AACpB,UAAM,IAAI1C,UAAJ,uBAAmCS,GAAGiC,QAAtC,mBAA4DjC,GAAGlB,KAA/D,CAAN;AACH,GAFM,MAEA,IAAI,OAAOkB,GAAGlB,KAAV,KAAoB,QAAxB,EAAkC;AACvC,QAAIoD,OAAOC,SAAP,CAAiBnC,GAAGlB,KAApB,KAA8BkB,GAAGlB,KAAH,IAAYoD,OAAOE,gBAAjD,IAAqEpC,GAAGlB,KAAH,IAAYoD,OAAOG,gBAA5F,EAA8G;AAC5Gf,oBAActB,GAAGlB,KAAjB,EAAwB,CAAxB,EAA2BiC,OAA3B;AACD,KAFD,MAEO;AACL;AACA,UAAMuB,QAAQ,IAAIT,WAAJ,CAAgB,CAAhB,CAAd;AAAA,UAAkCU,SAAS,IAAIC,QAAJ,CAAaF,KAAb,CAA3C;AACAC,aAAOE,UAAP,CAAkB,CAAlB,EAAqBzC,GAAGlB,KAAxB,EAA+B,IAA/B,EAHK,CAGgC;AACrC,UAAIyD,OAAOG,UAAP,CAAkB,CAAlB,EAAqB,IAArB,MAA+B1C,GAAGlB,KAAtC,EAA6C;AAC3CiC,gBAAQ7D,MAAR,CAAe6E,cAAf,CAA8B,IAAIjH,UAAJ,CAAewH,KAAf,CAA9B;AACAvB,gBAAQ9D,MAAR,CAAe+D,WAAf,CAA2B,KAAK,CAAL,GAASvF,WAAWM,OAA/C;AACD,OAHD,MAGO;AACL,YAAM4G,QAAQ,IAAId,WAAJ,CAAgB,CAAhB,CAAd;AAAA,YAAkCe,SAAS,IAAIJ,QAAJ,CAAaG,KAAb,CAA3C;AACAC,eAAOC,UAAP,CAAkB,CAAlB,EAAqB7C,GAAGlB,KAAxB,EAA+B,IAA/B,EAFK,CAEgC;AACrCiC,gBAAQ7D,MAAR,CAAe6E,cAAf,CAA8B,IAAIjH,UAAJ,CAAe6H,KAAf,CAA9B;AACA5B,gBAAQ9D,MAAR,CAAe+D,WAAf,CAA2B,KAAK,CAAL,GAASvF,WAAWM,OAA/C;AACD;AACF;AACF,GAjBM,MAiBA;AACL,UAAM,IAAIwD,UAAJ,sCAAkDS,GAAGlB,KAArD,CAAN;AACD;AACF;;AAED;;;;;AAKA,SAASgE,WAAT,CAAqBC,SAArB,EAAgCC,SAAhC,EAA2C;AACzC,MAAMC,UAAUF,UAAUG,SAAV,EAAhB;AACA,MAAID,YAAYxH,WAAWC,IAA3B,EAAiC;AAC/B,WAAO,EAACoD,OAAO,IAAR,EAAP;AACD,GAFD,MAEO,IAAImE,YAAYxH,WAAWE,KAA3B,EAAkC;AACvC,WAAO,EAACmD,OAAO,KAAR,EAAP;AACD,GAFM,MAEA,IAAImE,YAAYxH,WAAWG,IAA3B,EAAiC;AACtC,WAAO,EAACkD,OAAO,IAAR,EAAP;AACD,GAFM,MAEA,IAAImE,UAAU,EAAV,KAAiBxH,WAAWO,IAAhC,EAAsC;AAC3C,WAAO,EAAC8C,OAAOkE,UAAUG,aAAV,CAAwBF,WAAW,CAAnC,CAAR,EAAP;AACD,GAFM,MAEA;AACL,QAAMG,QAAQJ,UAAUK,YAAV,CAAuBJ,WAAW,CAAlC,CAAd;AAAA,QAAoDK,aAAa,IAAIjJ,OAAJ,CAAY+I,KAAZ,CAAjE;AACA,QAAIH,UAAU,EAAV,KAAiBxH,WAAWI,WAAhC,EAA6C;AAC3C,aAAO,EAACiD,OAAOwE,WAAWC,UAAX,EAAR,EAAP;AACD,KAFD,MAEO,IAAIN,UAAU,EAAV,KAAiBxH,WAAWK,UAAhC,EAA4C;AACjD,aAAO,EAACgD,OAAOwE,WAAWE,SAAX,EAAR,EAAP;AACD,KAFM,MAEA,IAAIP,UAAU,EAAV,KAAiBxH,WAAWM,OAAhC,EAAyC;AAC9C,UAAM0H,OAAO,IAAIjB,QAAJ,CAAaY,MAAMpB,MAAnB,EAA2BoB,MAAMM,UAAjC,EAA6CN,MAAMO,UAAnD,CAAb;AACA,UAAIP,MAAMO,UAAN,KAAqB,CAAzB,EAA4B;AAC1B,eAAO,EAAC7E,OAAO2E,KAAKf,UAAL,CAAgB,CAAhB,EAAmB,IAAnB,CAAR,CAAkC;AAAlC,SAAP;AACD,OAFD,MAEO,IAAIU,MAAMO,UAAN,KAAqB,CAAzB,EAA4B;AACjC,eAAO,EAAC7E,OAAO2E,KAAKG,UAAL,CAAgB,CAAhB,EAAmB,IAAnB,CAAR,EAAP;AACD,OAFM,MAEA;AACL,cAAM,IAAIrE,UAAJ,gDAA4D6D,MAAMO,UAAlE,CAAN;AACD;AACF,KATM,MASA,IAAIV,UAAU,EAAV,KAAiBxH,WAAWS,OAAhC,EAAyC;AAC9C,aAAO,EAAC4C,OAAOwE,WAAWE,SAAX,EAAR,EAAgCvB,UAAU,SAA1C,EAAP;AACD,KAFM,MAEA,IAAIgB,UAAU,EAAV,KAAiBxH,WAAWU,SAAhC,EAA2C;AAChD,aAAO,EAAC2C,OAAOwE,WAAWE,SAAX,EAAR,EAAgCvB,UAAU,WAA1C,EAAP;AACD,KAFM,MAEA;AACL,aAAO,EAACnD,OAAOsE,KAAR,EAAenB,UAAUgB,UAAU,EAAnC,EAAP;AACD;AACF;AACF;;AAED;;;;;;;;AAQA,SAASY,kBAAT,CAA4B9C,OAA5B,EAAqC+C,QAArC,EAA+C3E,QAA/C,EAAyD4E,MAAzD,EAAiE;AAAA,0BACrBhD,QAAQ+C,QAAR,CADqB;AAAA,MACvDE,QADuD,qBACvDA,QADuD;AAAA,MAC7CC,UAD6C,qBAC7CA,UAD6C;AAAA,MACjCC,OADiC,qBACjCA,OADiC;;AAE/D,MAAIF,WAAW,CAAX,KAAiBhJ,YAAYO,SAA7B,IAA0CuI,WAAW,CAAX,GAAe/C,QAAQJ,MAAjE,IACAI,QAAQ+C,WAAW,CAAnB,EAAsBE,QAAtB,KAAmCA,WAAW,CADlD,EACqD;AAAA,uBACvBlB,YAAYoB,OAAZ,EAAqBnD,QAAQ+C,WAAW,CAAnB,EAAsBI,OAA3C,CADuB;AAAA,QAC3CpF,KAD2C,gBAC3CA,KAD2C;AAAA,QACpCmD,QADoC,gBACpCA,QADoC;;AAEnD8B,WAAOE,UAAP,IAAqBnF,KAArB;AACA,QAAImD,QAAJ,EAAc8B,OAAOE,aAAa,WAApB,IAAmChC,QAAnC;AACd,WAAO,CAAP;AACD,GAND,MAMO,IAAI+B,WAAW,CAAX,KAAiBhJ,YAAYE,QAAjC,EAA2C;AAChD,QAAMoE,WAAW4E,QAAQhB,SAAR,EAAjB;AACA,QAAI5D,aAAa,IAAjB,EAAuB;AACrByE,aAAOE,UAAP,IAAqB,IAArB;AACD,KAFD,MAEO;AACL,UAAI,CAAC9E,SAASG,QAAT,CAAL,EAAyB,MAAM,IAAIC,UAAJ,qBAAiCD,QAAjC,CAAN;AACzByE,aAAOE,UAAP,IAAqB9E,SAASG,QAAT,CAArB;AACD;AACF,GARM,MAQA;AACLyE,WAAOE,UAAP,IAAqBC,QAAQhB,SAAR,EAArB;AACD;AACD,SAAO,CAAP;AACD;;AAED;;;;;;;AAOA,SAASiB,SAAT,CAAmBrE,GAAnB,EAAwBsE,WAAxB,EAAqC;AACnC,MAAMrD,UAAU;AACdvE,cAAY,IAAIlC,UAAJ,CAAe,MAAf,CADE;AAEdmC,YAAY,IAAInC,UAAJ,CAAe,MAAf,CAFE;AAGdoC,cAAY,IAAIpC,UAAJ,CAAe,MAAf,CAHE;AAIdqC,YAAY,IAAInC,YAAJ,EAJE;AAKdoC,YAAY,IAAItC,UAAJ,CAAe,MAAf,CALE;AAMdyC,YAAY,IAAIrC,cAAJ,EANE;AAOdsC,YAAY,IAAI1C,UAAJ,CAAe,MAAf,CAPE;AAQd2C,YAAY,IAAI3C,UAAJ,CAAe,MAAf,CARE;AASd4C,YAAY,IAAI9C,OAAJ,EATE;AAUd+C,eAAY,IAAI7C,UAAJ,CAAe,MAAf,CAVE;AAWd8C,aAAY,IAAI5C,YAAJ;AAXE,GAAhB;;AAcA,MAAI4J,WAAJ,EAAiB;AACfrD,YAAQlE,OAAR,GAAoB,IAAIvC,UAAJ,CAAe,MAAf,CAApB;AACAyG,YAAQjE,KAAR,GAAoB,IAAItC,YAAJ,EAApB;AACAuG,YAAQnD,OAAR,GAAoB,IAAItD,UAAJ,CAAe,MAAf,CAApB;AACAyG,YAAQlD,SAAR,GAAoB,IAAIvD,UAAJ,CAAe,MAAf,CAApB;AACAyG,YAAQjD,OAAR,GAAoB,IAAItD,YAAJ,EAApB;AACD,GAND,MAMO;AACLuG,YAAQvD,OAAR,GAAoB,IAAIlD,UAAJ,CAAe,MAAf,CAApB;AACAyG,YAAQrD,OAAR,GAAoB,IAAIlD,YAAJ,EAApB;AACAuG,YAAQtD,SAAR,GAAoB,IAAInD,UAAJ,CAAe,MAAf,CAApB;AACD;;AAzBkC;AAAA;AAAA;;AAAA;AA2BnC,0BAAewF,GAAf,mIAAoB;AAAA,UAAXE,EAAW;;AAClBc,qBAAed,EAAf,EAAmBe,OAAnB;AACAI,yBAAmBnB,EAAnB,EAAuBe,OAAvB;AACAA,cAAQhE,MAAR,CAAeiE,WAAf,CAA2B,CAAC,CAAChB,GAAGjD,MAAhC;AACAqE,4BAAsBpB,EAAtB,EAA0Be,OAA1B;AACAY,kBAAY3B,EAAZ,EAAgBe,OAAhB;;AAEA,UAAIf,GAAGG,KAAH,CAASd,OAAb,EAAsB;AACpB0B,gBAAQ5D,SAAR,CAAkB6D,WAAlB,CAA8BhB,GAAGG,KAAH,CAASb,QAAvC;AACAyB,gBAAQ3D,OAAR,CAAgB4D,WAAhB,CAA4BhB,GAAGG,KAAH,CAASd,OAArC;AACD,OAHD,MAGO;AACL0B,gBAAQ5D,SAAR,CAAkB6D,WAAlB,CAA8B,IAA9B;AACAD,gBAAQ3D,OAAR,CAAgB4D,WAAhB,CAA4B,IAA5B;AACD;;AAED,UAAIoD,WAAJ,EAAiB;AACfrD,gBAAQlE,OAAR,CAAgBmE,WAAhB,CAA4BhB,GAAGY,EAAH,CAAMtB,QAAlC;AACAyB,gBAAQjE,KAAR,CAAckE,WAAd,CAA0BhB,GAAGY,EAAH,CAAMvB,OAAhC;AACA0B,gBAAQnD,OAAR,CAAgBoD,WAAhB,CAA4BhB,GAAGqE,IAAH,CAAQ1D,MAApC;AACA,aAAK,IAAID,IAAI,CAAb,EAAgBA,IAAIV,GAAGqE,IAAH,CAAQ1D,MAA5B,EAAoCD,GAApC,EAAyC;AACvCK,kBAAQlD,SAAR,CAAkBmD,WAAlB,CAA8BhB,GAAGqE,IAAH,CAAQ3D,CAAR,EAAWpB,QAAzC;AACAyB,kBAAQjD,OAAR,CAAgBkD,WAAhB,CAA4BhB,GAAGqE,IAAH,CAAQ3D,CAAR,EAAWrB,OAAvC;AACD;AACF,OARD,MAQO;AACL0B,gBAAQvD,OAAR,CAAgBwD,WAAhB,CAA4BhB,GAAGI,IAAH,CAAQO,MAApC;AACA,aAAK,IAAID,KAAI,CAAb,EAAgBA,KAAIV,GAAGI,IAAH,CAAQO,MAA5B,EAAoCD,IAApC,EAAyC;AACvCK,kBAAQtD,SAAR,CAAkBuD,WAAlB,CAA8BhB,GAAGI,IAAH,CAAQM,EAAR,EAAWpB,QAAzC;AACAyB,kBAAQrD,OAAR,CAAgBsD,WAAhB,CAA4BhB,GAAGI,IAAH,CAAQM,EAAR,EAAWrB,OAAvC;AACD;AACF;AACF;AAzDkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2DnC,MAAIiF,aAAa,EAAjB;AA3DmC;AAAA;AAAA;;AAAA;AA4DnC,0BAAuBhH,OAAOU,OAAP,CAAeoG,cAAczG,eAAd,GAAgCN,cAA/C,CAAvB,mIAAuF;AAAA;;AAAA;;AAAA,UAA7EkH,IAA6E;AAAA,UAAvE3D,EAAuE;;AACrF,UAAIG,QAAQwD,IAAR,CAAJ,EAAmBD,WAAWjE,IAAX,CAAgB,EAACO,MAAD,EAAK2D,UAAL,EAAWC,SAASzD,QAAQwD,IAAR,CAApB,EAAhB;AACpB;AA9DkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+DnC,SAAOD,WAAW/D,IAAX,CAAgB,UAACkE,CAAD,EAAIC,CAAJ;AAAA,WAAUD,EAAE7D,EAAF,GAAO8D,EAAE9D,EAAnB;AAAA,GAAhB,CAAP;AACD;;AAED;;;;;;AAMA,SAAS+D,SAAT,CAAmB7E,GAAnB,EAAwBsE,WAAxB,EAAqC;AACnC,MAAMQ,SAAS,EAAf;AADmC;AAAA;AAAA;;AAAA;AAEnC,0BAAe9E,GAAf,mIAAoB;AAAA,UAAXE,EAAW;;AAClB,UAAM6E,QAAQ;AACZ5E,aAAKD,GAAGvD,MAAH,KAAc,IAAd,GAAqB3C,OAArB,GAAkCkG,GAAGvD,MAArC,SAA+CuD,GAAGxD,QAD3C;AAEZ0D,aAAKF,GAAGrD,MAAH,KAAc,CAAd,GAAkB,OAAlB,GAA6BqD,GAAGpD,MAAH,IAAgBoD,GAAGrD,MAAnB,SAA6BqD,GAAGtD,QAFtD;AAGZM,gBAAQV,QAAQ0D,GAAGhD,MAAX,KAAsBgD,GAAGhD;AAHrB,OAAd;AAKA6H,YAAM9H,MAAN,GAAe,CAAC,CAACiD,GAAGjD,MAApB;AACA,UAAIT,QAAQ0D,GAAGhD,MAAX,MAAuB,KAAvB,IAAgCV,QAAQ0D,GAAGhD,MAAX,MAAuB,KAA3D,EAAkE;AAChE6H,cAAM/F,KAAN,GAAckB,GAAG/C,MAAjB;AACA,YAAI+C,GAAG8E,eAAP,EAAwBD,MAAM5C,QAAN,GAAiBjC,GAAG8E,eAApB;AACzB;AACD,UAAI,CAAC,CAAC9E,GAAG5C,OAAL,KAAiB,CAAC,CAAC4C,GAAG7C,SAA1B,EAAqC;AACnC,cAAM,IAAIoC,UAAJ,gCAA4CS,GAAG5C,OAA/C,aAA8D4C,GAAG7C,SAAjE,CAAN;AACD;AACD,UAAI6C,GAAG5C,OAAH,KAAe,IAAnB,EAAyByH,MAAM1E,KAAN,GAAiBH,GAAG5C,OAApB,SAA+B4C,GAAG7C,SAAlC;AACzB,UAAIiH,WAAJ,EAAiB;AACfS,cAAMjE,EAAN,GAAcZ,GAAGlD,KAAjB,SAA0BkD,GAAGnD,OAA7B;AACAgI,cAAMR,IAAN,GAAarE,GAAGpC,OAAH,CAAWmC,GAAX,CAAe;AAAA,iBAAWsE,KAAKvG,OAAhB,SAA2BuG,KAAKxG,SAAhC;AAAA,SAAf,CAAb;AACD,OAHD,MAGO;AACLgH,cAAMzE,IAAN,GAAaJ,GAAGxC,OAAH,CAAWuC,GAAX,CAAe;AAAA,iBAAWK,KAAK1C,OAAhB,SAA2B0C,KAAK3C,SAAhC;AAAA,SAAf,CAAb;AACD;AACDmH,aAAOvE,IAAP,CAAYwE,KAAZ;AACD;AAxBkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyBnC,SAAOD,MAAP;AACD;;AAED,SAASG,iBAAT,CAA2Bf,QAA3B,EAAqC;AACnC,MAAI,CAACA,WAAW,CAAZ,MAAmBhJ,YAAYI,SAAnC,EAA8C;AAC5C,WAAO,IAAIZ,YAAJ,EAAP;AACD,GAFD,MAEO,IAAI,CAACwJ,WAAW,CAAZ,MAAmBhJ,YAAYK,OAAnC,EAA4C;AACjD,WAAO,IAAIX,cAAJ,EAAP;AACD,GAFM,MAEA,IAAI,CAACsJ,WAAW,CAAZ,MAAmBhJ,YAAYM,UAAnC,EAA+C;AACpD,WAAO,IAAIhB,UAAJ,CAAe,MAAf,CAAP;AACD,GAFM,MAEA,IAAI,CAAC0J,WAAW,CAAZ,MAAmBhJ,YAAYQ,SAAnC,EAA8C;AACnD,WAAO,IAAIpB,OAAJ,EAAP;AACD,GAFM,MAEA;AACL,WAAO,IAAIE,UAAJ,CAAe,MAAf,CAAP;AACD;AACF;;AAED,SAAS0K,iBAAT,CAA2BhB,QAA3B,EAAqChC,MAArC,EAA6C;AAC3C,MAAI,CAACgC,WAAW,CAAZ,MAAmBhJ,YAAYI,SAAnC,EAA8C;AAC5C,WAAO,IAAIX,YAAJ,CAAiBuH,MAAjB,CAAP;AACD,GAFD,MAEO,IAAI,CAACgC,WAAW,CAAZ,MAAmBhJ,YAAYK,OAAnC,EAA4C;AACjD,WAAO,IAAIV,cAAJ,CAAmBqH,MAAnB,CAAP;AACD,GAFM,MAEA,IAAI,CAACgC,WAAW,CAAZ,MAAmBhJ,YAAYM,UAAnC,EAA+C;AACpD,WAAO,IAAIf,UAAJ,CAAe,MAAf,EAAuByH,MAAvB,CAAP;AACD,GAFM,MAEA,IAAI,CAACgC,WAAW,CAAZ,MAAmBhJ,YAAYQ,SAAnC,EAA8C;AACnD,WAAO,IAAInB,OAAJ,CAAY2H,MAAZ,CAAP;AACD,GAFM,MAEA;AACL,WAAO,IAAIzH,UAAJ,CAAe,MAAf,EAAuByH,MAAvB,CAAP;AACD;AACF;;AAED,SAASiD,YAAT,CAAsBlE,OAAtB,EAA+BmE,UAA/B,EAA2C;AACzC;AACA,MAAMC,WAAWrK,WAAWC,EAAX,EAAjB;AAAA,MAAkCqK,WAAW,EAA7C;AAFyC;AAAA;AAAA;;AAAA;AAGzC,0BAAmC9H,OAAOU,OAAP,CAAekH,UAAf,CAAnC,mIAA+D;AAAA;;AAAA;;AAAA,UAArDjB,UAAqD;AAAA,UAAzCD,QAAyC;;AAC7DoB,eAASpB,QAAT,IAAqBgB,kBAAkBhB,QAAlB,EAA4BmB,QAA5B,CAArB;AACD;AALwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAMzC,0BAAmBpE,OAAnB,mIAA4B;AAAA,UAAnBsE,MAAmB;;AAC1BD,eAASC,OAAOrB,QAAhB,IAA4BgB,kBAAkBK,OAAOrB,QAAzB,EAAmCqB,OAAOrD,MAA1C,CAA5B;AACD;AARwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUzC,MAAI+B,SAAS,EAAb;;AAVyC,6BAWhCC,SAXgC;AAAA,+BAYjB1G,OAAOU,OAAP,CAAekH,UAAf,EAA2BI,IAA3B,CAAgC;AAAA;AAAA,UAAEf,IAAF;AAAA,UAAQ3D,EAAR;;AAAA,aAAgBA,OAAOoD,SAAvB;AAAA,KAAhC,CAZiB;AAAA;AAAA,QAYlCC,UAZkC;AAAA,QAYtBsB,CAZsB;;AAavC,QAAI,CAACtB,UAAL,EAAiBA,aAAaD,UAASwB,QAAT,EAAb;AACjBzB,WAAO1D,IAAP,CAAY,EAAC2D,mBAAD,EAAWC,sBAAX,EAAuBC,SAASkB,SAASpB,SAAT,CAAhC,EAAZ;AAduC;;AAAA;AAAA;AAAA;;AAAA;AAWzC,0BAAqB1G,OAAOgD,IAAP,CAAY8E,QAAZ,EAAsBrF,GAAtB,CAA0B;AAAA,aAAM0F,SAAS7E,EAAT,CAAN;AAAA,KAA1B,EAA8CL,IAA9C,CAAmD,UAACkE,CAAD,EAAIC,CAAJ;AAAA,aAAUD,IAAIC,CAAd;AAAA,KAAnD,CAArB,mIAA0F;AAAA,UAAjFV,SAAiF;;AAAA,YAAjFA,SAAiF;AAIzF;AAfwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBzC,SAAOD,MAAP;AACD;;AAED,SAAS2B,aAAT,CAAuB3E,OAAvB,EAAgC5B,QAAhC,EAA0C+F,UAA1C,EAAsD;AACpDnE,YAAUkE,aAAalE,OAAb,EAAsBmE,UAAtB,CAAV;AACA,MAAIS,aAAa,EAAjB;AACA,SAAO5E,QAAQ6E,IAAR,CAAa;AAAA,WAAO,CAACC,IAAI3B,OAAJ,CAAY4B,IAApB;AAAA,GAAb,CAAP,EAA+C;AAC7C,QAAIC,MAAM,EAAV;AAAA,QAAcF,MAAM,CAApB;AACA,WAAOA,MAAM9E,QAAQJ,MAArB,EAA6B;AAC3B,UAAMqD,WAAWjD,QAAQ8E,GAAR,EAAa7B,QAA9B;AACA,UAAIgC,UAAUhC,YAAY,CAA1B;AAAA,UAA6BiC,YAAY,CAAzC;AACA,aAAOJ,MAAMI,SAAN,GAAkBlF,QAAQJ,MAA1B,IAAoCI,QAAQ8E,MAAMI,SAAd,EAAyBjC,QAAzB,IAAqC,CAArC,KAA2CgC,OAAtF,EAA+F;AAC7FC;AACD;;AAED,UAAIjC,WAAW,CAAX,KAAiBhJ,YAAYC,UAAjC,EAA6C;AAC3C,YAAMiL,SAAS,EAAf;AAAA,YAAmBC,QAAQpF,QAAQ8E,GAAR,EAAa3B,OAAb,CAAqBhB,SAArB,EAA3B;AACA,aAAK,IAAIxC,IAAI,CAAb,EAAgBA,IAAIyF,KAApB,EAA2BzF,GAA3B,EAAgC;AAC9B,cAAI5B,QAAQ,EAAZ;AACA,eAAK,IAAIsH,YAAY,CAArB,EAAwBA,YAAYH,SAApC,EAA+CG,WAA/C,EAA4D;AAC1DvC,+BAAmB9C,OAAnB,EAA4B8E,MAAMO,SAAlC,EAA6CjH,QAA7C,EAAuDL,KAAvD;AACD;AACDoH,iBAAO7F,IAAP,CAAYvB,KAAZ;AACD;AACDiH,YAAIhF,QAAQ8E,GAAR,EAAa5B,UAAjB,IAA+BiC,MAA/B;AACAL,eAAOI,SAAP;AACD,OAXD,MAWO;AACLJ,eAAOhC,mBAAmB9C,OAAnB,EAA4B8E,GAA5B,EAAiC1G,QAAjC,EAA2C4G,GAA3C,CAAP;AACD;AACF;AACDJ,eAAWtF,IAAX,CAAgB0F,GAAhB;AACD;AACD,SAAOJ,UAAP;AACD;;AAED,SAASU,WAAT,CAAqBnC,OAArB,EAAoE;AAAA,MAAtCoC,UAAsC,uEAAzBpE,OAAOE,gBAAkB;;AAClE,MAAImE,eAAe,CAAC,CAApB;AAAA,MAAuBxF,UAAU,EAAjC;AACA,SAAO,CAACmD,QAAQ4B,IAAT,IAAiB/E,QAAQJ,MAAR,GAAiB2F,UAAzC,EAAqD;AACnD,QAAMtC,WAAWE,QAAQsC,UAAR,EAAjB;AACA,QAAMC,YAAYvC,QAAQwC,iBAAR,EAAlB;AACA,QAAI1C,YAAYuC,YAAhB,EAA8B,MAAM,IAAIhH,UAAJ,CAAe,oCAAf,CAAN;AAC9BgH,mBAAevC,QAAf;AACAjD,YAAQV,IAAR,CAAa,EAAC2D,kBAAD,EAAWhC,QAAQyE,SAAnB,EAAb;AACD;AACD,SAAO1F,OAAP;AACD;;AAED,SAAS4F,kBAAT,CAA4BzC,OAA5B,EAAqC;AACnC,MAAIrE,SAAS;AACXvB,WAAS4F,QAAQ0C,aAAR,EADE;AAEXrI,SAAS2F,QAAQX,UAAR,EAFE;AAGX1C,aAASqD,QAAQX,UAAR,EAHE;AAIX9E,UAASyF,QAAQV,SAAR,EAJE;AAKX9E,aAASwF,QAAQ2C,kBAAR,EALE;AAMXC,UAAM;AANK,GAAb;AAQA,MAAM3H,WAAW,CAACU,OAAOvB,KAAR,CAAjB;AAAA,MAAiCyI,cAAc7C,QAAQX,UAAR,EAA/C;AACA,OAAK,IAAI7C,IAAI,CAAb,EAAgBA,IAAIqG,WAApB,EAAiCrG,GAAjC;AAAsCvB,aAASkB,IAAT,CAAc6D,QAAQ0C,aAAR,EAAd;AAAtC,GACA,IAAMI,UAAU9C,QAAQX,UAAR,EAAhB;AACA,OAAK,IAAI7C,MAAI,CAAb,EAAgBA,MAAIsG,OAApB,EAA6BtG,KAA7B,EAAkC;AAChCb,WAAOiH,IAAP,CAAYzG,IAAZ,CAAiBlG,iBAAiB+J,QAAQb,YAAR,CAAqB,EAArB,CAAjB,CAAjB;AACD;AACDxD,SAAOV,QAAP,GAAkBA,QAAlB;AACA,SAAOU,MAAP;AACD;;AAED;;;;;AAKA,SAASoH,eAAT,CAAyBC,SAAzB,EAAoCnG,OAApC,EAA6CoG,oBAA7C,EAAmE;AACjE,MAAMC,gBAAgB,CAAtB,CADiE,CACzC;AACxB,MAAMC,eAAexM,YAAY8I,UAAZ,GAAyByD,aAAzB,GAAyC,CAAzC,GAA6C,CAAlE,CAFiE,CAEG;AACpE,MAAME,OAAO,IAAIlN,OAAJ,EAAb;AACA;AACA;AACA;AACAkN,OAAKvF,cAAL,CAAoB,IAAIjH,UAAJ,CAAeuM,YAAf,CAApB;AACAF,uBAAqBG,IAArB;;AARiE;AAAA;AAAA;;AAAA;AAUjE,2BAAmBvG,OAAnB,wIAA4B;AAAA,UAAnBsE,MAAmB;;AAC1B,UAAMrD,SAASqD,OAAOb,OAAP,CAAexC,MAA9B;AACA,UAAIA,OAAO2B,UAAP,GAAoB,CAAxB,EAA2B;AACzB;AACA2D,aAAK5F,YAAL,CAAkB2D,OAAOzE,EAAzB;AACA0G,aAAKC,mBAAL,CAAyBvF,MAAzB;AACD;AACF;AAjBgE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmBjE,MAAMwF,UAAUF,KAAKtF,MAArB;AACA,MAAMyF,SAAS,IAAIrN,OAAJ,EAAf;AACA,MAAI8M,cAAc,UAAlB,EAA8B;AAC5BO,WAAOC,UAAP,CAAkB,CAAlB;AACD,GAFD,MAEO,IAAIR,cAAc,QAAlB,EAA4B;AACjCO,WAAOC,UAAP,CAAkB,CAAlB;AACD,GAFM,MAEA;AACL,UAAM,IAAInI,UAAJ,8BAA0C2H,SAA1C,CAAN;AACD;AACDO,SAAO/F,YAAP,CAAoB8F,QAAQ7D,UAAR,GAAqB0D,YAAzC;;AAEA;AACA,MAAMM,YAAYF,OAAOzF,MAAzB;AACA,MAAM4F,SAAS,IAAIhN,IAAJ,EAAf;AACAgN,SAAOC,MAAP,CAAcF,SAAd;AACAC,SAAOC,MAAP,CAAcL,QAAQM,QAAR,CAAiBT,YAAjB,CAAd;AACA,MAAMU,OAAOH,OAAOI,MAAP,EAAb;AAAA,MAA8BC,WAAWF,KAAKD,QAAL,CAAc,CAAd,EAAiBV,aAAjB,CAAzC;;AAEA;AACAI,UAAQU,GAAR,CAAYrN,WAAZ,EAAyBwM,eAAeM,UAAUhE,UAAzB,GAAsCyD,aAAtC,GAAsDvM,YAAY8I,UAA3F;AACA6D,UAAQU,GAAR,CAAYD,QAAZ,EAAyBZ,eAAeM,UAAUhE,UAAzB,GAAsCyD,aAA/D;AACAI,UAAQU,GAAR,CAAYP,SAAZ,EAAyBN,eAAeM,UAAUhE,UAAlD;AACA;AACA,SAAO,EAACoE,UAAD,EAAO3E,OAAOoE,QAAQM,QAAR,CAAkBT,eAAeM,UAAUhE,UAAzB,GAAsCyD,aAAtC,GAAsDvM,YAAY8I,UAApF,CAAd,EAAP;AACD;;AAED,SAASwE,qBAAT,CAA+BjE,OAA/B,EAAwCkE,WAAxC,EAAqD;AACnD,MAAI,CAACnO,WAAWiK,QAAQb,YAAR,CAAqBxI,YAAY8I,UAAjC,CAAX,EAAyD9I,WAAzD,CAAL,EAA4E;AAC1E,UAAM,IAAI0E,UAAJ,CAAe,kDAAf,CAAN;AACD;AACD,MAAM8I,eAAenE,QAAQb,YAAR,CAAqB,CAArB,CAArB;AACA,MAAMiF,kBAAkBpE,QAAQqE,MAAhC;AACA,MAAMrB,YAAYhD,QAAQsE,QAAR,EAAlB;AACA,MAAMC,cAAcvE,QAAQX,UAAR,EAApB;AACA,MAAMkE,SAAS,EAACP,oBAAD,EAAYuB,wBAAZ,EAAyBC,WAAWxE,QAAQb,YAAR,CAAqBoF,WAArB,CAApC,EAAf;;AAEA,MAAIL,WAAJ,EAAiB;AACf,QAAMR,SAAS,IAAIhN,IAAJ,EAAf;AACAgN,WAAOC,MAAP,CAAc3D,QAAQyE,GAAR,CAAYb,QAAZ,CAAqBQ,eAArB,EAAsCpE,QAAQqE,MAA9C,CAAd;AACA,QAAMK,aAAahB,OAAOI,MAAP,EAAnB;AACA,QAAI,CAAC/N,WAAW2O,WAAWd,QAAX,CAAoB,CAApB,EAAuB,CAAvB,CAAX,EAAsCO,YAAtC,CAAL,EAA0D;AACxD,YAAM,IAAI9I,UAAJ,CAAe,8BAAf,CAAN;AACD;AACDkI,WAAOM,IAAP,GAAc5N,iBAAiByO,UAAjB,CAAd;AACD;AACD,SAAOnB,MAAP;AACD;;AAED,SAASoB,YAAT,CAAsBC,SAAtB,EAAiC;AAAA,uBACDtJ,cAAc,CAACsJ,SAAD,CAAd,EAA2B,IAA3B,CADC;AAAA,MACvBrJ,OADuB,kBACvBA,OADuB;AAAA,MACdN,QADc,kBACdA,QADc;;AAE/B,MAAMU,SAASJ,QAAQ,CAAR,CAAf;;AAF+B,yBAIPwH,gBAAgB,QAAhB,EAA0B9C,UAAUtE,OAAOC,GAAjB,EAAsB,KAAtB,CAA1B,EAAwD,mBAAW;AACzF0E,YAAQuE,eAAR,CAAwBlJ,OAAOvB,KAA/B;AACAkG,YAAQ9C,YAAR,CAAqB7B,OAAOtB,GAA5B;AACAiG,YAAQ9C,YAAR,CAAqB7B,OAAOgB,OAA5B;AACA2D,YAAQ/C,WAAR,CAAoB5B,OAAOpB,IAA3B;AACA+F,YAAQwE,oBAAR,CAA6BnJ,OAAOnB,OAAP,IAAkB,EAA/C;AACA8F,YAAQ9C,YAAR,CAAqBvC,SAASwB,MAAT,GAAkB,CAAvC;AANyF;AAAA;AAAA;;AAAA;AAOzF,6BAAkBxB,SAAS8J,KAAT,CAAe,CAAf,CAAlB;AAAA,YAAS3K,KAAT;AAAqCkG,gBAAQuE,eAAR,CAAwBzK,KAAxB;AAArC;AAPyF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQzF,QAAI,CAAC4K,MAAMC,OAAN,CAActJ,OAAOiH,IAArB,CAAL,EAAiC,MAAM,IAAIsC,SAAJ,CAAc,sBAAd,CAAN;AACjC5E,YAAQ9C,YAAR,CAAqB7B,OAAOiH,IAAP,CAAYnG,MAAjC;AATyF;AAAA;AAAA;;AAAA;AAUzF,6BAAiBd,OAAOiH,IAAP,CAAYmC,KAAZ,GAAoB1I,IAApB,EAAjB,wIAA6C;AAAA,YAApCwH,KAAoC;;AAC3CvD,gBAAQzC,cAAR,CAAuB7H,iBAAiB6N,KAAjB,CAAvB;AACD;AAZwF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAa1F,GAbuB,CAJO;AAAA,MAIvBA,IAJuB,oBAIvBA,IAJuB;AAAA,MAIjB3E,KAJiB,oBAIjBA,KAJiB;;AAmB/B,MAAMiG,UAAUlP,iBAAiB4N,IAAjB,CAAhB;AACA,MAAIe,UAAUf,IAAV,IAAkBe,UAAUf,IAAV,KAAmBsB,OAAzC,EAAkD;AAChD,UAAM,IAAI9J,UAAJ,2CAAuDuJ,UAAUf,IAAjE,YAA4EsB,OAA5E,CAAN;AACD;AACD,SAAOjG,KAAP;AACD;;AAED,SAASkG,mBAAT,CAA6BtH,MAA7B,EAAqC;AACnC,MAAMkC,UAAU,IAAI7J,OAAJ,CAAY2H,MAAZ,CAAhB;AACA,MAAMyF,SAASU,sBAAsBjE,OAAtB,EAA+B,IAA/B,CAAf;AACA,MAAMqF,eAAe,IAAIlP,OAAJ,CAAYoN,OAAOiB,SAAnB,CAArB;AACA,MAAI,CAACxE,QAAQ4B,IAAb,EAAmB,MAAM,IAAIvG,UAAJ,CAAe,kCAAf,CAAN;AACnB,MAAIkI,OAAOP,SAAP,KAAqB,CAAzB,EAA4B,MAAM,IAAI3H,UAAJ,6BAAyCkI,OAAOP,SAAhD,CAAN;;AAE5B,MAAMrH,SAAS8G,mBAAmB4C,YAAnB,CAAf;AACA1J,SAAOkI,IAAP,GAAcN,OAAOM,IAArB;AACAlI,SAAOkB,OAAP,GAAiBsF,YAAYkD,YAAZ,CAAjB;AACA,SAAO1J,MAAP;AACD;;AAED;;;AAGA,SAAS2J,YAAT,CAAsBxH,MAAtB,EAA8B;AAC5B,MAAMnC,SAASyJ,oBAAoBtH,MAApB,CAAf;AACAnC,SAAOC,GAAP,GAAa6E,UAAUe,cAAc7F,OAAOkB,OAArB,EAA8BlB,OAAOV,QAArC,EAA+C9B,cAA/C,CAAV,EAA0E,KAA1E,CAAb;AACA,SAAOwC,OAAOV,QAAd;AACA,SAAOU,OAAOkB,OAAd;AACA,SAAOlB,MAAP;AACD;;AAED;;;;;AAKA,SAAS4J,gBAAT,CAA0BzH,MAA1B,EAAkCoG,WAAlC,EAA+C;AAC7C,MAAMX,SAASU,sBAAsB,IAAI9N,OAAJ,CAAY2H,MAAZ,CAAtB,EAA2CoG,WAA3C,CAAf;AACA,MAAIX,OAAOP,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAI3H,UAAJ,CAAe,mCAAf,CAAN;AACD;AACD,MAAMmK,OAAO/C,mBAAmB,IAAItM,OAAJ,CAAYoN,OAAOiB,SAAnB,CAAnB,CAAb;AACA,MAAIN,WAAJ,EAAiBsB,KAAK3B,IAAL,GAAYN,OAAOM,IAAnB;AACjB,SAAO2B,IAAP;AACD;;AAED;;;;AAIA,SAASC,eAAT,CAAyB3H,MAAzB,EAAiC;AAC/B,MAAIkC,UAAU,IAAI7J,OAAJ,CAAY2H,MAAZ,CAAd;AAAA,MAAmC4H,SAAS,EAA5C;AAAA,MAAgDC,cAAc,CAA9D;AACA,SAAO,CAAC3F,QAAQ4B,IAAhB,EAAsB;AACpBqC,0BAAsBjE,OAAtB,EAA+B,KAA/B;AACA0F,WAAOvJ,IAAP,CAAY2B,OAAO8F,QAAP,CAAgB+B,WAAhB,EAA6B3F,QAAQqE,MAArC,CAAZ;AACAsB,kBAAc3F,QAAQqE,MAAtB;AACD;AACD,SAAOqB,MAAP;AACD;;AAED;;;;AAIA,SAASE,aAAT,CAAuBC,aAAvB,EAAsC;AACpC,MAAIC,UAAU,EAAd;AADoC;AAAA;AAAA;;AAAA;AAEpC,2BAAyBD,aAAzB,wIAAwC;AAAA,UAA/BE,YAA+B;AAAA;AAAA;AAAA;;AAAA;AACtC,+BAAkBN,gBAAgBM,YAAhB,CAAlB,wIAAiD;AAAA,cAAxCC,KAAwC;;AAC/C,cAAIA,MAAM,CAAN,MAAa,CAAjB,EAAoB;AAClBF,sBAAUA,QAAQxJ,MAAR,CAAe2J,eAAeD,KAAf,CAAf,CAAV;AACD,WAFD,MAEO,IAAIA,MAAM,CAAN,MAAa,CAAjB,EAAoB;AACzBF,oBAAQ3J,IAAR,CAAamJ,aAAaU,KAAb,CAAb;AACD,WAFM,MAEA;AACL;AACD;AACF;AATqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUvC;AAZmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAapC,SAAOF,OAAP;AACD;;AAED,SAASI,SAAT,CAAmB3F,CAAnB,EAAsBC,CAAtB,EAAyB;AACvB,MAAID,MAAMC,CAAV,EAAa,OAAO,CAAP;AACb,MAAID,MAAM3K,OAAV,EAAmB,OAAO,CAAC,CAAR;AACnB,MAAI4K,MAAM5K,OAAV,EAAmB,OAAO,CAAC,CAAR;AACnB,MAAMuQ,KAAKrQ,UAAUyK,CAAV,CAAX;AAAA,MAAyB6F,KAAKtQ,UAAU0K,CAAV,CAA9B;AACA,MAAI2F,GAAGhL,OAAH,GAAaiL,GAAGjL,OAApB,EAA6B,OAAO,CAAC,CAAR;AAC7B,MAAIgL,GAAGhL,OAAH,GAAaiL,GAAGjL,OAApB,EAA6B,OAAO,CAAC,CAAR;AAC7B,MAAIgL,GAAGjL,OAAH,GAAakL,GAAGlL,OAApB,EAA6B,OAAO,CAAC,CAAR;AAC7B,MAAIiL,GAAGjL,OAAH,GAAakL,GAAGlL,OAApB,EAA6B,OAAO,CAAC,CAAR;AAC7B,SAAO,CAAP;AACD;;AAED,SAASmL,gBAAT,CAA0B9K,OAA1B,EAAmC;AACjC,MAAI+K,aAAa,EAAjB;AAAA,MAAqBC,cAAc,EAAnC;AAAA,MAAuCC,aAAa,EAApD;AADiC;AAAA;AAAA;;AAAA;AAEjC,2BAAmBjL,OAAnB,wIAA4B;AAAA,UAAnBI,MAAmB;;AAC1B,WAAK,IAAIa,IAAI,CAAb,EAAgBA,IAAIb,OAAOC,GAAP,CAAWa,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C,YAAMV,KAAKH,OAAOC,GAAP,CAAWY,CAAX,CAAX;AAAA,YAA0BxB,OAAUc,GAAGY,EAAH,CAAMvB,OAAhB,SAA2BW,GAAGY,EAAH,CAAMxB,OAA3D;AACA,YAAMuL,YAAY3K,GAAGC,GAAH,CAAOnB,KAAP,KAAiBhF,OAAlB,GAA6BA,OAA7B,GAA0CkG,GAAGC,GAAH,CAAOZ,OAAjD,SAA4DW,GAAGC,GAAH,CAAOb,OAApF;AACA,YAAIY,GAAGhD,MAAH,CAAU4N,UAAV,CAAqB,MAArB,CAAJ,EAAkC;AAChCF,qBAAWxL,IAAX,IAAmBc,GAAGhD,MAAtB;AACA,cAAIgD,GAAGhD,MAAH,KAAc,UAAd,IAA4BgD,GAAGhD,MAAH,KAAc,UAA9C,EAA0D;AACxDyN,wBAAYvL,IAAZ,IAAoB,EAAC,SAAS,EAAV,EAApB;AACD;AACF;;AAED,YAAIgB,YAAJ;AACA,YAAIyK,cAAa7Q,OAAb,IAAwB4Q,WAAWC,SAAX,MAAyB,SAAjD,IAA8DD,WAAWC,SAAX,MAAyB,WAA3F,EAAwG;AACtGzK,gBAAMF,GAAGE,GAAH,CAAOpB,KAAb;AACD,SAFD,MAEO,IAAI4L,WAAWC,SAAX,MAAyB,UAAzB,IAAuCD,WAAWC,SAAX,MAAyB,UAApE,EAAgF;AACrF,cAAI3K,GAAGjD,MAAP,EAAe;AACbmD,kBAAMhB,IAAN;AACA,gBAAM2L,MAAO7K,GAAGE,GAAH,CAAOpB,KAAP,KAAiB,OAAlB,GAA6B,OAA7B,GAA0CkB,GAAGE,GAAH,CAAOb,OAAjD,SAA4DW,GAAGE,GAAH,CAAOd,OAA/E;AACAqL,wBAAYE,SAAZ,EAAsBE,GAAtB,EAA2BxK,IAA3B,CAAgCnB,IAAhC;AACAuL,wBAAYE,SAAZ,EAAsBzL,IAAtB,IAA8B,EAA9B;AACD,WALD,MAKO;AACLgB,kBAASF,GAAGE,GAAH,CAAOb,OAAhB,SAA2BW,GAAGE,GAAH,CAAOd,OAAlC;AACD;AACF,SATM,MASA;AACL,gBAAM,IAAIG,UAAJ,qCAAiDoL,SAAjD,CAAN;AACD;;AAED,YAAI,CAACH,WAAWG,SAAX,CAAL,EAA2BH,WAAWG,SAAX,IAAuB,EAAvB;AAC3B,YAAI,CAACH,WAAWG,SAAX,EAAqBzK,GAArB,CAAL,EAAgCsK,WAAWG,SAAX,EAAqBzK,GAArB,IAA4B,EAA5B;AAChCsK,mBAAWG,SAAX,EAAqBzK,GAArB,EAA0BhB,IAA1B,IAAkCc,EAAlC;AACAA,WAAGqE,IAAH,GAAU,EAAV;;AA7B0C;AAAA;AAAA;;AAAA;AA+B1C,iCAAiBrE,GAAGI,IAApB,wIAA0B;AAAA,gBAAjBA,IAAiB;;AACxB,gBAAM0K,SAAY1K,KAAKf,OAAjB,SAA4Be,KAAKhB,OAAvC;AACA,gBAAI,CAACoL,WAAWG,SAAX,EAAqBzK,GAArB,EAA0B4K,MAA1B,CAAL,EAAwC;AACtC,oBAAM,IAAIvL,UAAJ,+BAA2CuL,MAA3C,CAAN;AACD;AACDN,uBAAWG,SAAX,EAAqBzK,GAArB,EAA0B4K,MAA1B,EAAkCzG,IAAlC,CAAuChE,IAAvC,CAA4CL,GAAGY,EAA/C;AACD;AArCyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsC3C;AACF;AA1CgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4CjC,MAAId,MAAM,EAAV;AA5CiC;AAAA;AAAA;;AAAA;AA6CjC,2BAAqBxC,OAAOgD,IAAP,CAAYkK,UAAZ,EAAwBjK,IAAxB,CAA6B6J,SAA7B,CAArB,wIAA8D;AAAA,UAArDO,QAAqD;;AAC5D,UAAIrK,OAAO,EAAX;AACA,UAAIoK,WAAWC,QAAX,MAAyB,UAAzB,IAAuCD,WAAWC,QAAX,MAAyB,UAApE,EAAgF;AAC9E,YAAII,QAAQ,CAAC,OAAD,CAAZ;AACA,eAAOA,MAAMpK,MAAN,GAAe,CAAtB,EAAyB;AACvB,cAAMT,OAAM6K,MAAMC,GAAN,EAAZ;AACA,cAAI9K,SAAQ,OAAZ,EAAqBI,KAAKD,IAAL,CAAUH,IAAV;AAFE;AAAA;AAAA;;AAAA;AAGvB,mCAAiBuK,YAAYE,QAAZ,EAAsBzK,IAAtB,EAA2BK,IAA3B,CAAgC6J,SAAhC,CAAjB;AAAA,kBAASlL,KAAT;AAA6D6L,oBAAM1K,IAAN,CAAWnB,KAAX;AAA7D;AAHuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIxB;AACF,OAPD,MAOO;AACL;AACA;AACAoB,eAAOhD,OAAOgD,IAAP,CAAYkK,WAAWG,QAAX,CAAZ,EAAkCpK,IAAlC,EAAP;AACD;;AAb2D;AAAA;AAAA;;AAAA;AAe5D,+BAAgBD,IAAhB,wIAAsB;AAAA,cAAbJ,KAAa;AAAA;AAAA;AAAA;;AAAA;AACpB,mCAAiB5C,OAAOgD,IAAP,CAAYkK,WAAWG,QAAX,EAAqBzK,KAArB,CAAZ,EAAuCK,IAAvC,CAA4C6J,SAA5C,CAAjB,wIAAyE;AAAA,kBAAhElL,MAAgE;;AACvE,kBAAMc,MAAKwK,WAAWG,QAAX,EAAqBzK,KAArB,EAA0BhB,MAA1B,CAAX;AACA,kBAAIc,IAAGhD,MAAH,KAAc,KAAlB,EAAyB8C,IAAIO,IAAJ,CAASL,GAAT;AAC1B;AAJmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKrB;AApB2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqB7D;AAlEgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmEjC,SAAOF,GAAP;AACD;;AAED;;;;;AAKA,SAASmL,cAAT,CAAwBxL,OAAxB,EAAiCK,GAAjC,EAAsC;AACpC,MAAIoL,iBAAiB,EAArB,CADoC,CACZ;AADY;AAAA;AAAA;;AAAA;AAEpC,2BAAmBzL,OAAnB,wIAA4B;AAAA,UAAnBI,MAAmB;;AAC1BA,aAAOC,GAAP,GAAa,EAAb;AACA,UAAI,CAACoL,eAAerL,OAAOvB,KAAtB,CAAL,EAAmC4M,eAAerL,OAAOvB,KAAtB,IAA+B,EAA/B;AACnC,UAAIuB,OAAOtB,GAAP,KAAe2M,eAAerL,OAAOvB,KAAtB,EAA6BqC,MAA7B,GAAsC,CAAzD,EAA4D;AAC1D,cAAM,IAAIpB,UAAJ,sBAAiC2L,eAAerL,OAAOvB,KAAtB,EAA6BqC,MAA7B,GAAsC,CAAvE,eAAiFd,OAAOtB,GAAxF,CAAN;AACD;AACD,UAAIsB,OAAOtB,GAAP,GAAa,CAAb,IAAkB2M,eAAerL,OAAOvB,KAAtB,EAA6BuB,OAAOtB,GAAP,GAAa,CAA1C,EAA6CC,KAA7C,GAAqDqB,OAAOrB,KAAlF,EAAyF;AACvF,cAAM,IAAIe,UAAJ,CAAe,6CAAf,CAAN;AACD;AACD2L,qBAAerL,OAAOvB,KAAtB,EAA6B+B,IAA7B,CAAkCR,MAAlC;AACD;AAZmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcpC,MAAIsL,UAAU,EAAd;AAdoC;AAAA;AAAA;;AAAA;AAepC,2BAAerL,GAAf,wIAAoB;AAAA,UAAXE,EAAW;;AAClB,UAAIA,GAAGhD,MAAH,KAAc,KAAlB,EAAyB,MAAM,IAAIuC,UAAJ,CAAe,4CAAf,CAAN;AACzBS,SAAGI,IAAH,GAAU+K,QAAQnL,GAAGY,EAAX,IAAiBuK,QAAQnL,GAAGY,EAAX,EAAeR,IAAhC,GAAuC,EAAjD;AACA+K,cAAQnL,GAAGY,EAAX,IAAiBZ,EAAjB;AAHkB;AAAA;AAAA;;AAAA;AAIlB,+BAAiBA,GAAGqE,IAApB,wIAA0B;AAAA,cAAjBA,IAAiB;;AACxB,cAAI,CAAC8G,QAAQ9G,IAAR,CAAL,EAAoB;AAClB,gBAAMnE,MAAMF,GAAGjD,MAAH,GAAYiD,GAAGY,EAAf,GAAoBZ,GAAGE,GAAnC;AACAiL,oBAAQ9G,IAAR,IAAgB,EAACzD,IAAIyD,IAAL,EAAWrH,QAAQ,KAAnB,EAA0BiD,KAAKD,GAAGC,GAAlC,EAAuCC,QAAvC,EAA4CE,MAAM,EAAlD,EAAhB;AACD;AACD+K,kBAAQ9G,IAAR,EAAcjE,IAAd,CAAmBC,IAAnB,CAAwBL,GAAGY,EAA3B;AACD;AAViB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWlB,aAAOZ,GAAGqE,IAAV;AACD;AA3BmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AA4BpC,2BAAe/G,OAAO4I,MAAP,CAAciF,OAAd,CAAf,wIAAuC;AAAA,UAA9BnL,IAA8B;;AACrC,UAAIA,KAAGhD,MAAH,KAAc,KAAlB,EAAyB8C,IAAIO,IAAJ,CAASL,IAAT;AAC1B;AA9BmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAgCpC,2BAAeF,GAAf,wIAAoB;AAAA,UAAXE,IAAW;;AAAA,uBACWhG,UAAUgG,KAAGY,EAAb,CADX;AAAA,UACVvB,OADU,cACVA,OADU;AAAA,UACDD,OADC,cACDA,OADC;;AAElB,UAAMgM,eAAeF,eAAe9L,OAAf,CAArB;AACA;AACA,UAAIiM,OAAO,CAAX;AAAA,UAAcC,QAAQF,aAAazK,MAAnC;AACA,aAAO0K,OAAOC,KAAd,EAAqB;AACnB,YAAMC,QAAQC,KAAKC,KAAL,CAAW,CAACJ,OAAOC,KAAR,IAAiB,CAA5B,CAAd;AACA,YAAIF,aAAaG,KAAb,EAAoB/M,KAApB,GAA4Ba,OAAhC,EAAyC;AACvCgM,iBAAOE,QAAQ,CAAf;AACD,SAFD,MAEO;AACLD,kBAAQC,KAAR;AACD;AACF;AACD,UAAIF,QAAQD,aAAazK,MAAzB,EAAiC;AAC/B,cAAM,IAAIpB,UAAJ,mBAA+BS,KAAGY,EAAlC,+BAAN;AACD;AACDwK,mBAAaC,IAAb,EAAmBvL,GAAnB,CAAuBO,IAAvB,CAA4BL,IAA5B;AACD;AAjDmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAmDpC,2BAAmBP,OAAnB,wIAA4B;AAAA,UAAnBI,QAAmB;;AAC1BA,eAAOC,GAAP,CAAWS,IAAX,CAAgB,UAACmL,GAAD,EAAMC,GAAN;AAAA,eAAcvB,UAAUsB,IAAI9K,EAAd,EAAkB+K,IAAI/K,EAAtB,CAAd;AAAA,OAAhB;AACAf,eAAOgB,OAAP,GAAiBhB,SAAOrB,KAAP,GAAeqB,SAAOC,GAAP,CAAWa,MAA1B,GAAmC,CAApD;AACA,aAAOd,SAAOrB,KAAd;AACA,WAAK,IAAIkC,IAAI,CAAb,EAAgBA,IAAIb,SAAOC,GAAP,CAAWa,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C,YAAMV,OAAKH,SAAOC,GAAP,CAAWY,CAAX,CAAX;AAAA,YAA0BkL,aAAgB/L,SAAOgB,OAAP,GAAiBH,CAAjC,SAAsCb,SAAOvB,KAAvE;AACA,YAAI0B,KAAGY,EAAH,KAAUgL,UAAd,EAA0B;AACxB,gBAAM,IAAIrM,UAAJ,oBAAgCqM,UAAhC,cAAmD5L,KAAGY,EAAtD,CAAN;AACD;AACD,eAAOZ,KAAGY,EAAV;AACD;AACF;AA9DmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+DrC;;AAED,SAASiL,qBAAT,CAA+BpM,OAA/B,EAAwC;AACtC,MAAMsB,UAAU,EAAE;AAChBzC,WAAY,IAAIhE,UAAJ,CAAe,MAAf,CADE;AAEdiE,SAAY,IAAI/D,YAAJ,EAFE;AAGdgE,WAAY,IAAIhE,YAAJ,EAHE;AAIdiE,UAAY,IAAIjE,YAAJ,EAJE;AAKdkE,aAAY,IAAIpE,UAAJ,CAAe,MAAf,CALE;AAMdqE,aAAY,IAAIrE,UAAJ,CAAe,MAAf,CANE;AAOdsE,eAAY,IAAIpE,YAAJ;AAPE,GAAhB;AASA,MAAIsR,cAAc,EAAlB,CAVsC,CAUjB;AACrB,MAAIC,QAAQ,EAAZ,CAXsC,CAWvB;;AAEf,OAAK,IAAIrL,IAAI,CAAb,EAAgBA,IAAIjB,QAAQkB,MAA5B,EAAoCD,GAApC,EAAyC;AACvC,QAAMb,SAASJ,QAAQiB,CAAR,CAAf;AACAoL,gBAAYjM,OAAOkI,IAAnB,IAA2BrH,CAA3B;AACAqL,UAAMlM,OAAOkI,IAAb,IAAqB,IAArB;;AAEAhH,YAAQzC,KAAR,CAAc0C,WAAd,CAA0BnB,OAAOP,QAAjC;AACAyB,YAAQxC,GAAR,CAAYyC,WAAZ,CAAwBnB,OAAOtB,GAA/B;AACAwC,YAAQvC,KAAR,CAAcwC,WAAd,CAA0BnB,OAAOgB,OAAP,GAAiBhB,OAAOC,GAAP,CAAWa,MAA5B,GAAqC,CAA/D;AACAI,YAAQtC,IAAR,CAAauC,WAAb,CAAyBnB,OAAOpB,IAAhC;AACAsC,YAAQrC,OAAR,CAAgBsC,WAAhB,CAA4BnB,OAAOnB,OAAnC;AACAqC,YAAQpC,OAAR,CAAgBqC,WAAhB,CAA4BnB,OAAOiH,IAAP,CAAYnG,MAAxC;;AAVuC;AAAA;AAAA;;AAAA;AAYvC,6BAAgBd,OAAOiH,IAAvB,wIAA6B;AAAA,YAApBkF,GAAoB;;AAC3B,YAAI,OAAOF,YAAYE,GAAZ,CAAP,KAA4B,QAAhC,EAA0C;AACxC,gBAAM,IAAIzM,UAAJ,+BAA2CyM,GAA3C,CAAN;AACD;AACDjL,gBAAQnC,SAAR,CAAkBoC,WAAlB,CAA8B8K,YAAYE,GAAZ,CAA9B;AACA,YAAID,MAAMC,GAAN,CAAJ,EAAgB,OAAOD,MAAMC,GAAN,CAAP;AACjB;AAlBsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBxC;;AAED,MAAIC,iBAAiB,EAArB;AAlCsC;AAAA;AAAA;;AAAA;AAmCtC,2BAAuB3O,OAAOU,OAAP,CAAeK,gBAAf,CAAvB,wIAAyD;AAAA;;AAAA;;AAAA,UAA/CkG,IAA+C;AAAA,UAAzC3D,EAAyC;;AACvDqL,qBAAe5L,IAAf,CAAoB,EAACO,MAAD,EAAK2D,UAAL,EAAWC,SAASzD,QAAQwD,IAAR,CAApB,EAApB;AACD;AArCqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCtC0H,iBAAe1L,IAAf,CAAoB,UAACkE,CAAD,EAAIC,CAAJ;AAAA,WAAUD,EAAE7D,EAAF,GAAO8D,EAAE9D,EAAnB;AAAA,GAApB;AACA,SAAO,EAAEqL,8BAAF,EAAkBF,OAAOzO,OAAOgD,IAAP,CAAYyL,KAAZ,EAAmBxL,IAAnB,EAAzB,EAAP;AACD;;AAED,SAAS2L,qBAAT,CAA+BzM,OAA/B,EAAwC0M,aAAxC,EAAuD;AACrD,MAAIJ,QAAQ,EAAZ,CADqD,CACtC;AACf,OAAK,IAAIrL,MAAI,CAAb,EAAgBA,MAAIjB,QAAQkB,MAA5B,EAAoCD,KAApC,EAAyC;AACvC,QAAIb,SAASJ,QAAQiB,GAAR,CAAb;AACAb,WAAOiH,IAAP,GAAc,EAAd;AAFuC;AAAA;AAAA;;AAAA;AAGvC,6BAAkBjH,OAAOlB,OAAP,CAAeoB,GAAf,CAAmB;AAAA,eAAKqM,EAAExN,SAAP;AAAA,OAAnB,CAAlB,wIAAwD;AAAA,YAA/C2M,KAA+C;;AACtD,YAAI,CAAC9L,QAAQ8L,KAAR,CAAD,IAAmB,CAAC9L,QAAQ8L,KAAR,EAAexD,IAAvC,EAA6C;AAC3C,gBAAM,IAAIxI,UAAJ,wBAAoCgM,KAApC,gCAAoE7K,GAApE,CAAN;AACD;AACD,YAAMqH,OAAOtI,QAAQ8L,KAAR,EAAexD,IAA5B;AACAlI,eAAOiH,IAAP,CAAYzG,IAAZ,CAAiB0H,IAAjB;AACA,YAAIgE,MAAMhE,IAAN,CAAJ,EAAiB,OAAOgE,MAAMhE,IAAN,CAAP;AAClB;AAVsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWvClI,WAAOiH,IAAP,CAAYvG,IAAZ;AACA,WAAOV,OAAOlB,OAAd;;AAEA;AACAc,YAAQiB,GAAR,IAAa8I,aAAaX,aAAahJ,MAAb,CAAb,CAAb;AACAkM,UAAMtM,QAAQiB,GAAR,EAAWqH,IAAjB,IAAyB,IAAzB;AACD;;AAED,MAAMsE,cAAc/O,OAAOgD,IAAP,CAAYyL,KAAZ,EAAmBxL,IAAnB,EAApB;AACA,MAAI+L,aAAcD,YAAY1L,MAAZ,KAAuBwL,cAAcxL,MAAvD;AAAA,MAAgED,IAAI,CAApE;AACA,SAAO4L,cAAc5L,IAAI2L,YAAY1L,MAArC,EAA6C;AAC3C2L,iBAAcD,YAAY3L,CAAZ,MAAmByL,cAAczL,CAAd,CAAjC;AACAA;AACD;AACD,MAAI,CAAC4L,UAAL,EAAiB;AACf,UAAM,IAAI/M,UAAJ,wCAAoD4M,cAAcI,IAAd,CAAmB,IAAnB,CAApD,cAAqFF,YAAYE,IAAZ,CAAiB,IAAjB,CAArF,CAAN;AACD;AACF;;AAED;;;AAGA,SAASC,cAAT,CAAwBzC,aAAxB,EAAuC;AAAA,wBACPvK,cAAcsK,cAAcC,aAAd,CAAd,EAA4C,KAA5C,CADO;AAAA,MAC7BtK,OAD6B,mBAC7BA,OAD6B;AAAA,MACpBN,QADoB,mBACpBA,QADoB;;AAAA,8BAEH0M,sBAAsBpM,OAAtB,CAFG;AAAA,MAE7BwM,cAF6B,yBAE7BA,cAF6B;AAAA,MAEbF,KAFa,yBAEbA,KAFa;;AAGrC,MAAMU,aAAatI,UAAUoG,iBAAiB9K,OAAjB,CAAV,EAAqC,IAArC,CAAnB;;AAEA,MAAIiN,oBAAoB,CAAxB;AALqC;AAAA;AAAA;;AAAA;AAMrC,2BAAmBT,cAAnB,wIAAmC;AAAA,UAA1B5G,MAA0B;;AACjC,UAAIA,OAAOb,OAAP,CAAexC,MAAf,CAAsB2B,UAAtB,GAAmC,CAAvC,EAA0C+I;AAC3C;AARoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUrC,SAAOzF,gBAAgB,UAAhB,EAA4BgF,eAAezL,MAAf,CAAsBiM,UAAtB,CAA5B,EAA+D,mBAAW;AAC/EjI,YAAQ9C,YAAR,CAAqBvC,SAASwB,MAA9B;AAD+E;AAAA;AAAA;;AAAA;AAE/E,6BAAkBxB,QAAlB,wIAA4B;AAAA,YAAnBb,KAAmB;;AAC1BkG,gBAAQuE,eAAR,CAAwBzK,KAAxB;AACD;AAJ8E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAK/EkG,YAAQ9C,YAAR,CAAqBqK,MAAMpL,MAA3B;AAL+E;AAAA;AAAA;;AAAA;AAM/E,6BAAiBoL,MAAMxL,IAAN,EAAjB,wIAA+B;AAAA,YAAtBoM,IAAsB;;AAC7BnI,gBAAQzC,cAAR,CAAuB7H,iBAAiByS,IAAjB,CAAvB;AACD;AAR8E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAS/EnI,YAAQ9C,YAAR,CAAqBgL,iBAArB;AACD,GAVM,EAUJtJ,KAVH;AAWD;;AAED,SAASwJ,oBAAT,CAA8B5K,MAA9B,EAAsC;AACpC,MAAM6K,kBAAkB,IAAIxS,OAAJ,CAAY2H,MAAZ,CAAxB;AACA,MAAMyF,SAASU,sBAAsB0E,eAAtB,EAAuC,IAAvC,CAAf;AACA,MAAM3I,UAAU,IAAI7J,OAAJ,CAAYoN,OAAOiB,SAAnB,CAAhB;AACA,MAAI,CAACmE,gBAAgB/G,IAArB,EAA2B,MAAM,IAAIvG,UAAJ,CAAe,oCAAf,CAAN;AAC3B,MAAIkI,OAAOP,SAAP,KAAqB,CAAzB,EAA4B,MAAM,IAAI3H,UAAJ,6BAAyCkI,OAAOP,SAAhD,CAAN;;AAE5B,MAAM/H,WAAW,EAAjB;AAAA,MAAqB2N,YAAY5I,QAAQX,UAAR,EAAjC;AACA,OAAK,IAAI7C,IAAI,CAAb,EAAgBA,IAAIoM,SAApB,EAA+BpM,GAA/B,EAAoC;AAClCvB,aAASkB,IAAT,CAAc6D,QAAQ0C,aAAR,EAAd;AACD;AACD,MAAMmF,QAAQ,EAAd;AAAA,MAAkBgB,WAAW7I,QAAQX,UAAR,EAA7B;AACA,OAAK,IAAI7C,MAAI,CAAb,EAAgBA,MAAIqM,QAApB,EAA8BrM,KAA9B,EAAmC;AACjCqL,UAAM1L,IAAN,CAAWlG,iBAAiB+J,QAAQb,YAAR,CAAqB,EAArB,CAAjB,CAAX;AACD;;AAED,MAAM4I,iBAAiB5F,YAAYnC,OAAZ,EAAqBA,QAAQX,UAAR,EAArB,CAAvB;AACA,MAAMkJ,aAAapG,YAAYnC,OAAZ,CAAnB;AACA,SAAO,EAAE+H,8BAAF,EAAkBQ,sBAAlB,EAA8BtN,kBAA9B,EAAwC4M,YAAxC,EAAP;AACD;;AAED,SAAS5B,cAAT,CAAwBnI,MAAxB,EAAgC;AAAA,8BAC0B4K,qBAAqB5K,MAArB,CAD1B;AAAA,MACtBiK,cADsB,yBACtBA,cADsB;AAAA,MACNQ,UADM,yBACNA,UADM;AAAA,MACMtN,QADN,yBACMA,QADN;AAAA,MACgB4M,KADhB,yBACgBA,KADhB;;AAE9B,MAAMtM,UAAUiG,cAAcuG,cAAd,EAA8B9M,QAA9B,EAAwCd,gBAAxC,CAAhB;AACA,MAAMyB,MAAM6E,UAAUe,cAAc+G,UAAd,EAA0BtN,QAA1B,EAAoCxB,eAApC,CAAV,EAAgE,IAAhE,CAAZ;AACAsN,iBAAexL,OAAf,EAAwBK,GAAxB;AACAoM,wBAAsBzM,OAAtB,EAA+BsM,KAA/B;AACA,SAAOtM,OAAP;AACD;;AAED;;;;;;AAMA,SAASuN,gBAAT,CAA0BC,OAA1B,EAAmCC,QAAnC,EAA6C;AAC3C,MAAIhH,SAAS,EAAb;AAAA,MAAiB7G,UAAU,IAA3B;AAD2C;AAAA;AAAA;;AAAA;AAE3C,2BAAe6N,SAASpN,GAAxB,wIAA6B;AAAA,UAApBE,EAAoB;;AAC3B;AACA,UAAIA,GAAGmN,UAAH,KAAkB,KAAlB,IAA2BnN,GAAGlB,KAAH,CAASmD,QAAT,KAAsB,SAArD,EAAgE;AAC9D,YAAI,CAAC5C,OAAL,EAAcA,UAAU,EAACH,MAAMc,GAAGd,IAAV,EAAgBJ,OAAO,CAAvB,EAA0BuF,MAAM,EAAhC,EAAV;AACdhF,gBAAQP,KAAR,IAAiBkB,GAAGlB,KAAH,CAASA,KAA1B;AAF8D;AAAA;AAAA;;AAAA;AAG9D,iCAAmBkB,GAAGqE,IAAtB;AAAA,gBAAS+I,MAAT;AAA4B/N,oBAAQgF,IAAR,CAAa+I,MAAb,IAAuB,IAAvB;AAA5B;AAH8D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI/D,OAJD,MAIO,IAAIpN,GAAGmN,UAAH,KAAkB,KAAtB,EAA6B;AAClC,YAAI,CAAC9N,OAAL,EAAc,MAAM,IAAIE,UAAJ,oBAAgCS,GAAGd,IAAnC,wBAAN;AACdG,gBAAQP,KAAR,IAAiBkB,GAAGlB,KAAH,CAASA,KAA1B;AACA,eAAOO,QAAQgF,IAAR,CAAarE,GAAGd,IAAhB,CAAP;AAHkC;AAAA;AAAA;;AAAA;AAIlC,iCAAmBc,GAAGqE,IAAtB;AAAA,gBAAS+I,OAAT;AAA4B/N,oBAAQgF,IAAR,CAAa+I,OAAb,IAAuB,IAAvB;AAA5B;AAJkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMnC,OANM,MAMA,IAAIpN,GAAGqE,IAAH,CAAQ1D,MAAR,KAAmB,CAAvB,EAA0B;AAAE;AACjC,YAAIX,GAAGmN,UAAH,CAAcvC,UAAd,CAAyB,MAAzB,CAAJ,EAAsC;AACpC1E,iBAAOlG,GAAGd,IAAV,IAAkB+N,QAAQjN,GAAGd,IAAX,CAAlB;AACD,SAFD,MAEO,IAAIc,GAAGmN,UAAH,KAAkB,KAAtB,EAA6B;AAClCjH,iBAAOlG,GAAGd,IAAV,IAAkBc,GAAGlB,KAArB;AACD,SAFM,MAEA,IAAIkB,GAAGmN,UAAH,KAAkB,MAAtB,EAA8B;AACnC;AACA;AACA;AACA,cAAI,CAACnN,GAAGqN,OAAR,EAAiB,MAAM,IAAI9N,UAAJ,qBAAiCS,GAAGd,IAApC,wBAAN;AACjBgH,iBAAOlG,GAAGd,IAAV,IAAkB+N,QAAQjN,GAAGqN,OAAX,CAAlB;AACD,SANM,MAMA;AACL,gBAAM,IAAI9N,UAAJ,8BAA0CS,GAAGmN,UAA7C,CAAN;AACD;AACF;AACF;;AAED;AACA;AAhC2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiC3C,MAAI9N,WAAW/B,OAAOgD,IAAP,CAAYjB,QAAQgF,IAApB,EAA0B1D,MAA1B,KAAqC,CAApD,EAAuD;AACrDuF,WAAO7G,QAAQH,IAAf,IAAuB,EAACJ,OAAOO,QAAQP,KAAhB,EAAuBmD,UAAU,SAAjC,EAAvB;AACD;;AAED,MAAI3E,OAAOgD,IAAP,CAAY4F,MAAZ,EAAoBvF,MAApB,GAA6B,CAAjC,EAAoC;AAClC,QAAIV,MAAMgN,QAAQC,SAASI,KAAjB,CAAV;AACA,QAAI,CAACrN,IAAIsN,KAAT,EAAgBtN,IAAIsN,KAAJ,GAAY,EAAZ;AAChB,QAAItN,IAAIuN,IAAJ,KAAa,KAAb,IAAsBvN,IAAIuN,IAAJ,KAAa,OAAvC,EAAgD;AAC9CvN,UAAIsN,KAAJ,CAAUL,SAAShN,GAAnB,IAA0BgG,MAA1B;AACD,KAFD,MAEO,IAAIjG,IAAIuN,IAAJ,KAAa,MAAb,IAAuBvN,IAAIuN,IAAJ,KAAa,MAAxC,EAAgD;AACrD,UAAI,CAACvN,IAAIwN,KAAT,EAAgBxN,IAAIwN,KAAJ,GAAY,EAAZ;AAChBxN,UAAIsN,KAAJ,CAAUtN,IAAIwN,KAAJ,CAAU9M,MAApB,IAA8BuF,MAA9B;AACAjG,UAAIwN,KAAJ,CAAUpN,IAAV,CAAe,EAACrD,QAAQ,QAAT,EAAmBuO,OAAOtL,IAAIwN,KAAJ,CAAU9M,MAApC,EAAf;AACD;AACF;AACF;;AAED;;;;;AAKA,SAAS+M,cAAT,CAAwBC,cAAxB,EAAwC;AAAA,+BACLf,qBAAqBe,cAArB,CADK;AAAA,MAC9BlB,UAD8B,0BAC9BA,UAD8B;AAAA,MAClBtN,QADkB,0BAClBA,QADkB;;AAEtC,MAAM0G,MAAMZ,aAAawH,UAAb,EAAyB9O,eAAzB,EAA0CM,MAA1C,CACV,UAACC,GAAD,EAAM2H,GAAN;AAAA,WAAcvI,OAAOC,MAAP,CAAcW,GAAd,sBAAqB2H,IAAI5B,UAAzB,EAAsC4B,IAAI3B,OAA1C,EAAd;AAAA,GADU,EACyD,EADzD,CAAZ;;AAGA,MAAM0J,UAAU,EAACC,SAAS,KAAV,EAAiBC,UAAU,MAA3B,EAAmCC,UAAU,MAA7C,EAAqDC,WAAW,OAAhE,EAAhB;AACA,MAAIf,8BAAYnT,OAAZ,EAAsB,EAAC6Q,UAAU7Q,OAAX,EAAoB0T,MAAM,KAA1B,EAAtB,CAAJ;AACA,MAAIN,WAAW,IAAf;;AAEA,SAAO,CAACrH,IAAIhJ,OAAJ,CAAYiJ,IAApB,EAA0B;AACxB,QAAM5G,OAAU2G,IAAI/I,KAAJ,CAAUoG,SAAV,EAAV,SAAmC/D,SAAS0G,IAAIhJ,OAAJ,CAAYqG,SAAZ,EAAT,CAAzC;AACA,QAAMlG,SAAS6I,IAAI7I,MAAJ,CAAWkG,SAAX,EAAf;AAAA,QAAuCiK,aAAa7Q,QAAQU,MAAR,CAApD;AACA,QAAIA,SAAS,CAAT,KAAe,CAAnB,EAAsB;AAAE;AACtBiQ,cAAQ/N,IAAR,IAAgB,EAACyL,UAAUzL,IAAX,EAAiBsO,MAAMI,QAAQT,UAAR,KAAuB,SAA9C,EAAhB;AACD;;AAED,QAAM3Q,WAAWqJ,IAAIrJ,QAAJ,CAAa0G,SAAb,EAAjB;AAAA,QAA2CzG,SAASoJ,IAAIpJ,MAAJ,CAAWyG,SAAX,EAApD;AACA,QAAMoK,QAAQ9Q,aAAa,IAAb,GAAoB1C,OAApB,GAAiC2C,MAAjC,SAA2C0C,SAAS3C,QAAT,CAAzD;AACA,QAAIyD,MAAMgN,QAAQK,KAAR,CAAV;AACA,QAAI,CAACrN,GAAL,EAAU,MAAM,IAAIV,UAAJ,wCAAoD+N,KAApD,CAAN;;AAEV,QAAM5Q,WAAWmJ,IAAInJ,QAAJ,CAAawG,SAAb,EAAjB;AAAA,QAA2CvG,SAASkJ,IAAIlJ,MAAJ,CAAWuG,SAAX,EAApD;AACA,QAAMtG,SAASiJ,IAAIjJ,MAAJ,CAAWsG,SAAX,EAAf;AAAA,QAAuCnG,SAAS,CAAC,CAAC8I,IAAI9I,MAAJ,CAAWmG,SAAX,EAAlD;AACA,QAAM/F,YAAY0I,IAAI1I,SAAJ,CAAc+F,SAAd,EAAlB;AAAA,QAA6C9F,UAAUyI,IAAIzI,OAAJ,CAAY8F,SAAZ,EAAvD;AACA,QAAMmK,UAAUlQ,cAAc,IAAd,GAAqB,IAArB,GAA+BC,OAA/B,SAA0C+B,SAAShC,SAAT,CAA1D;AACA,QAAM2B,QAAQgE,YAAY+C,IAAI5I,MAAhB,EAAwB4I,IAAI3I,MAA5B,CAAd;AAAA,QAAmDU,UAAUiI,IAAIjI,OAAJ,CAAYsF,SAAZ,EAA7D;AACA,QAAImB,OAAO,EAAX;AACA,SAAK,IAAI3D,IAAI,CAAb,EAAgBA,IAAI9C,OAApB,EAA6B8C,GAA7B,EAAkC;AAChC2D,WAAKhE,IAAL,CAAawF,IAAI/H,OAAJ,CAAYoF,SAAZ,EAAb,SAAwC/D,SAAS0G,IAAIhI,SAAJ,CAAcqF,SAAd,EAAT,CAAxC;AACD;;AAED,QAAI,CAACiK,UAAD,IAAelN,IAAIuN,IAAJ,KAAa,SAAhC,EAA2C;;AAE3C,QAAItN,YAAJ;AACA,QAAID,IAAIuN,IAAJ,KAAa,MAAb,IAAuBvN,IAAIuN,IAAJ,KAAa,MAAxC,EAAgD;AAC9C,UAAI9Q,aAAa,IAAb,IAAqBC,WAAW,IAAhC,IAAyCA,WAAW,CAAX,IAAgB,CAACI,MAA9D,EAAuE;AACrE,cAAM,IAAIwC,UAAJ,gBAA4BL,IAA5B,YAAuCe,IAAIuN,IAA3C,wBAAN;AACD;AACDtN,YAAMnD,SAASmC,IAAT,GAAmBvC,MAAnB,SAA6BwC,SAASzC,QAAT,CAAnC;AACD,KALD,MAKO;AACL,UAAIE,WAAW,IAAf,EAAqB;AACnB,cAAM,IAAI2C,UAAJ,gBAA4BL,IAA5B,YAAuCe,IAAIuN,IAA3C,wBAAN;AACD;AACDtN,YAAMtD,MAAN;AACD;;AAED,QAAI,CAACsQ,QAAD,IAAaA,SAASI,KAAT,KAAmBA,KAAhC,IAAyCJ,SAAShN,GAAT,KAAiBA,GAA9D,EAAmE;AACjE,UAAIgN,QAAJ,EAAcF,iBAAiBC,OAAjB,EAA0BC,QAA1B;AACdA,iBAAW,EAACI,YAAD,EAAQpN,QAAR,EAAaJ,KAAK,EAAlB,EAAX;AACD;AACDoN,aAASpN,GAAT,CAAaO,IAAb,CAAkB,EAACnB,UAAD,EAAOiO,sBAAP,EAAmBrO,YAAnB,EAA0BuO,gBAA1B,EAAmChJ,UAAnC,EAAlB;AACD;;AAED,MAAI6I,QAAJ,EAAcF,iBAAiBC,OAAjB,EAA0BC,QAA1B;AACd,SAAOD,QAAQnT,OAAR,CAAP;AACD;;AAED;;;;;AAKA,SAASmU,QAAT,CAAkBnO,GAAlB,EAAuBoO,OAAvB,EAAgC/O,QAAhC,EAA0C;AAAA,MAChC3C,QADgC,GAC+DsD,GAD/D,CAChCtD,QADgC;AAAA,MACtBC,MADsB,GAC+DqD,GAD/D,CACtBrD,MADsB;AAAA,MACdC,QADc,GAC+DoD,GAD/D,CACdpD,QADc;AAAA,MACJC,MADI,GAC+DmD,GAD/D,CACJnD,MADI;AAAA,MACIC,MADJ,GAC+DkD,GAD/D,CACIlD,MADJ;AAAA,MACYC,OADZ,GAC+DiD,GAD/D,CACYjD,OADZ;AAAA,MACqBC,KADrB,GAC+DgD,GAD/D,CACqBhD,KADrB;AAAA,MAC4BC,MAD5B,GAC+D+C,GAD/D,CAC4B/C,MAD5B;AAAA,MACoCC,MADpC,GAC+D8C,GAD/D,CACoC9C,MADpC;AAAA,MAC4CmR,cAD5C,GAC+DrO,GAD/D,CAC4CqO,cAD5C;;AAAA,qBAGpCD,QAAQnO,GAAR,CAAY;AAAA,WAAO8F,IAAI3B,OAAX;AAAA,GAAZ,CAHoC;AAAA;AAAA,MAEjCkK,SAFiC;AAAA,MAEtBC,OAFsB;AAAA,MAEbC,SAFa;AAAA,MAEFC,OAFE;AAAA,MAEOC,OAFP;AAAA,MAEgBC,QAFhB;AAAA,MAE0BC,MAF1B;AAAA,MAEkCC,OAFlC;AAAA,MAE2CC,OAF3C;;AAIxC,MAAIC,YAAY,CAAhB;AAAA,MAAmBC,eAAe,IAAlC;AAAA,MAAwCC,aAAa,IAArD;AACA,MAAIC,cAAc,IAAlB;AAAA,MAAwBC,YAAY,IAApC;AAAA,MAA0CC,aAAa,IAAvD;;AAEA;AACA,MAAIzS,WAAW,IAAf,EAAqB;AACnB,WAAO,CAAC4R,QAAQvI,IAAT,IAAiB,CAACsI,UAAUtI,IAA5B,IAAoC,CAAC0I,QAAQ1I,IAApD,EAA0D;AACxDiJ,mBAAaV,QAAQnL,SAAR,EAAb;AACA4L,qBAAe3P,SAASiP,UAAUlL,SAAV,EAAT,CAAf;AACAsL,cAAQW,UAAR,CAAmB,CAAnB;AACA,UAAIJ,eAAe,IAAf,IAAuB,CAACD,YAAxB,IAAwCC,aAAatS,MAArD,IACCsS,eAAetS,MAAf,IAAyBqS,eAAetS,QAD7C,EACwD;AACtDqS,qBAAa,CAAb;AACD,OAHD,MAGO;AACL;AACD;AACF;AACF;;AAED;AACA,MAAIjS,WAAW,IAAX,IAAmBmS,eAAetS,MAAlC,IAA4CqS,iBAAiBtS,QAAjE,EAA2E;AACzEgS,YAAQW,UAAR,CAAmBN,SAAnB;AACA,WAAO,CAACL,QAAQ1I,IAAhB,EAAsB;AACpBoJ,mBAAaV,QAAQtL,SAAR,EAAb;AACA6L,mBAAaV,QAAQnL,SAAR,EAAb;AACA4L,qBAAe3P,SAASiP,UAAUlL,SAAV,EAAT,CAAf;AACA,UAAIgM,eAAe,IAAf,IAAuBA,aAAatS,MAApC,IACAmS,eAAetS,MADf,IACyBqS,iBAAiBtS,QAD9C,EACwD;AACtDqS,qBAAa,CAAb;AACD,OAHD,MAGO;AACL;AACD;AACF;AACF;;AAED;AACA,MAAIlS,WAAW,IAAX,IAAmBD,aAAa,IAAhC,IAAwCC,SAAS,CAAjD,IAAsDoS,eAAetS,MAArE,IAA+EqS,iBAAiBtS,QAApG,EAA8G;AAC5GkS,WAAOS,UAAP,CAAkBN,SAAlB;AACAJ,aAASU,UAAT,CAAoBN,SAApB;AACA,WAAO,CAACH,OAAO5I,IAAR,IAAgB,CAAC2I,SAAS3I,IAA1B,KAAmCmJ,cAActS,MAAd,IAAwBqS,gBAAgBtS,QAA3E,CAAP,EAA6F;AAC3FuS,kBAAYP,OAAOxL,SAAP,EAAZ;AACA8L,oBAAc7P,SAASsP,SAASvL,SAAT,EAAT,CAAd;AACA6L,mBAAaV,QAAQnL,SAAR,EAAb;AACA4L,qBAAe3P,SAASiP,UAAUlL,SAAV,EAAT,CAAf;AACA,UAAI6L,eAAetS,MAAf,IAAyBqS,iBAAiBtS,QAA9C,EAAwDqS,aAAa,CAAb,CAAxD,KAA6E;AAC9E;AACD,QAAII,cAActS,MAAd,IAAwBqS,gBAAgBtS,QAA5C,EAAsD;AACpD,YAAM,IAAI6C,UAAJ,mCAA+C5C,MAA/C,SAAyDD,QAAzD,CAAN;AACD;;AAED;AACA,WAAO,CAACgS,OAAO5I,IAAR,IAAgB,CAAC2I,SAAS3I,IAAjC,EAAuC;AACrCmJ,kBAAYP,OAAOxL,SAAP,EAAZ;AACA8L,oBAAc7P,SAASsP,SAASvL,SAAT,EAAT,CAAd;AACA6L,mBAAaV,QAAQnL,SAAR,EAAb;AACA4L,qBAAe3P,SAASiP,UAAUlL,SAAV,EAAT,CAAf;AACA,UAAI,CAAC+L,YAAYnS,KAAZ,IAAsBmS,cAAcnS,KAAd,IAAuBkS,cAAcnS,OAA5D,KACAkS,eAAetS,MADf,IACyBqS,iBAAiBtS,QAD9C,EACwD;AACtDqS,qBAAa,CAAb;AACD,OAHD,MAGO;AACL;AACD;AACF;AACF;AACD,SAAOA,SAAP;AACD;;AAED;;;;;;;;;;;AAWA,SAASO,WAAT,CAAqBC,OAArB,EAA8BC,MAA9B,EAAsCnJ,KAAtC,EAA6CoJ,UAA7C,EAAyDzP,GAAzD,EAA8D;AAC5D,MAAIqG,UAAU,CAAd,EAAiB;AACjB,MAAIqJ,UAAU,CAAd;AAAA,MAAiBC,YAAY,CAAC,CAA9B;AAAA,MAAiCC,kBAAkB,CAAnD;AAAA,MAAsDC,cAAc,CAAC,CAArE;AAAA,MAAwEC,aAAa,CAArF;AAF4D;AAAA;AAAA;;AAAA;AAG5D,2BAAmBP,OAAnB,wIAA4B;AAAA,UAAnBQ,MAAmB;;AAC1B,aAAOL,UAAUF,OAAO3O,MAAjB,IAA2B2O,OAAOE,OAAP,EAAgBxL,QAAhB,GAA2B6L,OAAO7L,QAApE;AAA8EwL;AAA9E,OACA,IAAIM,QAAQ,IAAZ;AACA,UAAIN,UAAUF,OAAO3O,MAAjB,IAA2B2O,OAAOE,OAAP,EAAgBxL,QAAhB,KAA6B6L,OAAO7L,QAA/D,IACAsL,OAAOE,OAAP,EAAgBtL,OAAhB,CAAwByE,GAAxB,CAA4BhF,UAA5B,GAAyC,CAD7C,EACgD;AAC9CmM,gBAAQR,OAAOE,OAAP,EAAgBtL,OAAxB;AACD;AACD,UAAM6L,WAAYF,OAAO7L,QAAP,IAAmB,CAAnB,KAAyByL,SAA1B,GAAuCC,eAAvC,GAAyDvJ,KAA1E;;AAEA,UAAI0J,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYC,UAAxC,EAAoD;AAClDwU,oBAAYI,OAAO7L,QAAP,IAAmB,CAA/B;AACA,YAAI8L,KAAJ,EAAW;AACTJ,4BAAkBG,OAAOrL,OAAP,CAAewL,QAAf,CAAwBF,KAAxB,EAA+B,EAAC3J,YAAD,EAAQ8J,WAAW,IAAnB,EAA/B,CAAlB;AACD,SAFD,MAEO;AACLJ,iBAAOrL,OAAP,CAAexD,WAAf,CAA2B,CAA3B,EAA8BmF,KAA9B;AACAuJ,4BAAkB,CAAlB;AACD;AACF,OARD,MAQO,IAAIG,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYO,SAAxC,EAAmD;AACxD,YAAIuU,KAAJ,EAAW;AACT,cAAIN,UAAU,CAAV,KAAgBF,OAAO3O,MAAvB,IAAiC2O,OAAOE,UAAU,CAAjB,EAAoBxL,QAApB,KAAiC6L,OAAO7L,QAAP,GAAkB,CAAxF,EAA2F;AACzF,kBAAM,IAAIzE,UAAJ,CAAe,wDAAf,CAAN;AACD;AACDoQ,wBAAcE,OAAO7L,QAAP,GAAkB,CAAhC;AACA4L,uBAAaC,OAAOrL,OAAP,CAAewL,QAAf,CAAwBF,KAAxB,EAA+B,EAAC3J,OAAO4J,QAAR,EAAkBE,WAAW,IAA7B,EAAmCC,UAAU,CAA7C,EAA/B,CAAb;AACD,SAND,MAMO;AACLL,iBAAOrL,OAAP,CAAexD,WAAf,CAA2B,IAA3B,EAAiC+O,QAAjC;AACAJ,wBAAcE,OAAO7L,QAAP,GAAkB,CAAhC;AACA4L,uBAAa,CAAb;AACD;AACF,OAZM,MAYA,IAAIC,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYQ,SAAxC,EAAmD;AACxD,YAAIqU,OAAO7L,QAAP,KAAoB2L,WAAxB,EAAqC;AACnC,gBAAM,IAAIpQ,UAAJ,CAAe,wDAAf,CAAN;AACD;AACD,YAAIqQ,aAAa,CAAjB,EAAoB;AAClBC,iBAAOrL,OAAP,CAAezC,cAAf,CAA8B+N,MAAMzM,YAAN,CAAmBuM,UAAnB,CAA9B;AACD;AACF,OAPM,MAOA,IAAI9P,OAAO,CAACgQ,KAAR,IAAiBD,OAAO7L,QAAP,KAAoBrG,gBAAgBd,OAAzD,EAAkE;AACvEgT,eAAOrL,OAAP,CAAexD,WAAf,CAA2BlB,IAAIqQ,YAA/B,EAA6CJ,QAA7C;AACD,OAFM,MAEA,IAAIjQ,OAAO,CAACgQ,KAAR,IAAiBD,OAAO7L,QAAP,KAAoBrG,gBAAgBb,KAAzD,EAAgE;AACrE,aAAK,IAAI4D,IAAI,CAAb,EAAgBA,IAAIqP,QAApB,EAA8BrP,GAA9B;AAAmCmP,iBAAOrL,OAAP,CAAexD,WAAf,CAA2BlB,IAAIhD,KAAJ,GAAY4D,CAAvC;AAAnC;AACD,OAFM,MAEA;AAAE;AACP,YAAIoP,KAAJ,EAAW;AACT,cAAMM,UAAU,EAACjK,OAAO4J,QAAR,EAAkBM,aAAa,IAA/B,EAAhB;AACA,cAAIR,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYE,QAAxC,EAAkDkV,QAAQC,WAAR,GAAsBd,UAAtB;AAClDM,iBAAOrL,OAAP,CAAewL,QAAf,CAAwBF,KAAxB,EAA+BM,OAA/B;AACD,SAJD,MAIO;AACL,cAAME,aAAcT,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYK,OAArC,GAAgD,KAAhD,GAAwD,IAA3E;AACAwU,iBAAOrL,OAAP,CAAexD,WAAf,CAA2BsP,UAA3B,EAAuCP,QAAvC;AACD;AACF;AACF;AArD2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsD7D;;AAED;;;;;;;AAOA,SAASQ,aAAT,CAAuBxP,OAAvB,EAAgCwO,UAAhC,EAA4C;AAC1C,MAAIiB,YAAY,EAAhB;AAAA,MAAoBC,iBAApB;AAAA,MAA8BhB,YAAY,CAAC,CAA3C;AAAA,MAA8CC,kBAAkB,CAAhE;AAAA,MAAmEC,cAAc,CAAC,CAAlF;AAAA,MAAqFC,aAAa,CAAlG;AAD0C;AAAA;AAAA;;AAAA;AAE1C,2BAAgB7O,OAAhB,wIAAyB;AAAA,UAAhB8E,GAAgB;;AACvB,UAAIA,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYQ,SAArC,EAAgD;AAC9C,YAAIqK,IAAI7B,QAAJ,KAAiB2L,WAArB,EAAkC,MAAM,IAAIpQ,UAAJ,CAAe,6BAAf,CAAN;AAClCkR,mBAAW5K,IAAI3B,OAAJ,CAAYb,YAAZ,CAAyBuM,UAAzB,CAAX;AACD,OAHD,MAGO,IAAI/J,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYC,UAArC,EAAiD;AACtDwU,oBAAY5J,IAAI7B,QAAJ,IAAgB,CAA5B;AACA0L,0BAAkB7J,IAAI3B,OAAJ,CAAYhB,SAAZ,MAA2B,CAA7C;AACAuN,mBAAWf,eAAX;AACD,OAJM,MAIA,IAAI7J,IAAI7B,QAAJ,IAAgB,CAAhB,KAAsByL,SAA1B,EAAqC;AAC1CgB,mBAAW,EAAX;AACA,YAAI5K,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYO,SAArC,EAAgD;AAC9CoU,wBAAc9J,IAAI7B,QAAJ,GAAe,CAA7B;AACA4L,uBAAa,CAAb;AACD;AACD,aAAK,IAAIlP,IAAI,CAAb,EAAgBA,IAAIgP,eAApB,EAAqChP,GAArC,EAA0C;AACxC,cAAI5B,QAAQ+G,IAAI3B,OAAJ,CAAYhB,SAAZ,EAAZ;AACA,cAAI2C,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYE,QAAjC,IAA6CqU,UAA7C,IAA2D,OAAOzQ,KAAP,KAAiB,QAAhF,EAA0F;AACxFA,oBAAQyQ,WAAWzQ,KAAX,CAAR;AACD;AACD,cAAI+G,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYO,SAArC,EAAgD;AAC9CqU,0BAAca,aAAa,CAA3B;AACD;AACDA,mBAASpQ,IAAT,CAAcvB,KAAd;AACD;AACF,OAhBM,MAgBA;AACL2R,mBAAW5K,IAAI3B,OAAJ,CAAYhB,SAAZ,EAAX;AACA,YAAI2C,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYE,QAAjC,IAA6CqU,UAA7C,IAA2D,OAAOkB,QAAP,KAAoB,QAAnF,EAA6F;AAC3FA,qBAAWlB,WAAWkB,QAAX,CAAX;AACD;AACD,YAAI5K,IAAI7B,QAAJ,GAAe,CAAf,KAAqBhJ,YAAYO,SAArC,EAAgD;AAC9CoU,wBAAc9J,IAAI7B,QAAJ,GAAe,CAA7B;AACA4L,uBAAaa,aAAa,CAA1B;AACD;AACF;;AAEDD,gBAAUnQ,IAAV,CAAeoQ,QAAf;AACD;AAtCyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuC1C,SAAOD,SAAP;AACD;;AAED;;;;;AAKA,SAASE,eAAT,CAAyBrB,OAAzB,EAAkCC,MAAlC,EAA0CkB,SAA1C,EAAqD;AACnDG,UAAQC,GAAR,CAAY,YAAZ,EAA0BJ,UAAUzQ,GAAV,CAAc,UAACjB,KAAD,EAAQ+R,GAAR,EAAgB;AAAC,WAAO,EAAC5M,YAAYqL,OAAOuB,GAAP,EAAY5M,UAAzB,EAAqCnF,YAArC,EAAP;AAAoD,GAAnF,CAA1B;AACA,MAAI0Q,UAAU,CAAd;AAAA,MAAiBC,YAAY,CAAC,CAA9B;AAAA,MAAiCC,kBAAkB,CAAnD;AAFmD;AAAA;AAAA;;AAAA;AAGnD,2BAAmBL,OAAnB,wIAA4B;AAAA,UAAnBQ,MAAmB;;AAC1B,aAAOL,UAAUF,OAAO3O,MAAjB,IAA2B2O,OAAOE,OAAP,EAAgBxL,QAAhB,GAA2B6L,OAAO7L,QAApE;AAA8EwL;AAA9E,OAEA,IAAIA,UAAUF,OAAO3O,MAAjB,IAA2B2O,OAAOE,OAAP,EAAgBxL,QAAhB,KAA6B6L,OAAO7L,QAAnE,EAA6E;AAC3E,YAAMyM,WAAWD,UAAUhB,OAAV,CAAjB;AACA,YAAIK,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYC,UAAxC,EAAoD;AAClDwU,sBAAYI,OAAO7L,QAAP,IAAmB,CAA/B;AACA0L,4BAAkBe,QAAlB;AACAZ,iBAAOrL,OAAP,CAAexD,WAAf,CAA2ByP,QAA3B;AACD,SAJD,MAIO,IAAIZ,OAAO7L,QAAP,IAAmB,CAAnB,KAAyByL,SAA7B,EAAwC;AAC7C,cAAI,CAACvG,MAAMC,OAAN,CAAcsH,QAAd,CAAD,IAA4BA,SAAS9P,MAAT,KAAoB+O,eAApD,EAAqE;AACnE,kBAAM,IAAInQ,UAAJ,CAAe,iBAAf,CAAN;AACD;AAH4C;AAAA;AAAA;;AAAA;AAI7C,mCAAckR,QAAd;AAAA,kBAASrS,CAAT;AAAwByR,qBAAOrL,OAAP,CAAexD,WAAf,CAA2B5C,CAA3B;AAAxB;AAJ6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAK9C,SALM,MAKA,IAAIyR,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYQ,SAAxC,EAAmD;AACxDqU,iBAAOrL,OAAP,CAAezC,cAAf,CAA8B0O,QAA9B;AACD,SAFM,MAEA;AACLZ,iBAAOrL,OAAP,CAAexD,WAAf,CAA2ByP,QAA3B;AACD;AACF,OAhBD,MAgBO,IAAIZ,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYC,UAAxC,EAAoD;AACzDwU,oBAAYI,OAAO7L,QAAP,IAAmB,CAA/B;AACA0L,0BAAkB,CAAlB;AACAG,eAAOrL,OAAP,CAAexD,WAAf,CAA2B,CAA3B;AACD,OAJM,MAIA,IAAI6O,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYQ,SAAxC,EAAmD;AACxD,YAAM2K,QAAS0J,OAAO7L,QAAP,IAAmB,CAAnB,KAAyByL,SAA1B,GAAuCC,eAAvC,GAAyD,CAAvE;AACA,YAAIY,aAAa,IAAjB;AACA,YAAIT,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYK,OAAxC,EAAiDiV,aAAa,KAAb;AACjD,YAAIT,OAAO7L,QAAP,GAAkB,CAAlB,KAAwBhJ,YAAYO,SAAxC,EAAmD+U,aAAa,CAAb;AACnDT,eAAOrL,OAAP,CAAexD,WAAf,CAA2BsP,UAA3B,EAAuCnK,KAAvC;AACD;AACF;AAjCkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkCpD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,SAAS2K,eAAT,CAAyBjR,MAAzB,EAAiCkR,UAAjC,EAA6C;AAC3C,MAAMC,eAAenR,OAAOV,QAAP,CAAgB,CAAhB,CAArB;;AAD2C,wBAGvC4R,WAAWhR,GAAX,CAAe;AAAA,WAAO8F,IAAI3B,OAAX;AAAA,GAAf,CAHuC;AAAA;AAAA,MAEpCkK,SAFoC;AAAA,MAEzBC,OAFyB;AAAA,MAEhBC,SAFgB;AAAA,MAELC,OAFK;AAAA,MAEIC,OAFJ;AAAA,MAEaC,QAFb;AAAA,MAEuBC,MAFvB;AAAA,MAE+BC,OAF/B;AAAA,MAEwCC,OAFxC;;AAI3C,MAAIqC,YAAY,EAAhB;AAAA,MAAoBC,UAAU,IAA9B;AAAA,MAAoCC,SAAS,IAA7C;AAAA,MAAmDC,cAAc,EAAjE;AAAA,MAAqEC,UAAUxR,OAAOgB,OAAtF;;AAEA,SAAO,CAAC+N,QAAQ9I,IAAhB,EAAsB;AACpB,QAAMtJ,WAAW4R,UAAUlL,SAAV,EAAjB;AAAA,QAAwCxG,WAAW4R,UAAUpL,SAAV,EAAnD;AACA,QAAMoO,SAAS;AACb9U,gBAAWA,aAAa,IAAb,GAAoB,IAApB,GAA2BqD,OAAOV,QAAP,CAAgB3C,QAAhB,CADzB;AAEbC,cAAW4R,QAAQnL,SAAR,EAFE;AAGbxG,gBAAWA,aAAa,IAAb,GAAoB,IAApB,GAA2BmD,OAAOV,QAAP,CAAgBzC,QAAhB,CAHzB;AAIbC,cAAW4R,QAAQrL,SAAR,EAJE;AAKbtG,cAAW4R,QAAQtL,SAAR,EALE;AAMbrG,eAAWmU,YANE;AAOblU,aAAWuU,OAPE;AAQbtU,cAAW4R,QAAQzL,SAAR,EARE;AASblG,cAAW4R,QAAQ1L,SAAR,EATE;AAUbiN,oBAAgB,CAAC,CAVJ,EAUO;AACpBhC,sBAAgB,CAXH;AAYboD,kBAAgB;AAZH,KAAf;AAcA,QAAKD,OAAO7U,MAAP,KAAkB,IAAlB,IAA0B6U,OAAO9U,QAAP,KAAoB,IAA/C,IACC8U,OAAO7U,MAAP,KAAkB,IAAlB,IAA0B,OAAO6U,OAAO9U,QAAd,KAA2B,QAD1D,EACqE;AACnE,YAAM,IAAI+C,UAAJ,oCAAgD+R,OAAO7U,MAAvD,UAAkE6U,OAAO9U,QAAzE,OAAN;AACD;AACD,QAAK8U,OAAO3U,MAAP,KAAkB,IAAlB,IAA0B2U,OAAO5U,QAAP,KAAoB,IAA/C,IACC4U,OAAO3U,MAAP,KAAkB,IAAlB,IAA0B,OAAO2U,OAAO5U,QAAd,KAA2B,QAD1D,EACqE;AACnE,YAAM,IAAI6C,UAAJ,iCAA6C+R,OAAO3U,MAApD,UAA+D2U,OAAO5U,QAAtE,OAAN;AACD;AACD,QAAI4U,OAAO9U,QAAP,KAAoBwU,YAApB,IAAoCM,OAAO7U,MAAP,IAAiBoD,OAAOgB,OAA5D,IACA,CAACoQ,UAAaK,OAAO7U,MAApB,SAA8B6U,OAAO9U,QAArC,CADD,IACqD8U,OAAOvU,MADhE,EACwE;AACtEuU,aAAOC,UAAP,GAAoB,IAApB;AACD;;AAED,QAAI,CAACL,OAAL,EAAc;AACZA,gBAAUI,MAAV;AACAH,eAASG,MAAT;AACD,KAHD,MAGO,IAAIA,OAAO9U,QAAP,KAAoB2U,OAAO3U,QAA3B,IAAuC8U,OAAO7U,MAAP,KAAkB0U,OAAO1U,MAAhE,KACN6U,OAAO1U,MAAP,KAAkB,IAAlB,IAA0BuU,OAAOvU,MAAP,KAAkB,IAA5C,IAAoDuU,OAAOvU,MAAP,IAAiB0U,OAAO1U,MAA7E,IACC0U,OAAO1U,MAAP,KAAkB,IAAlB,IAA0BuU,OAAOvU,MAAP,KAAkB,IAA5C,IAAoD,CAACuU,OAAOpU,MAA5D,IAAsE,CAACuU,OAAOvU,MAD/E,IAECuU,OAAO1U,MAAP,KAAkB,IAAlB,IAA0BuU,OAAOvU,MAAP,KAAkB,IAA5C,IAAoDuU,OAAOpU,MAA3D,IAAqEuU,OAAOvU,MAA5E,IACAuU,OAAO5U,QAAP,KAAoByU,OAAOtU,OAD3B,IACsCyU,OAAO3U,MAAP,KAAkBwU,OAAOrU,KAJzD,CAAJ,EAIsE;AAC3EoU,cAAQ/C,cAAR,IAA0B,CAA1B;AACAgD,eAASG,MAAT;AACD,KAPM,MAOA;AACLL,gBAAaC,QAAQzU,MAArB,SAA+ByU,QAAQ1U,QAAvC,IAAqD,IAArD;AACA4U,kBAAY/Q,IAAZ,CAAiB6Q,OAAjB;AACAA,gBAAUI,MAAV;AACAH,eAASG,MAAT;AACD;;AAEDD,eAAW,CAAX;AACD;;AAED,MAAIH,OAAJ,EAAaE,YAAY/Q,IAAZ,CAAiB6Q,OAAjB;AACb,SAAOE,WAAP;AACD;;IAEKI,U;AACJ,sBAAYxP,MAAZ,EAAoB;AAAA;;AAClB,QAAMyP,MAAM7E,qBAAqB5K,MAArB,CAAZ;AACA,SAAKiK,cAAL,GAAsBwF,IAAIxF,cAA1B;AACA,SAAK9M,QAAL,GAAgBsS,IAAItS,QAApB;AACA,SAAK4M,KAAL,GAAa0F,IAAI1F,KAAjB;AACA,SAAK2F,UAAL,GAAkBzM,aAAawM,IAAIhF,UAAjB,EAA6B9O,eAA7B,CAAlB;AACA,SAAKgU,MAAL,GAAc,CAAd,CANkB,CAMF;AACjB;;AAED;;;;;;;;;sCAKkBtC,O,EAAS0B,U,EAAYjR,G,EAAKyP,U,EAAY;AACtD;AACA,UAAM/S,WAAW,CAAjB;AAAA,UAAoBC,SAAS,CAA7B;AAAA,UAAgCC,WAAW,CAA3C;AAAA,UAA8CC,SAAS,CAAvD;AAAA,UAA0DC,SAAS,CAAnE;AAAA,UAAsEC,UAAU,CAAhF;AAAA,UAAmFC,QAAQ,CAA3F;AAAA,UAA8FC,SAAS,CAAvG;AAAA,UACEC,SAAS,CADX;AAAA,UACcQ,UAAU,EADxB;AAAA,UAC4BC,YAAY,EADxC;AAAA,UAC4CC,UAAU,EADtD;AAAA,UAC0DE,UAAU,EADpE;AAAA,UACwEC,YAAY,EADpF;AAAA,UACwFC,UAAU,EADlG;AAEA,UAAI,KAAK4T,UAAL,CAAgBlV,QAAhB,EAA2BwH,QAA3B,KAAwCrG,gBAAgBnB,QAAxD,IAAqEuU,WAAWvU,QAAX,EAAsBwH,QAAtB,KAAmC3G,eAAeb,QAAvH,IACA,KAAKkV,UAAL,CAAgBjV,MAAhB,EAA2BuH,QAA3B,KAAwCrG,gBAAgBlB,MADxD,IACqEsU,WAAWtU,MAAX,EAAsBuH,QAAtB,KAAmC3G,eAAeZ,MADvH,IAEA,KAAKiV,UAAL,CAAgBhV,QAAhB,EAA2BsH,QAA3B,KAAwCrG,gBAAgBjB,QAFxD,IAEqEqU,WAAWrU,QAAX,EAAsBsH,QAAtB,KAAmC3G,eAAeX,QAFvH,IAGA,KAAKgV,UAAL,CAAgB/U,MAAhB,EAA2BqH,QAA3B,KAAwCrG,gBAAgBhB,MAHxD,IAGqEoU,WAAWpU,MAAX,EAAsBqH,QAAtB,KAAmC3G,eAAeV,MAHvH,IAIA,KAAK+U,UAAL,CAAgB9U,MAAhB,EAA2BoH,QAA3B,KAAwCrG,gBAAgBf,MAJxD,IAIqEmU,WAAWnU,MAAX,EAAsBoH,QAAtB,KAAmC3G,eAAeT,MAJvH,IAKA,KAAK8U,UAAL,CAAgB7U,OAAhB,EAA2BmH,QAA3B,KAAwCrG,gBAAgBd,OALxD,IAKqEkU,WAAWlU,OAAX,EAAsBmH,QAAtB,KAAmC3G,eAAeR,OALvH,IAMA,KAAK6U,UAAL,CAAgB5U,KAAhB,EAA2BkH,QAA3B,KAAwCrG,gBAAgBb,KANxD,IAMqEiU,WAAWjU,KAAX,EAAsBkH,QAAtB,KAAmC3G,eAAeP,KANvH,IAOA,KAAK4U,UAAL,CAAgB3U,MAAhB,EAA2BiH,QAA3B,KAAwCrG,gBAAgBZ,MAPxD,IAOqEgU,WAAWhU,MAAX,EAAsBiH,QAAtB,KAAmC3G,eAAeN,MAPvH,IAQA,KAAK2U,UAAL,CAAgB1U,MAAhB,EAA2BgH,QAA3B,KAAwCrG,gBAAgBX,MARxD,IAQqE+T,WAAW/T,MAAX,EAAsBgH,QAAtB,KAAmC3G,eAAeL,MARvH,IASA,KAAK0U,UAAL,CAAgB9T,OAAhB,EAA2BoG,QAA3B,KAAwCrG,gBAAgBC,OATxD,IASqEmT,WAAWvT,OAAX,EAAsBwG,QAAtB,KAAmC3G,eAAeG,OATvH,IAUA,KAAKkU,UAAL,CAAgB7T,SAAhB,EAA2BmG,QAA3B,KAAwCrG,gBAAgBE,SAVxD,IAUqEkT,WAAWtT,SAAX,EAAsBuG,QAAtB,KAAmC3G,eAAeI,SAVvH,IAWA,KAAKiU,UAAL,CAAgB5T,OAAhB,EAA2BkG,QAA3B,KAAwCrG,gBAAgBG,OAXxD,IAWqEiT,WAAWrT,OAAX,EAAsBsG,QAAtB,KAAmC3G,eAAeK,OAX3H,EAWoI;AAClI,cAAM,IAAI6B,UAAJ,CAAe,qBAAf,CAAN;AACD;;AAED,UAAIqS,UAAU9R,IAAIqO,cAAlB;AAAA,UAAkC0D,cAAc,CAAhD;AAAA,UAAmDR,UAAUvR,IAAIhD,KAAjE;AACA,UAAIgV,QAAQ,KAAKJ,UAAL,CAAgB1U,MAAhB,EAAwBkH,OAAxB,CAAgC4B,IAAhC,GAAuC,IAAvC,GAA8CyK,cAAc,KAAKmB,UAAnB,CAA1D;AACA,UAAIK,iBAAkBD,UAAU,IAAV,GAAiB,CAAjB,GAAqB,CAA3C;AACA,UAAIE,WAAWzB,cAAcQ,UAAd,EAA0BxB,UAA1B,CAAf;AACAyC,eAASnV,OAAT,IAAoBiD,IAAIqQ,YAAxB;AACA6B,eAASlV,KAAT,IAAkBuU,OAAlB;;AAEA;AACA;AACA;AACA,aAAOO,UAAU,CAAjB,EAAoB;AAClB,YAAIK,YAAY,KAAhB;AAAA,YAAuBC,eAAe,KAAtC;AAAA,YAA6CC,eAAe,KAA5D;AACA;AACA,YAAIH,SAASjV,MAAT,CAAJ,EAAsB,MAAM,IAAIwC,UAAJ,CAAe,6BAAf,CAAN;;AAEtB;AACA;AACA;AACA;AACA;AACA,YAAI,CAACuS,KAAD,IAAUA,MAAMtV,QAAN,MAAoBwV,SAASxV,QAAT,CAA9B,IAAoDsV,MAAMrV,MAAN,MAAkBuV,SAASvV,MAAT,CAAtE,IACCqV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IADhD,IAECkV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IAA/C,IAAuDoV,SAASpV,MAAT,IAAmBkV,MAAMlV,MAAN,CAF/E,EAE+F;AAC7F;AACAsV,yBAAe,IAAf;AACA,cAAIF,SAASpV,MAAT,MAAqB,IAArB,IAA6B,CAACoV,SAASjV,MAAT,CAAlC,EAAoD;AAClD;AACA;AACA,kBAAM,IAAIwC,UAAJ,0DAAqEyS,SAASrV,MAAT,CAArE,SAAyF,KAAKwC,QAAL,CAAc6S,SAAStV,QAAT,CAAd,CAAzF,CAAN;AACD;AAEF,SAXD,MAWO,IAAKoV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IAAhD,IACCkV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IAA/C,IAAuDkV,MAAMlV,MAAN,IAAgBoV,SAASpV,MAAT,CADxE,IAECkV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IAA/C,IAAuD,CAACkV,MAAM/U,MAAN,CAAxD,KACC+U,MAAMpV,QAAN,MAAoBsV,SAAStV,QAAT,CAApB,IAA0CoV,MAAMnV,MAAN,MAAkBqV,SAASrV,MAAT,CAD7D,KAEAmV,MAAMlV,MAAN,MAAkB,IAAlB,IAA0BoV,SAASpV,MAAT,MAAqB,IAA/C,IAAuDkV,MAAM/U,MAAN,CAAvD,KACC+U,MAAMjV,OAAN,MAAmBmV,SAAStV,QAAT,CAAnB,IAAyCoV,MAAMhV,KAAN,MAAiBkV,SAASrV,MAAT,CAD3D,CAJL,EAKqF;AAC1F;AACAsV,sBAAY,IAAZ;AAED,SATM,MASA;AACL;AACA;AACA;AACA,eAAK,IAAIvR,IAAI,CAAb,EAAgBA,IAAIsR,SAASxU,OAAT,CAApB,EAAuCkD,GAAvC,EAA4C;AAC1C,gBAAIsR,SAASvU,SAAT,EAAoBiD,CAApB,MAA2BoR,MAAMjV,OAAN,CAA3B,IAA6CmV,SAAStU,OAAT,EAAkBgD,CAAlB,MAAyBoR,MAAMhV,KAAN,CAA1E,EAAwF;AACtF;AACA,kBAAIsV,IAAI,CAAR;AACA,qBAAOA,IAAIN,MAAMlU,OAAN,CAAJ,KAAuBkU,MAAMhU,OAAN,EAAesU,CAAf,IAAoBf,OAApB,IACvBS,MAAMhU,OAAN,EAAesU,CAAf,MAAsBf,OAAtB,IAAiC,KAAKlS,QAAL,CAAc2S,MAAMjU,SAAN,EAAiBuU,CAAjB,CAAd,IAAqCtS,IAAIjD,OAD1E,CAAP;AAC2FuV;AAD3F,eAEAN,MAAMhU,OAAN,EAAeuU,MAAf,CAAsBD,CAAtB,EAAyB,CAAzB,EAA4Bf,OAA5B;AACAS,oBAAMjU,SAAN,EAAiBwU,MAAjB,CAAwBD,CAAxB,EAA2B,CAA3B,EAA8BtS,IAAIqQ,YAAlC;AACA2B,oBAAMlU,OAAN;AACAoU,uBAAStU,OAAT,EAAkB2U,MAAlB,CAAyB3R,CAAzB,EAA4B,CAA5B;AACAsR,uBAASvU,SAAT,EAAoB4U,MAApB,CAA2B3R,CAA3B,EAA8B,CAA9B;AACAsR,uBAASxU,OAAT;AACA;AACD;AACF;;AAED;AACA;AACA,cAAIsU,MAAMhV,KAAN,IAAeuU,OAAf,IAA2BS,MAAMhV,KAAN,MAAiBuU,OAAjB,IAA4B,KAAKlS,QAAL,CAAc2S,MAAMjV,OAAN,CAAd,IAAgCiD,IAAIjD,OAA/F,EAAyG;AACvG;AACAoV,wBAAY,IAAZ;;AAEA;AACA;AACA,gBAAID,SAAShV,MAAT,MAAqBV,QAAQ0C,OAAR,CAAgB,KAAhB,CAArB,IAA+CgT,SAASxU,OAAT,MAAsB,CAAzE,EAA4E2U,eAAe,IAAf;AAE7E,WARD,MAQO,IAAIL,MAAMhV,KAAN,MAAiBuU,OAAjB,IAA4B,KAAKlS,QAAL,CAAc2S,MAAMjV,OAAN,CAAd,MAAkCiD,IAAIjD,OAAtE,EAA+E;AACpF,kBAAM,IAAI0C,UAAJ,8BAA0C8R,OAA1C,SAAqDvR,IAAIjD,OAAzD,CAAN;AACD,WAFM,MAEA;AACL;AACA;AACA,gBAAImV,SAASxU,OAAT,IAAoB,CAAxB,EAA2B;AACzB,oBAAM,IAAI+B,UAAJ,sCAAkDyS,SAAStU,OAAT,EAAkB,CAAlB,CAAlD,SAA0E,KAAKyB,QAAL,CAAc6S,SAASvU,SAAT,EAAoB,CAApB,CAAd,CAA1E,CAAN;AACD;AACDyU,2BAAe,IAAf;AACD;AACF;;AAED,YAAID,SAAJ,EAAe;AACbvB,0BAAgBrB,OAAhB,EAAyB,KAAKqC,UAA9B,EAA0CI,KAA1C;AACAD;AACAC,kBAAQ,KAAKJ,UAAL,CAAgB1U,MAAhB,EAAwBkH,OAAxB,CAAgC4B,IAAhC,GAAuC,IAAvC,GAA8CyK,cAAc,KAAKmB,UAAnB,CAAtD;AACA,cAAII,UAAU,IAAd,EAAoBC;AACrB;AACD,YAAIG,YAAJ,EAAkB;AAChBxB,0BAAgBrB,OAAhB,EAAyB0B,UAAzB,EAAqCiB,QAArC;AACAH;AACD;AACD,YAAIK,gBAAgBC,YAApB,EAAkC;AAChCP;AACAP;AACA,cAAIO,UAAU,CAAd,EAAiB;AACfI,uBAAWzB,cAAcQ,UAAd,EAA0BxB,UAA1B,CAAX;AACAyC,qBAASnV,OAAT,IAAoBiD,IAAIqQ,YAAxB;AACA6B,qBAASlV,KAAT,IAAkBuU,OAAlB;AACD;AACF;AACF;;AAED,UAAIS,KAAJ,EAAW;AACTpB,wBAAgBrB,OAAhB,EAAyBnB,OAAzB,EAAkC4D,KAAlC;AACAD;AACD;AACD,aAAO,EAACA,wBAAD,EAAcE,8BAAd,EAAP;AACD;;;6BAEQjS,G,EAAKwS,W,EAAaC,O,EAASxB,U,EAAYxB,U,EAAY;AAC1D,UAAIiD,cAAc,CAAlB;AAAA,UAAqBnD,UAAUkD,QAAQxS,GAAR,CAAY,oBAAY;AACrD,eAAO,EAACiE,kBAAD,EAAWQ,SAASO,kBAAkBf,QAAlB,CAApB,EAAP;AACD,OAF8B,CAA/B;AAGA,UAAIyO,eAAe,KAAKd,MAAL,GAAcW,WAAjC;AACAlD,kBAAYC,OAAZ,EAAqB,KAAKqC,UAA1B,EAAsCY,WAAtC;AACA,UAAIxS,IAAIyR,UAAR,EAAoB;AAClBnC,oBAAYC,OAAZ,EAAqB0B,UAArB,EAAiCjR,IAAIqO,cAArC,EAAqDoB,UAArD,EAAiEzP,GAAjE;AACA0S,sBAAc1S,IAAIqO,cAAlB;AACD,OAHD,MAGO;AAAA,iCACiC,KAAKuE,iBAAL,CAAuBrD,OAAvB,EAAgC0B,UAAhC,EAA4CjR,GAA5C,EAAiDyP,UAAjD,CADjC;AAAA,YACEsC,WADF,sBACEA,WADF;AAAA,YACeE,cADf,sBACeA,cADf;;AAELU,wBAAgBV,cAAhB;AACAS,sBAAcX,cAAcE,cAA5B;AACD;AACD;AACA;AACA;AACA3C,kBAAYC,OAAZ,EAAqB,KAAKqC,UAA1B,EAAsCe,YAAtC;AAjB0D;AAAA;AAAA;;AAAA;AAkB1D,+BAAgB,KAAKf,UAArB,wIAAiC;AAAA,cAAxB7L,GAAwB;;AAC/B,cAAI,CAACA,IAAI3B,OAAJ,CAAY4B,IAAjB,EAAuB,MAAM,IAAIvG,UAAJ,oBAAgCsG,IAAI5B,UAApC,aAAN;AACxB;AApByD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsB1D,WAAKyN,UAAL,GAAkBrC,QAAQtP,GAAR,CAAY,eAAO;AACnC,YAAMmE,UAAUc,kBAAkBa,IAAI7B,QAAtB,EAAgC6B,IAAIrB,OAAJ,CAAYxC,MAA5C,CAAhB;AACA,eAAO,EAACgC,UAAU6B,IAAI7B,QAAf,EAAyBC,YAAYlG,oBAAoB8H,IAAI7B,QAAxB,CAArC,EAAwEE,gBAAxE,EAAP;AACD,OAHiB,CAAlB;AAIA,WAAKyN,MAAL,IAAea,WAAf;AACA7B,cAAQC,GAAR,CAAY,kBAAZ,EAAgC,KAAKc,UAAL,CAAgB3R,GAAhB,CAAoB,eAAO;AAAE,eAAO,EAACkE,YAAY4B,IAAI5B,UAAjB,EAA6BjC,QAAQ6D,IAAI3B,OAAJ,CAAYyE,GAAjD,EAAP;AAA6D,OAA1F,CAAhC;AACD;;AAED;;;;;;;;kCAKcoI,U,EAAY;AACxB,UAAM4B,eAAe,CACnB,UADmB,EACP,QADO,EACG,UADH,EACe,QADf,EACyB,QADzB,EACmC,SADnC,EAC8C,OAD9C,EACuD,QADvD,EAEnB,QAFmB,EAET,QAFS,EAEC,QAFD,EAEW,WAFX,EAEwB,SAFxB,EAEmC,SAFnC,EAE8C,WAF9C,EAE2D,SAF3D,CAArB;AAIA,UAAIJ,UAAU,EAAd;AACA,WAAK,IAAI7R,IAAI,CAAb,EAAgBA,IAAIiS,aAAahS,MAAjC,EAAyCD,GAAzC,EAA8C;AAC5C,YAAIqQ,WAAWrQ,CAAX,EAAcuD,UAAd,KAA6B0O,aAAajS,CAAb,CAAjC,EAAkD;AAChD,gBAAM,IAAInB,UAAJ,sBAAkCoT,aAAajS,CAAb,CAAlC,kBAA8DA,CAA9D,cAAwEqQ,WAAWrQ,CAAX,EAAcuD,UAAtF,CAAN;AACD;AACF;AAVuB;AAAA;AAAA;;AAAA;AAWxB,+BAAgB8M,UAAhB;AAAA,cAASlL,GAAT;AAA4B0M,kBAAQ1M,IAAI7B,QAAZ,IAAwB,IAAxB;AAA5B;AAXwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAYxB,+BAAmC1G,OAAOU,OAAP,CAAeL,eAAf,CAAnC;AAAA;;AAAA;;AAAA,cAAUsG,UAAV;AAAA,cAAsBD,QAAtB;AAAoEuO,kBAAQvO,QAAR,IAAoB,IAApB;AAApE,SAZwB,CAcxB;AACA;AAfwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBxB,aAAOuO,QAAQlV,eAAeG,OAAvB,CAAP;AACA,aAAO+U,QAAQlV,eAAeI,SAAvB,CAAP;AACA,aAAO8U,QAAQlV,eAAeK,OAAvB,CAAP;AACA,aAAOJ,OAAOgD,IAAP,CAAYiS,OAAZ,EAAqBxS,GAArB,CAAyB;AAAA,eAAM0F,SAAS7E,EAAT,CAAN;AAAA,OAAzB,EAA6CL,IAA7C,CAAkD,UAACkE,CAAD,EAAIC,CAAJ;AAAA,eAAUD,IAAIC,CAAd;AAAA,OAAlD,CAAP;AACD;;AAED;;;;;;;kCAIc7E,M,EAAQ;AACpB;AACA,UAAI,KAAKV,QAAL,CAAcH,OAAd,CAAsBa,OAAOV,QAAP,CAAgB,CAAhB,CAAtB,IAA4C,CAAhD,EAAmD;AACjD,YAAIU,OAAOtB,GAAP,KAAe,CAAnB,EAAsB;AACpB,gBAAM,IAAIgB,UAAJ,UAAsBM,OAAOtB,GAA7B,uCAAkEsB,OAAOV,QAAP,CAAgB,CAAhB,CAAlE,CAAN;AACD;AACD,aAAKA,QAAL,CAAckB,IAAd,CAAmBR,OAAOV,QAAP,CAAgB,CAAhB,CAAnB;AACD;AACD,UAAMoQ,aAAa,EAAnB,CARoB,CAQE;AARF;AAAA;AAAA;;AAAA;AASpB,+BAAoB1P,OAAOV,QAA3B,wIAAqC;AAAA,cAA5BC,OAA4B;;AACnC,cAAMmM,QAAQ,KAAKpM,QAAL,CAAcH,OAAd,CAAsBI,OAAtB,CAAd;AACA,cAAImM,QAAQ,CAAZ,EAAe;AACb,kBAAM,IAAIhM,UAAJ,cAA0BH,OAA1B,+BAAN;AACD;AACDmQ,qBAAWlP,IAAX,CAAgBkL,KAAhB;AACD;AAfmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBpB,aAAOgE,UAAP;AACD;;AAED;;;;;;;gCAIYqD,Y,EAAc;AACxB,UAAM/S,SAASyJ,oBAAoBsJ,YAApB,CAAf,CADwB,CACyB;AACjD,UAAM7B,aAAa9L,aAAapF,OAAOkB,OAApB,EAA6B1D,cAA7B,CAAnB;AACA,UAAMkV,UAAU,KAAKM,aAAL,CAAmB9B,UAAnB,CAAhB;AACA,UAAMxB,aAAa,KAAKuD,aAAL,CAAmBjT,MAAnB,CAAnB;AACA,UAAMuR,cAAcN,gBAAgBjR,MAAhB,EAAwBkR,UAAxB,CAApB;AACA,UAAMgC,aAAa,KAAK5T,QAAL,CAAcH,OAAd,CAAsBa,OAAOV,QAAP,CAAgB,CAAhB,CAAtB,CAAnB;;AANwB;AAAA;AAAA;;AAAA;AAQxB,+BAAgB4R,UAAhB;AAAA,cAASlL,GAAT;AAA4BA,cAAI3B,OAAJ,CAAY8O,KAAZ;AAA5B;AARwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AASxB,+BAAe5B,WAAf,wIAA4B;AAAA,cAAnBpR,EAAmB;;AAC1BA,aAAGmQ,YAAH,GAAkB4C,UAAlB;AAD0B;AAAA;AAAA;;AAAA;AAE1B,mCAAgB,KAAKrB,UAArB;AAAA,kBAAS7L,IAAT;AAAiCA,mBAAI3B,OAAJ,CAAY8O,KAAZ;AAAjC;AAF0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAG1B,cAAMnE,YAAYZ,SAASjO,EAAT,EAAa,KAAK0R,UAAlB,EAA8B,KAAKvS,QAAnC,CAAlB;AAH0B;AAAA;AAAA;;AAAA;AAI1B,mCAAgB,KAAKuS,UAArB;AAAA,kBAAS7L,KAAT;AAAiCA,oBAAI3B,OAAJ,CAAY8O,KAAZ;AAAjC;AAJ0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAK1B,eAAKC,QAAL,CAAcjT,EAAd,EAAkB6O,SAAlB,EAA6B0D,OAA7B,EAAsCxB,UAAtC,EAAkDxB,UAAlD;AACD;AAfuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBzB;;;;;;AAGH2D,OAAOC,OAAP,GAAiB;AACfnY,0BADe,EACFS,sBADE,EACUa,gBADV,EACmBqB,gCADnB,EACoCN,8BADpC,EACoDgB,kCADpD;AAEfsL,kCAFe,EAEEd,0BAFF,EAEgBW,0BAFhB,EAE8BC,kCAF9B,EAEgDK,4BAFhD,EAE+D0C,8BAF/D,EAE+ErC,8BAF/E;AAGfuD,gCAHe,EAGC8D;AAHD,CAAjB,C;;;;;;;;;;;;;;;;;;;;;;;;AC5pDA;;;AAGA,IAAI4B,qBAAJ;AAAA,IAAkBC,qBAAlB;;AAEA,IAAI,OAAOC,WAAP,KAAuB,UAAvB,IAAqC,OAAOC,WAAP,KAAuB,UAAhE,EAA4E;AAC1E;AACA;AACA;AACA,MAAMC,cAAc,IAAIF,WAAJ,EAApB;AAAA,MAAuCG,cAAc,IAAIF,WAAJ,CAAgB,OAAhB,CAArD;AACAH,iBAAe,sBAACM,MAAD;AAAA,WAAYF,YAAYG,MAAZ,CAAmBD,MAAnB,CAAZ;AAAA,GAAf;AACAL,iBAAe,sBAACrR,MAAD;AAAA,WAAYyR,YAAYG,MAAZ,CAAmB5R,MAAnB,CAAZ;AAAA,GAAf;AAED,CARD,MAQO,IAAI,OAAO6R,MAAP,KAAkB,UAAtB,EAAkC;AACvC;AACA;AACA;AAHuC,iBAIbha,mBAAOA,CAAC,2EAAR,CAJa;AAAA,MAI/Bia,aAJ+B,YAI/BA,aAJ+B;;AAKvC,MAAML,eAAc,IAAIK,aAAJ,CAAkB,MAAlB,CAApB;AACAV,iBAAe,sBAACM,MAAD;AAAA,WAAYG,OAAOE,IAAP,CAAYL,MAAZ,EAAoB,MAApB,CAAZ;AAAA,GAAf;AACA;AACA;AACA;AACAL,iBAAe,sBAACrR,MAAD;AAAA,WAAYyR,aAAYO,GAAZ,CAAgBH,OAAOE,IAAP,CAAY/R,MAAZ,CAAhB,CAAZ;AAAA,GAAf;AAED,CAZM,MAYA;AACL;AACA,QAAM,IAAIiS,KAAJ,CAAU,2DAAV,CAAN;AACD;;AAGD;;;AAGA,SAAS/Z,gBAAT,CAA0B4E,KAA1B,EAAiC;AAC/B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAIsK,SAAJ,CAAc,uBAAd,CAAN;AACD;AACD,MAAI,CAAC,wBAAwB8K,IAAxB,CAA6BpV,KAA7B,CAAL,EAA0C;AACxC,UAAM,IAAIS,UAAJ,CAAe,0BAAf,CAAN;AACD;AACD,MAAIT,UAAU,EAAd,EAAkB;AAChB,WAAO,IAAIhE,UAAJ,CAAe,CAAf,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAIA,UAAJ,CAAegE,MAAMqV,KAAN,CAAY,KAAZ,EAAmBpU,GAAnB,CAAuB;AAAA,aAAK0F,SAASf,CAAT,EAAY,EAAZ,CAAL;AAAA,KAAvB,CAAf,CAAP;AACD;AACF;;AAED;;;AAGA,SAASvK,gBAAT,CAA0BiJ,KAA1B,EAAiC;AAC/B,MAAMgR,MAAM,EAAZ;AAD+B;AAAA;AAAA;;AAAA;AAE/B,yBAAchR,KAAd,8HAAqB;AAAA,UAAZsB,CAAY;;AACnB,UAAIA,IAAI,CAAJ,IAASA,IAAI,GAAjB,EAAsB,MAAM,IAAInF,UAAJ,sCAAkDmF,CAAlD,CAAN;AACtB0P,UAAI/T,IAAJ,CAAS,CAAC,MAAMqE,EAAEc,QAAF,CAAW,EAAX,CAAP,EAAuByD,KAAvB,CAA6B,CAAC,CAA9B,CAAT;AACD;AAL8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAM/B,SAAOmL,IAAI7H,IAAJ,CAAS,EAAT,CAAP;AACD;;AAED;;;;;IAIMnS,O;AACJ,qBAAc;AAAA;;AACZ,SAAKuO,GAAL,GAAW,IAAI7N,UAAJ,CAAe,EAAf,CAAX;AACA,SAAKyN,MAAL,GAAc,CAAd;AACD;;AAED;;;;;;;;;AAQA;;;2BAGkB;AAAA,UAAb8L,OAAa,uEAAH,CAAG;;AAChB,UAAIC,UAAU,KAAK3L,GAAL,CAAShF,UAAT,GAAsB,CAApC;AACA,aAAO2Q,UAAUD,OAAjB;AAA0BC,mBAAW,CAAX;AAA1B,OACA,IAAMC,SAAS,IAAIzZ,UAAJ,CAAewZ,OAAf,CAAf;AACAC,aAAOrM,GAAP,CAAW,KAAKS,GAAhB,EAAqB,CAArB;AACA,WAAKA,GAAL,GAAW4L,MAAX;AACA,aAAO,IAAP;AACD;;AAED;;;;;;+BAGWzV,K,EAAO;AAChB,UAAI,KAAKyJ,MAAL,IAAe,KAAKI,GAAL,CAAShF,UAA5B,EAAwC,KAAK6Q,IAAL;AACxC,WAAK7L,GAAL,CAAS,KAAKJ,MAAd,IAAwBzJ,KAAxB;AACA,WAAKyJ,MAAL,IAAe,CAAf;AACD;;AAED;;;;;;;;iCAKazJ,K,EAAO;AAClB,UAAI,CAACoD,OAAOC,SAAP,CAAiBrD,KAAjB,CAAL,EAA8B,MAAM,IAAIS,UAAJ,CAAe,yBAAf,CAAN;AAC9B,UAAIT,QAAQ,CAAR,IAAaA,QAAQ,UAAzB,EAAqC,MAAM,IAAIS,UAAJ,CAAe,qBAAf,CAAN;;AAErC,UAAMiC,WAAWgK,KAAKiJ,GAAL,CAAS,CAAT,EAAYjJ,KAAKkJ,IAAL,CAAU,CAAC,KAAKlJ,KAAKmJ,KAAL,CAAW7V,KAAX,CAAN,IAA2B,CAArC,CAAZ,CAAjB;AACA,UAAI,KAAKyJ,MAAL,GAAc/G,QAAd,GAAyB,KAAKmH,GAAL,CAAShF,UAAtC,EAAkD,KAAK6Q,IAAL;;AAElD,WAAK,IAAI9T,IAAI,CAAb,EAAgBA,IAAIc,QAApB,EAA8Bd,GAA9B,EAAmC;AACjC,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,CAAvB,IAA6B5B,QAAQ,IAAT,IAAkB4B,MAAMc,WAAW,CAAjB,GAAqB,IAArB,GAA4B,IAA9C,CAA5B;AACA1C,mBAAW,CAAX,CAFiC,CAEpB;AACd;AACD,WAAKyJ,MAAL,IAAe/G,QAAf;AACA,aAAOA,QAAP;AACD;;AAED;;;;;;;;gCAKY1C,K,EAAO;AACjB,UAAI,CAACoD,OAAOC,SAAP,CAAiBrD,KAAjB,CAAL,EAA8B,MAAM,IAAIS,UAAJ,CAAe,yBAAf,CAAN;AAC9B,UAAIT,QAAQ,CAAC,UAAT,IAAuBA,QAAQ,UAAnC,EAA+C,MAAM,IAAIS,UAAJ,CAAe,qBAAf,CAAN;;AAE/C,UAAMiC,WAAWgK,KAAKkJ,IAAL,CAAU,CAAC,KAAKlJ,KAAKmJ,KAAL,CAAW7V,SAAS,CAAT,GAAaA,KAAb,GAAqB,CAACA,KAAD,GAAS,CAAzC,CAAN,IAAqD,CAA/D,CAAjB;AACA,UAAI,KAAKyJ,MAAL,GAAc/G,QAAd,GAAyB,KAAKmH,GAAL,CAAShF,UAAtC,EAAkD,KAAK6Q,IAAL;;AAElD,WAAK,IAAI9T,IAAI,CAAb,EAAgBA,IAAIc,QAApB,EAA8Bd,GAA9B,EAAmC;AACjC,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,CAAvB,IAA6B5B,QAAQ,IAAT,IAAkB4B,MAAMc,WAAW,CAAjB,GAAqB,IAArB,GAA4B,IAA9C,CAA5B;AACA1C,kBAAU,CAAV,CAFiC,CAErB;AACb;AACD,WAAKyJ,MAAL,IAAe/G,QAAf;AACA,aAAOA,QAAP;AACD;;AAED;;;;;;;;iCAKa1C,K,EAAO;AAClB,UAAI,CAACoD,OAAOC,SAAP,CAAiBrD,KAAjB,CAAL,EAA8B,MAAM,IAAIS,UAAJ,CAAe,yBAAf,CAAN;AAC9B,UAAIT,QAAQ,CAAR,IAAaA,QAAQoD,OAAOE,gBAAhC,EAAkD;AAChD,cAAM,IAAI7C,UAAJ,CAAe,qBAAf,CAAN;AACD;AACD,UAAMqV,SAASpJ,KAAKC,KAAL,CAAW3M,QAAQ,WAAnB,CAAf;AACA,UAAM+V,QAAQ,CAAC/V,QAAQ,UAAT,MAAyB,CAAvC,CANkB,CAMuB;AACzC,aAAO,KAAKgW,YAAL,CAAkBF,MAAlB,EAA0BC,KAA1B,CAAP;AACD;;AAED;;;;;;;;gCAKY/V,K,EAAO;AACjB,UAAI,CAACoD,OAAOC,SAAP,CAAiBrD,KAAjB,CAAL,EAA8B,MAAM,IAAIS,UAAJ,CAAe,yBAAf,CAAN;AAC9B,UAAIT,QAAQoD,OAAOG,gBAAf,IAAmCvD,QAAQoD,OAAOE,gBAAtD,EAAwE;AACtE,cAAM,IAAI7C,UAAJ,CAAe,qBAAf,CAAN;AACD;AACD,UAAMqV,SAASpJ,KAAKC,KAAL,CAAW3M,QAAQ,WAAnB,CAAf;AACA,UAAM+V,QAAQ,CAAC/V,QAAQ,UAAT,MAAyB,CAAvC,CANiB,CAMwB;AACzC,aAAO,KAAKiW,WAAL,CAAiBH,MAAjB,EAAyBC,KAAzB,CAAP;AACD;;AAED;;;;;;;;;iCAMaD,M,EAAQC,K,EAAO;AAC1B,UAAI,CAAC3S,OAAOC,SAAP,CAAiByS,MAAjB,CAAD,IAA6B,CAAC1S,OAAOC,SAAP,CAAiB0S,KAAjB,CAAlC,EAA2D;AACzD,cAAM,IAAItV,UAAJ,CAAe,yBAAf,CAAN;AACD;AACD,UAAIqV,SAAS,CAAT,IAAcA,SAAS,UAAvB,IAAqCC,QAAQ,CAA7C,IAAkDA,QAAQ,UAA9D,EAA0E;AACxE,cAAM,IAAItV,UAAJ,CAAe,qBAAf,CAAN;AACD;AACD,UAAIqV,WAAW,CAAf,EAAkB,OAAO,KAAKI,YAAL,CAAkBH,KAAlB,CAAP;;AAElB,UAAMrT,WAAWgK,KAAKkJ,IAAL,CAAU,CAAC,KAAKlJ,KAAKmJ,KAAL,CAAWC,MAAX,CAAN,IAA4B,CAAtC,CAAjB;AACA,UAAI,KAAKrM,MAAL,GAAc/G,QAAd,GAAyB,KAAKmH,GAAL,CAAShF,UAAtC,EAAkD,KAAK6Q,IAAL;AAClD,WAAK,IAAI9T,IAAI,CAAb,EAAgBA,IAAI,CAApB,EAAuBA,GAAvB,EAA4B;AAC1B,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,CAAvB,IAA6BmU,QAAQ,IAAT,GAAiB,IAA7C;AACAA,mBAAW,CAAX,CAF0B,CAEb;AACd;AACD,WAAKlM,GAAL,CAAS,KAAKJ,MAAL,GAAc,CAAvB,IAA6BsM,QAAQ,IAAT,GAAkB,CAACD,SAAS,IAAV,KAAmB,CAArC,IAA2CpT,aAAa,CAAb,GAAiB,IAAjB,GAAwB,IAAnE,CAA5B;AACAoT,kBAAY,CAAZ;AACA,WAAK,IAAIlU,KAAI,CAAb,EAAgBA,KAAIc,QAApB,EAA8Bd,IAA9B,EAAmC;AACjC,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,EAAvB,IAA6BkU,SAAS,IAAV,IAAmBlU,OAAMc,WAAW,CAAjB,GAAqB,IAArB,GAA4B,IAA/C,CAA5B;AACAoT,oBAAY,CAAZ;AACD;AACD,WAAKrM,MAAL,IAAe/G,QAAf;AACA,aAAOA,QAAP;AACD;;AAED;;;;;;;;;;;gCAQYoT,M,EAAQC,K,EAAO;AACzB,UAAI,CAAC3S,OAAOC,SAAP,CAAiByS,MAAjB,CAAD,IAA6B,CAAC1S,OAAOC,SAAP,CAAiB0S,KAAjB,CAAlC,EAA2D;AACzD,cAAM,IAAItV,UAAJ,CAAe,yBAAf,CAAN;AACD;AACD,UAAIqV,SAAS,CAAC,UAAV,IAAwBA,SAAS,UAAjC,IAA+CC,QAAQ,CAAC,UAAxD,IAAsEA,QAAQ,UAAlF,EAA8F;AAC5F,cAAM,IAAItV,UAAJ,CAAe,qBAAf,CAAN;AACD;AACDsV,iBAAW,CAAX,CAPyB,CAOZ;AACb,UAAID,WAAW,CAAX,IAAgBC,SAAS,UAA7B,EAAyC,OAAO,KAAKI,WAAL,CAAiBJ,KAAjB,CAAP;AACzC,UAAID,WAAW,CAAC,CAAZ,IAAiBC,SAAS,UAA9B,EAA0C,OAAO,KAAKI,WAAL,CAAiBJ,QAAQ,WAAzB,CAAP;;AAE1C,UAAMrT,WAAWgK,KAAKkJ,IAAL,CAAU,CAAC,KAAKlJ,KAAKmJ,KAAL,CAAWC,UAAU,CAAV,GAAcA,MAAd,GAAuB,CAACA,MAAD,GAAU,CAA5C,CAAN,IAAwD,CAAlE,CAAjB;AACA,UAAI,KAAKrM,MAAL,GAAc/G,QAAd,GAAyB,KAAKmH,GAAL,CAAShF,UAAtC,EAAkD,KAAK6Q,IAAL;AAClD,WAAK,IAAI9T,IAAI,CAAb,EAAgBA,IAAI,CAApB,EAAuBA,GAAvB,EAA4B;AAC1B,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,CAAvB,IAA6BmU,QAAQ,IAAT,GAAiB,IAA7C;AACAA,mBAAW,CAAX,CAF0B,CAEb;AACd;AACD,WAAKlM,GAAL,CAAS,KAAKJ,MAAL,GAAc,CAAvB,IAA6BsM,QAAQ,IAAT,GAAkB,CAACD,SAAS,IAAV,KAAmB,CAArC,IAA2CpT,aAAa,CAAb,GAAiB,IAAjB,GAAwB,IAAnE,CAA5B;AACAoT,iBAAW,CAAX,CAlByB,CAkBZ;AACb,WAAK,IAAIlU,MAAI,CAAb,EAAgBA,MAAIc,QAApB,EAA8Bd,KAA9B,EAAmC;AACjC,aAAKiI,GAAL,CAAS,KAAKJ,MAAL,GAAc7H,GAAvB,IAA6BkU,SAAS,IAAV,IAAmBlU,QAAMc,WAAW,CAAjB,GAAqB,IAArB,GAA4B,IAA/C,CAA5B;AACAoT,mBAAW,CAAX;AACD;AACD,WAAKrM,MAAL,IAAe/G,QAAf;AACA,aAAOA,QAAP;AACD;;AAED;;;;;;;mCAIe0T,I,EAAM;AACnB,UAAI,KAAK3M,MAAL,GAAc2M,KAAKvR,UAAnB,GAAgC,KAAKgF,GAAL,CAAShF,UAA7C,EAAyD;AACvD,aAAK6Q,IAAL,CAAU,KAAKjM,MAAL,GAAc2M,KAAKvR,UAA7B;AACD;AACD,WAAKgF,GAAL,CAAST,GAAT,CAAagN,IAAb,EAAmB,KAAK3M,MAAxB;AACA,WAAKA,MAAL,IAAe2M,KAAKvR,UAApB;AACA,aAAOuR,KAAKvR,UAAZ;AACD;;AAED;;;;;;;oCAIgB7E,K,EAAO;AACrB,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,MAAM,IAAIsK,SAAJ,CAAc,uBAAd,CAAN;AAC/B,aAAO,KAAKrH,cAAL,CAAoBqR,aAAatU,KAAb,CAApB,CAAP;AACD;;AAED;;;;;;;wCAIoBoW,I,EAAM;AACxB,WAAKxT,YAAL,CAAkBwT,KAAKvR,UAAvB;AACA,WAAK5B,cAAL,CAAoBmT,IAApB;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;yCAIqBpW,K,EAAO;AAC1B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,MAAM,IAAIsK,SAAJ,CAAc,uBAAd,CAAN;AAC/B,WAAK7B,mBAAL,CAAyB6L,aAAatU,KAAb,CAAzB;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;oCAKgBA,K,EAAO;AACrB,WAAKyI,mBAAL,CAAyBrN,iBAAiB4E,KAAjB,CAAzB;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;6BAIS,CACR;;;wBA3NY;AACX,WAAKqW,MAAL;AACA,aAAO,KAAKxM,GAAL,CAASb,QAAT,CAAkB,CAAlB,EAAqB,KAAKS,MAA1B,CAAP;AACD;;;;;;AA2NH;;;;;;;IAKMlO,O;AACJ,mBAAY2H,MAAZ,EAAoB;AAAA;;AAClB,QAAI,EAAEA,kBAAkBlH,UAApB,CAAJ,EAAqC;AACnC,YAAM,IAAIsO,SAAJ,wBAAmCpH,MAAnC,CAAN;AACD;AACD,SAAK2G,GAAL,GAAW3G,MAAX;AACA,SAAKuG,MAAL,GAAc,CAAd;AACD;;AAED;;;;;;;;;;AAQA;;;;4BAIQ;AACN,WAAKA,MAAL,GAAc,CAAd;AACD;;AAED;;;;;;;yBAIKnF,K,EAAO;AACV,UAAI,KAAKmF,MAAL,GAAcnF,KAAd,GAAsB,KAAKuF,GAAL,CAAShF,UAAnC,EAA+C;AAC7C,cAAM,IAAIpE,UAAJ,CAAe,kCAAf,CAAN;AACD;AACD,WAAKgJ,MAAL,IAAenF,KAAf;AACD;;AAED;;;;;;+BAGW;AACT,WAAKmF,MAAL,IAAe,CAAf;AACA,aAAO,KAAKI,GAAL,CAAS,KAAKJ,MAAL,GAAc,CAAvB,CAAP;AACD;;AAED;;;;;;;iCAIa;AACX,UAAIxE,SAAS,CAAb;AAAA,UAAgBqR,QAAQ,CAAxB;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAA9B,EAA0C;AACxC,YAAM0R,WAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACA,YAAI6M,UAAU,EAAV,IAAgB,CAACC,WAAW,IAAZ,MAAsB,CAA1C,EAA6C;AAAE;AAC7C,gBAAM,IAAI9V,UAAJ,CAAe,qBAAf,CAAN;AACD;AACDwE,iBAAS,CAACA,SAAS,CAACsR,WAAW,IAAZ,KAAqBD,KAA/B,MAA0C,CAAnD,CALwC,CAKa;AACrDA,iBAAS,CAAT;AACA,aAAK7M,MAAL;AACA,YAAI,CAAC8M,WAAW,IAAZ,MAAsB,CAA1B,EAA6B,OAAOtR,MAAP;AAC9B;AACD,YAAM,IAAIxE,UAAJ,CAAe,qCAAf,CAAN;AACD;;AAED;;;;;;;gCAIY;AACV,UAAIwE,SAAS,CAAb;AAAA,UAAgBqR,QAAQ,CAAxB;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAA9B,EAA0C;AACxC,YAAM0R,WAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACA,YAAK6M,UAAU,EAAV,IAAgB,CAACC,WAAW,IAAZ,MAAsB,CAAvC,IAA6C;AAC5CD,kBAAU,EAAV,IAAgB,CAACC,WAAW,IAAZ,MAAsB,CAAtC,IAA2C,CAACA,WAAW,IAAZ,MAAsB,CADlE,IACwE;AACvED,kBAAU,EAAV,IAAgB,CAACC,WAAW,IAAZ,MAAsB,CAAtC,IAA2C,CAACA,WAAW,IAAZ,MAAsB,IAFtE,EAE6E;AAAE;AAC7E,gBAAM,IAAI9V,UAAJ,CAAe,qBAAf,CAAN;AACD;AACDwE,kBAAU,CAACsR,WAAW,IAAZ,KAAqBD,KAA/B;AACAA,iBAAS,CAAT;AACA,aAAK7M,MAAL;;AAEA,YAAI,CAAC8M,WAAW,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,cAAI,CAACA,WAAW,IAAZ,MAAsB,CAAtB,IAA2BD,QAAQ,EAAvC,EAA2C;AACzC,mBAAOrR,MAAP,CADyC,CAC3B;AACf,WAFD,MAEO;AACL,mBAAOA,SAAU,CAAC,CAAD,IAAMqR,KAAvB,CADK,CACyB;AAC/B;AACF;AACF;AACD,YAAM,IAAI7V,UAAJ,CAAe,qCAAf,CAAN;AACD;;AAED;;;;;;;;iCAKa;AAAA,sBACe,KAAK+V,UAAL,EADf;AAAA,UACHT,KADG,aACHA,KADG;AAAA,UACID,MADJ,aACIA,MADJ;;AAEX,UAAIA,SAAS,CAAT,IAAcA,SAAS,QAA3B,EAAqC;AACnC,cAAM,IAAIrV,UAAJ,CAAe,qBAAf,CAAN;AACD;AACD,aAAOqV,SAAS,WAAT,GAAuBC,KAA9B;AACD;;AAED;;;;;;;;gCAKY;AAAA,qBACgB,KAAKU,SAAL,EADhB;AAAA,UACFV,KADE,YACFA,KADE;AAAA,UACKD,MADL,YACKA,MADL;;AAEV,UAAIA,SAAS,CAAC,QAAV,IAAuBA,WAAW,CAAC,QAAZ,IAAwBC,UAAU,CAAzD,IAA+DD,SAAS,QAA5E,EAAsF;AACpF,cAAM,IAAIrV,UAAJ,CAAe,qBAAf,CAAN;AACD;AACD,aAAOqV,SAAS,WAAT,GAAuBC,KAA9B;AACD;;AAED;;;;;;;;;iCAMa;AACX,UAAIA,QAAQ,CAAZ;AAAA,UAAeD,SAAS,CAAxB;AAAA,UAA2BQ,QAAQ,CAAnC;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAAvB,IAAqCyR,SAAS,EAArD,EAAyD;AACvD,YAAMC,WAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACAsM,gBAAQ,CAACA,QAAQ,CAACQ,WAAW,IAAZ,KAAqBD,KAA9B,MAAyC,CAAjD,CAFuD,CAEJ;AACnD,YAAIA,UAAU,EAAd,EAAkB;AAChBR,mBAAS,CAACS,WAAW,IAAZ,MAAsB,CAA/B;AACD;AACDD,iBAAS,CAAT;AACA,aAAK7M,MAAL;AACA,YAAI,CAAC8M,WAAW,IAAZ,MAAsB,CAA1B,EAA6B,OAAO,EAAET,cAAF,EAAUC,YAAV,EAAP;AAC9B;;AAEDO,cAAQ,CAAR;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAA9B,EAA0C;AACxC,YAAM0R,YAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACA,YAAI6M,UAAU,EAAV,IAAgB,CAACC,YAAW,IAAZ,MAAsB,CAA1C,EAA6C;AAAE;AAC7C,gBAAM,IAAI9V,UAAJ,CAAe,qBAAf,CAAN;AACD;AACDqV,iBAAS,CAACA,SAAS,CAACS,YAAW,IAAZ,KAAqBD,KAA/B,MAA0C,CAAnD;AACAA,iBAAS,CAAT;AACA,aAAK7M,MAAL;AACA,YAAI,CAAC8M,YAAW,IAAZ,MAAsB,CAA1B,EAA6B,OAAO,EAAET,cAAF,EAAUC,YAAV,EAAP;AAC9B;AACD,YAAM,IAAItV,UAAJ,CAAe,qCAAf,CAAN;AACD;;AAED;;;;;;;;;;gCAOY;AACV,UAAIsV,QAAQ,CAAZ;AAAA,UAAeD,SAAS,CAAxB;AAAA,UAA2BQ,QAAQ,CAAnC;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAAvB,IAAqCyR,SAAS,EAArD,EAAyD;AACvD,YAAMC,WAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACAsM,gBAAQ,CAACA,QAAQ,CAACQ,WAAW,IAAZ,KAAqBD,KAA9B,MAAyC,CAAjD,CAFuD,CAEJ;AACnD,YAAIA,UAAU,EAAd,EAAkB;AAChBR,mBAAS,CAACS,WAAW,IAAZ,MAAsB,CAA/B;AACD;AACDD,iBAAS,CAAT;AACA,aAAK7M,MAAL;AACA,YAAI,CAAC8M,WAAW,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,cAAI,CAACA,WAAW,IAAZ,MAAsB,CAA1B,EAA6B;AAAE;AAC7B,gBAAID,QAAQ,EAAZ,EAAgBP,QAAQ,CAACA,QAAS,CAAC,CAAD,IAAMO,KAAhB,MAA4B,CAApC;AAChBR,sBAAU,CAAC,CAAD,IAAMpJ,KAAKiJ,GAAL,CAASW,QAAQ,EAAjB,EAAqB,CAArB,CAAhB;AACD;AACD,iBAAO,EAAER,cAAF,EAAUC,YAAV,EAAP;AACD;AACF;;AAEDO,cAAQ,CAAR;AACA,aAAO,KAAK7M,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAA9B,EAA0C;AACxC,YAAM0R,aAAW,KAAK1M,GAAL,CAAS,KAAKJ,MAAd,CAAjB;AACA;AACA;AACA,YAAI6M,UAAU,EAAV,IAAgBC,eAAa,CAA7B,IAAkCA,eAAa,IAAnD,EAAyD;AACvD,gBAAM,IAAI9V,UAAJ,CAAe,qBAAf,CAAN;AACD;AACDqV,kBAAU,CAACS,aAAW,IAAZ,KAAqBD,KAA/B;AACAA,iBAAS,CAAT;AACA,aAAK7M,MAAL;AACA,YAAI,CAAC8M,aAAW,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,cAAI,CAACA,aAAW,IAAZ,MAAsB,CAAtB,IAA2BD,QAAQ,EAAvC,EAA2C;AAAE;AAC3CR,sBAAU,CAAC,CAAD,IAAMQ,KAAhB;AACD;AACD,iBAAO,EAAER,cAAF,EAAUC,YAAV,EAAP;AACD;AACF;AACD,YAAM,IAAItV,UAAJ,CAAe,qCAAf,CAAN;AACD;;AAED;;;;;;;iCAIaoB,M,EAAQ;AACnB,UAAM6U,QAAQ,KAAKjN,MAAnB;AACA,UAAIiN,QAAQ7U,MAAR,GAAiB,KAAKgI,GAAL,CAAShF,UAA9B,EAA0C;AACxC,cAAM,IAAIpE,UAAJ,CAAe,8BAAf,CAAN;AACD;AACD,WAAKgJ,MAAL,IAAe5H,MAAf;AACA,aAAO,KAAKgI,GAAL,CAASb,QAAT,CAAkB0N,KAAlB,EAAyB,KAAKjN,MAA9B,CAAP;AACD;;AAED;;;;;;;kCAIc5H,M,EAAQ;AACpB,aAAO0S,aAAa,KAAKhQ,YAAL,CAAkB1C,MAAlB,CAAb,CAAP;AACD;;AAED;;;;;;;wCAIoB;AAClB,aAAO,KAAK0C,YAAL,CAAkB,KAAKE,UAAL,EAAlB,CAAP;AACD;;AAED;;;;;;;yCAIqB;AACnB,aAAO8P,aAAa,KAAK3M,iBAAL,EAAb,CAAP;AACD;;AAED;;;;;;;oCAIgB;AACd,aAAOvM,iBAAiB,KAAKuM,iBAAL,EAAjB,CAAP;AACD;;;wBAnOU;AACT,aAAO,KAAK6B,MAAL,KAAgB,KAAKI,GAAL,CAAShF,UAAhC;AACD;;;;;;AAoOH;;;;;;;;;;;;;;;;;;;;;;;;IAsBMrJ,U;;;AACJ,sBAAYkT,IAAZ,EAAkB;AAAA;;AAAA;;AAEhB,UAAKA,IAAL,GAAYA,IAAZ;AACA,UAAKiI,KAAL,GAAa,OAAb;AACA,UAAKC,SAAL,GAAiB3W,SAAjB;AACA,UAAKoH,KAAL,GAAa,CAAb;AACA,UAAKwP,OAAL,GAAe,EAAf;AANgB;AAOjB;;AAED;;;;;;;;gCAIY7W,K,EAAwB;AAAA,UAAjB8W,WAAiB,uEAAH,CAAG;;AAClC,WAAKC,YAAL,CAAkB/W,KAAlB,EAAyB8W,WAAzB;AACD;;AAED;;;;;;iCAGa9W,K,EAAwB;AAAA,UAAjB8W,WAAiB,uEAAH,CAAG;;AACnC,UAAIA,eAAe,CAAnB,EAAsB;AACtB,UAAI,KAAKH,KAAL,KAAe,OAAnB,EAA4B;AAC1B,aAAKA,KAAL,GAAc3W,UAAU,IAAV,GAAiB,OAAjB,GAA4B8W,gBAAgB,CAAhB,GAAoB,WAApB,GAAkC,YAA5E;AACA,aAAKF,SAAL,GAAiB5W,KAAjB;AACA,aAAKqH,KAAL,GAAayP,WAAb;AACD,OAJD,MAIO,IAAI,KAAKH,KAAL,KAAe,WAAnB,EAAgC;AACrC,YAAI3W,UAAU,IAAd,EAAoB;AAClB,eAAKgX,KAAL;AACA,eAAKL,KAAL,GAAa,OAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACD,SAJD,MAIO,IAAI9W,UAAU,KAAK4W,SAAnB,EAA8B;AACnC,eAAKD,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAa,IAAIyP,WAAjB;AACD,SAHM,MAGA,IAAIA,cAAc,CAAlB,EAAqB;AAC1B,eAAKE,KAAL;AACA,eAAKL,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACA,eAAKF,SAAL,GAAiB5W,KAAjB;AACD,SALM,MAKA;AACL,eAAK2W,KAAL,GAAa,SAAb;AACA,eAAKE,OAAL,GAAe,CAAC,KAAKD,SAAN,CAAf;AACA,eAAKA,SAAL,GAAiB5W,KAAjB;AACD;AACF,OAlBM,MAkBA,IAAI,KAAK2W,KAAL,KAAe,YAAnB,EAAiC;AACtC,YAAI3W,UAAU,IAAd,EAAoB;AAClB,eAAKgX,KAAL;AACA,eAAKL,KAAL,GAAa,OAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACD,SAJD,MAIO,IAAI9W,UAAU,KAAK4W,SAAnB,EAA8B;AACnC,eAAKvP,KAAL,IAAcyP,WAAd;AACD,SAFM,MAEA,IAAIA,cAAc,CAAlB,EAAqB;AAC1B,eAAKE,KAAL;AACA,eAAKL,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACA,eAAKF,SAAL,GAAiB5W,KAAjB;AACD,SALM,MAKA;AACL,eAAKgX,KAAL;AACA,eAAKL,KAAL,GAAa,WAAb;AACA,eAAKC,SAAL,GAAiB5W,KAAjB;AACD;AACF,OAjBM,MAiBA,IAAI,KAAK2W,KAAL,KAAe,SAAnB,EAA8B;AACnC,YAAI3W,UAAU,IAAd,EAAoB;AAClB,eAAK6W,OAAL,CAAatV,IAAb,CAAkB,KAAKqV,SAAvB;AACA,eAAKI,KAAL;AACA,eAAKL,KAAL,GAAa,OAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACD,SALD,MAKO,IAAI9W,UAAU,KAAK4W,SAAnB,EAA8B;AACnC,eAAKI,KAAL;AACA,eAAKL,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAa,IAAIyP,WAAjB;AACD,SAJM,MAIA,IAAIA,cAAc,CAAlB,EAAqB;AAC1B,eAAKD,OAAL,CAAatV,IAAb,CAAkB,KAAKqV,SAAvB;AACA,eAAKI,KAAL;AACA,eAAKL,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACA,eAAKF,SAAL,GAAiB5W,KAAjB;AACD,SANM,MAMA;AACL,eAAK6W,OAAL,CAAatV,IAAb,CAAkB,KAAKqV,SAAvB;AACA,eAAKA,SAAL,GAAiB5W,KAAjB;AACD;AACF,OApBM,MAoBA,IAAI,KAAK2W,KAAL,KAAe,OAAnB,EAA4B;AACjC,YAAI3W,UAAU,IAAd,EAAoB;AAClB,eAAKqH,KAAL,IAAcyP,WAAd;AACD,SAFD,MAEO,IAAIA,cAAc,CAAlB,EAAqB;AAC1B,eAAKE,KAAL;AACA,eAAKL,KAAL,GAAa,YAAb;AACA,eAAKtP,KAAL,GAAayP,WAAb;AACA,eAAKF,SAAL,GAAiB5W,KAAjB;AACD,SALM,MAKA;AACL,eAAKgX,KAAL;AACA,eAAKL,KAAL,GAAa,WAAb;AACA,eAAKC,SAAL,GAAiB5W,KAAjB;AACD;AACF;AACF;;AAED;;;;;;;;;;;;6BASSoF,O,EAAuB;AAAA,UAAdkM,OAAc,uEAAJ,EAAI;AAAA,UACtBjK,KADsB,GACsBiK,OADtB,CACtBjK,KADsB;AAAA,UACfkK,WADe,GACsBD,OADtB,CACfC,WADe;AAAA,UACFJ,SADE,GACsBG,OADtB,CACFH,SADE;AAAA,UACSC,QADT,GACsBE,OADtB,CACSF,QADT;;AAE9B,UAAI,EAAEhM,mBAAmB3J,UAArB,KAAqC2J,QAAQsJ,IAAR,KAAiB,KAAKA,IAA/D,EAAsE;AACpE,cAAM,IAAIpE,SAAJ,CAAc,8BAAd,CAAN;AACD;AACD,UAAI2M,YAAa,OAAO5P,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCjE,OAAOE,gBAA5D;AAAA,UAA+E4T,MAAM,CAArF;AACA,UAAI7P,SAAS4P,YAAY,CAArB,IAA0B7R,QAAQ4B,IAAtC,EAA4C,MAAM,IAAIvG,UAAJ,kBAA8B4G,KAA9B,aAAN;AAC5C,UAAI4P,cAAc,CAAd,IAAmB7R,QAAQ4B,IAA/B,EAAqC,OAAOkQ,GAAP;;AAErC;AACA,UAAMC,aAAa/R,QAAQhB,SAAR,EAAnB;AACA,WAAKlC,WAAL,CAAkBqP,eAAe4F,eAAe,IAA/B,GAAuC5F,YAAY4F,UAAZ,CAAvC,GAAiEA,UAAlF;AACAF;AACA,UAAI9F,SAAJ,EAAe+F,OAAOC,gBAAgB/F,YAAY,CAA5B,CAAP;AACf,UAAI/J,SAAS4P,YAAY,CAArB,IAA0B7R,QAAQ4B,IAAtC,EAA4C,MAAM,IAAIvG,UAAJ,kBAA8B4G,KAA9B,aAAN;AAC5C,UAAI4P,cAAc,CAAd,IAAmB7R,QAAQ4B,IAA/B,EAAqC,OAAOkQ,GAAP;;AAErC;AACA,UAAInM,oBAAJ;AAAA,UAAiBqM,kBAAjB;AAAA,UAA4B/G,aAAa,CAACkB,WAAD,IAAgB,CAACJ,SAA1D;AAAA,UAAqEkG,WAAW,IAAhF;AACA,aAAOJ,YAAY,CAAZ,IAAiB,CAAC7R,QAAQ4B,IAAjC,EAAuC;AACrCoQ,oBAAYhS,QAAQqE,MAApB;AACA,YAAI4N,YAAYjS,QAAQiC,KAAR,KAAkB,CAAlC,EAAqC;AACnCgQ,qBAAW,KAAX;AACAtM,wBAAc3F,QAAQqE,MAAtB;AACD;AACD,YAAI,CAAC4N,QAAL,EAAejS,QAAQkS,UAAR;;AAEf,YAAMC,YAAY7K,KAAK8K,GAAL,CAASpS,QAAQiC,KAAjB,EAAwB4P,SAAxB,CAAlB;AACA7R,gBAAQiC,KAAR,IAAiBkQ,SAAjB;;AAEA,YAAInS,QAAQuR,KAAR,KAAkB,SAAtB,EAAiC;AAC/B,cAAItG,cAAc,CAACgH,QAAnB,EAA6B;AAC3BjS,oBAAQqS,aAAR,CAAsBF,SAAtB;AACD,WAFD,MAEO;AACL,iBAAK,IAAI3V,IAAI,CAAb,EAAgBA,IAAI2V,SAApB,EAA+B3V,GAA/B,EAAoC;AAClC,kBAAIwD,QAAQ4B,IAAZ,EAAkB,MAAM,IAAIvG,UAAJ,CAAe,oBAAf,CAAN;AAClB,kBAAMT,QAAQoF,QAAQsS,YAAR,EAAd;AACA,kBAAI1X,UAAUoF,QAAQwR,SAAtB,EAAiC,MAAM,IAAInW,UAAJ,CAAe,gDAAf,CAAN;AACjC2E,sBAAQwR,SAAR,GAAoB5W,KAApB;AACA,mBAAK+W,YAAL,CAAmBxF,eAAevR,UAAU,IAA1B,GAAkCuR,YAAYvR,KAAZ,CAAlC,GAAuDA,KAAzE;AACA,kBAAImR,SAAJ,EAAe+F,OAAOlX,WAAWoR,YAAY,CAAvB,CAAP;AAChB;AACF;AACF,SAbD,MAaO,IAAIhM,QAAQuR,KAAR,KAAkB,YAAtB,EAAoC;AACzC,cAAIxF,SAAJ,EAAe+F,OAAQK,YAAYnS,QAAQwR,SAArB,MAAqCxF,YAAY,CAAjD,CAAP;AACf,cAAI,CAACf,UAAD,IAAegH,QAAnB,EAA6B;AAC3B,gBAAMM,cAAepG,eAAenM,QAAQwR,SAAR,KAAsB,IAAtC,GAA8CrF,YAAYnM,QAAQwR,SAApB,CAA9C,GAA+ExR,QAAQwR,SAA3G;AACA,iBAAKG,YAAL,CAAkBY,WAAlB;AACA,gBAAIJ,YAAY,CAAhB,EAAmB;AACjB,mBAAKR,YAAL,CAAkBY,WAAlB;AACA,kBAAI,KAAKhB,KAAL,KAAe,YAAnB,EAAiC,MAAM,IAAIlW,UAAJ,uBAAmC,KAAKkW,KAAxC,CAAN;AACjC,mBAAKtP,KAAL,IAAckQ,YAAY,CAA1B;AACD;AACF;AACF,SAXM,MAWA,IAAInS,QAAQuR,KAAR,KAAkB,OAAtB,EAA+B;AACpC,cAAI,CAACtG,UAAD,IAAegH,QAAnB,EAA6B;AAC3B,iBAAKN,YAAL,CAAkB,IAAlB;AACA,gBAAI,KAAKJ,KAAL,KAAe,OAAnB,EAA4B,MAAM,IAAIlW,UAAJ,uBAAmC,KAAKkW,KAAxC,CAAN;AAC5B,iBAAKtP,KAAL,IAAckQ,YAAY,CAA1B;AACD;AACF;;AAED,YAAIF,QAAJ,EAAc;AACZA,qBAAW,KAAX;AACAtM,wBAAc3F,QAAQqE,MAAtB;AACAwN,uBAAaM,SAAb;AACD,SAJD,MAIO,IAAI,CAACnS,QAAQ4B,IAAR,IAAgBiQ,cAAcM,SAA/B,KAA6ClH,UAAjD,EAA6D;AAClE;AACA;AACAA,uBAAa,KAAb;AACAjL,kBAAQqE,MAAR,GAAiB2N,SAAjB;AACAhS,kBAAQuR,KAAR,GAAgB1W,SAAhB;AACA,cAAI,KAAK0W,KAAL,KAAe,SAAnB,EAA8B,KAAKE,OAAL,CAAatV,IAAb,CAAkB,KAAKqV,SAAvB;AAC9B,eAAKI,KAAL;AACA,cAAIjM,cAAcqM,SAAlB,EAA6B;AAC3B,iBAAKnU,cAAL,CAAoBmC,QAAQyE,GAAR,CAAYb,QAAZ,CAAqB+B,WAArB,EAAkCqM,SAAlC,CAApB;AACD;AACF,SAXM,MAWA;AACLH,uBAAaM,SAAb;AACD;AACF;AACD,UAAIlQ,SAAS4P,YAAY,CAArB,IAA0B7R,QAAQ4B,IAAtC,EAA4C,MAAM,IAAIvG,UAAJ,kBAA8B4G,KAA9B,aAAN;AAC5C,UAAI8J,SAAJ,EAAe,OAAO+F,GAAP;AAChB;;AAED;;;;;;4BAGQ;AACN,UAAI,KAAKP,KAAL,KAAe,WAAnB,EAAgC;AAC9B,aAAKR,WAAL,CAAiB,CAAC,CAAlB;AACA,aAAKyB,cAAL,CAAoB,KAAKhB,SAAzB;AACD,OAHD,MAGO,IAAI,KAAKD,KAAL,KAAe,YAAnB,EAAiC;AACtC,aAAKhU,WAAL,CAAiB,KAAK0E,KAAtB;AACA,aAAKuQ,cAAL,CAAoB,KAAKhB,SAAzB;AACD,OAHM,MAGA,IAAI,KAAKD,KAAL,KAAe,SAAnB,EAA8B;AACnC,aAAKhU,WAAL,CAAiB,CAAC,KAAKkU,OAAL,CAAahV,MAA/B;AADmC;AAAA;AAAA;;AAAA;AAEnC,gCAAc,KAAKgV,OAAnB;AAAA,gBAASvX,CAAT;AAA4B,iBAAKsY,cAAL,CAAoBtY,CAApB;AAA5B;AAFmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGpC,OAHM,MAGA,IAAI,KAAKqX,KAAL,KAAe,OAAnB,EAA4B;AACjC,aAAKR,WAAL,CAAiB,CAAjB;AACA,aAAKvT,YAAL,CAAkB,KAAKyE,KAAvB;AACD;AACD,WAAKsP,KAAL,GAAa,OAAb;AACD;;AAED;;;;;;mCAGe3W,K,EAAO;AACpB,UAAI,KAAK0O,IAAL,KAAc,KAAlB,EAAyB;AACvB,aAAK/L,WAAL,CAAiB3C,KAAjB;AACD,OAFD,MAEO,IAAI,KAAK0O,IAAL,KAAc,MAAlB,EAA0B;AAC/B,aAAK9L,YAAL,CAAkB5C,KAAlB;AACD,OAFM,MAEA,IAAI,KAAK0O,IAAL,KAAc,MAAlB,EAA0B;AAC/B,aAAKxE,oBAAL,CAA0BlK,KAA1B;AACD,OAFM,MAEA;AACL,cAAM,IAAIS,UAAJ,mCAA+C,KAAKiO,IAApD,CAAN;AACD;AACF;;AAED;;;;;;;6BAIS;AACP,UAAI,KAAKiI,KAAL,KAAe,SAAnB,EAA8B,KAAKE,OAAL,CAAatV,IAAb,CAAkB,KAAKqV,SAAvB;AAC9B;AACA,UAAI,KAAKD,KAAL,KAAe,OAAf,IAA0B,KAAKlN,MAAL,GAAc,CAA5C,EAA+C,KAAKuN,KAAL;AAChD;;;;EA3OsB1b,O;;AA8OzB;;;;;;IAIMG,U;;;AACJ,sBAAYiT,IAAZ,EAAkBxL,MAAlB,EAA0B;AAAA;;AAAA,yHAClBA,MADkB;;AAExB,WAAKwL,IAAL,GAAYA,IAAZ;AACA,WAAKkI,SAAL,GAAiB3W,SAAjB;AACA,WAAKoH,KAAL,GAAa,CAAb;AACA,WAAKsP,KAAL,GAAa1W,SAAb;AALwB;AAMzB;;AAED;;;;;;;;;;AAQA;;;;4BAIQ;AACN,WAAKwJ,MAAL,GAAc,CAAd;AACA,WAAKmN,SAAL,GAAiB3W,SAAjB;AACA,WAAKoH,KAAL,GAAa,CAAb;AACA,WAAKsP,KAAL,GAAa1W,SAAb;AACD;;AAED;;;;;;gCAGY;AACV,UAAI,KAAK+G,IAAT,EAAe,OAAO,IAAP;AACf,UAAI,KAAKK,KAAL,KAAe,CAAnB,EAAsB,KAAKiQ,UAAL;AACtB,WAAKjQ,KAAL,IAAc,CAAd;AACA,UAAI,KAAKsP,KAAL,KAAe,SAAnB,EAA8B;AAC5B,YAAM3W,QAAQ,KAAK0X,YAAL,EAAd;AACA,YAAI1X,UAAU,KAAK4W,SAAnB,EAA8B,MAAM,IAAInW,UAAJ,CAAe,gDAAf,CAAN;AAC9B,aAAKmW,SAAL,GAAiB5W,KAAjB;AACA,eAAOA,KAAP;AACD,OALD,MAKO;AACL,eAAO,KAAK4W,SAAZ;AACD;AACF;;AAED;;;;;;+BAGWiB,O,EAAS;AAClB,aAAOA,UAAU,CAAV,IAAe,CAAC,KAAK7Q,IAA5B,EAAkC;AAChC,YAAI,KAAKK,KAAL,KAAe,CAAnB,EAAsB;AACpB,eAAKA,KAAL,GAAa,KAAK3C,SAAL,EAAb;AACA,cAAI,KAAK2C,KAAL,GAAa,CAAjB,EAAoB;AAClB,iBAAKuP,SAAL,GAAkB,KAAKvP,KAAL,IAAcwQ,OAAf,GAA0B,KAAKJ,aAAL,CAAmB,CAAnB,CAA1B,GAAkD,KAAKC,YAAL,EAAnE;AACA,iBAAKf,KAAL,GAAa,YAAb;AACD,WAHD,MAGO,IAAI,KAAKtP,KAAL,GAAa,CAAjB,EAAoB;AACzB,iBAAKA,KAAL,GAAa,CAAC,KAAKA,KAAnB;AACA,iBAAKsP,KAAL,GAAa,SAAb;AACD,WAHM,MAGA;AAAE;AACP,iBAAKtP,KAAL,GAAa,KAAK5C,UAAL,EAAb;AACA,iBAAKmS,SAAL,GAAiB,IAAjB;AACA,iBAAKD,KAAL,GAAa,OAAb;AACD;AACF;;AAED,YAAMmB,UAAUpL,KAAK8K,GAAL,CAASK,OAAT,EAAkB,KAAKxQ,KAAvB,CAAhB;AACA,YAAI,KAAKsP,KAAL,KAAe,SAAnB,EAA8B,KAAKc,aAAL,CAAmBK,OAAnB;AAC9BD,mBAAWC,OAAX;AACA,aAAKzQ,KAAL,IAAcyQ,OAAd;AACD;AACF;;AAED;;;;;;;iCAIa;AACX,WAAKzQ,KAAL,GAAa,KAAK3C,SAAL,EAAb;AACA,UAAI,KAAK2C,KAAL,GAAa,CAAjB,EAAoB;AAClB,YAAMrH,QAAQ,KAAK0X,YAAL,EAAd;AACA,YAAI,CAAC,KAAKf,KAAL,KAAe,YAAf,IAA+B,KAAKA,KAAL,KAAe,SAA/C,KAA6D,KAAKC,SAAL,KAAmB5W,KAApF,EAA2F;AACzF,gBAAM,IAAIS,UAAJ,CAAe,4DAAf,CAAN;AACD;AACD,aAAKkW,KAAL,GAAa,YAAb;AACA,aAAKC,SAAL,GAAiB5W,KAAjB;AACD,OAPD,MAOO,IAAI,KAAKqH,KAAL,KAAe,CAAnB,EAAsB;AAC3B,cAAM,IAAI5G,UAAJ,CAAe,6DAAf,CAAN;AACD,OAFM,MAEA,IAAI,KAAK4G,KAAL,GAAa,CAAjB,EAAoB;AACzB,aAAKA,KAAL,GAAa,CAAC,KAAKA,KAAnB;AACA,YAAI,KAAKsP,KAAL,KAAe,SAAnB,EAA8B,MAAM,IAAIlW,UAAJ,CAAe,qCAAf,CAAN;AAC9B,aAAKkW,KAAL,GAAa,SAAb;AACD,OAJM,MAIA;AAAE;AACP,YAAI,KAAKA,KAAL,KAAe,OAAnB,EAA4B,MAAM,IAAIlW,UAAJ,CAAe,sCAAf,CAAN;AAC5B,aAAK4G,KAAL,GAAa,KAAK5C,UAAL,EAAb;AACA,YAAI,KAAK4C,KAAL,KAAe,CAAnB,EAAsB,MAAM,IAAI5G,UAAJ,CAAe,uCAAf,CAAN;AACtB,aAAKmW,SAAL,GAAiB,IAAjB;AACA,aAAKD,KAAL,GAAa,OAAb;AACD;AACF;;AAED;;;;;;;mCAIe;AACb,UAAI,KAAKjI,IAAL,KAAc,KAAlB,EAAyB;AACvB,eAAO,KAAKhK,SAAL,EAAP;AACD,OAFD,MAEO,IAAI,KAAKgK,IAAL,KAAc,MAAlB,EAA0B;AAC/B,eAAO,KAAKjK,UAAL,EAAP;AACD,OAFM,MAEA,IAAI,KAAKiK,IAAL,KAAc,MAAlB,EAA0B;AAC/B,eAAO,KAAK3G,kBAAL,EAAP;AACD,OAFM,MAEA;AACL,cAAM,IAAItH,UAAJ,mCAA+C,KAAKiO,IAApD,CAAN;AACD;AACF;;AAED;;;;;;;kCAIcqJ,G,EAAK;AACjB,UAAI,KAAKrJ,IAAL,KAAc,MAAlB,EAA0B;AACxB,aAAK,IAAI9M,IAAI,CAAb,EAAgBA,IAAImW,GAApB,EAAyBnW,GAAzB;AAA8B,eAAKoW,IAAL,CAAU,KAAKvT,UAAL,EAAV;AAA9B;AACD,OAFD,MAEO;AACL,eAAOsT,MAAM,CAAN,IAAW,KAAKtO,MAAL,GAAc,KAAKI,GAAL,CAAShF,UAAzC,EAAqD;AACnD,cAAI,CAAC,KAAKgF,GAAL,CAAS,KAAKJ,MAAd,IAAwB,IAAzB,MAAmC,CAAvC,EAA0CsO;AAC1C,eAAKtO,MAAL;AACD;AACD,YAAIsO,MAAM,CAAV,EAAa,MAAM,IAAItX,UAAJ,CAAe,kCAAf,CAAN;AACd;AACF;;;wBArHU;AACT,aAAQ,KAAK4G,KAAL,KAAe,CAAhB,IAAuB,KAAKoC,MAAL,KAAgB,KAAKI,GAAL,CAAShF,UAAvD;AACD;;;;EAfsBtJ,O;;AAqIzB;;;;;;;;;;;;IAUMG,Y;;;AACJ,0BAAc;AAAA;;AAAA,6HACN,KADM;;AAEZ,WAAKuc,aAAL,GAAqB,CAArB;AAFY;AAGb;;AAED;;;;;;;;gCAIYjY,K,EAAwB;AAAA,UAAjB8W,WAAiB,uEAAH,CAAG;;AAClC,UAAIA,eAAe,CAAnB,EAAsB;AACtB,UAAI,OAAO9W,KAAP,KAAiB,QAArB,EAA+B;AAC7B,gIAAkBA,QAAQ,KAAKiY,aAA/B,EAA8C,CAA9C;AACA,aAAKA,aAAL,GAAqBjY,KAArB;AACA,YAAI8W,cAAc,CAAlB,EAAqB,wHAAkB,CAAlB,EAAqBA,cAAc,CAAnC;AACtB,OAJD,MAIO;AACL,gIAAkB9W,KAAlB,EAAyB8W,WAAzB;AACD;AACF;;AAED;;;;;;;;6BAKS1R,O,EAAuB;AAAA,UAAdkM,OAAc,uEAAJ,EAAI;;AAC9B,UAAIA,QAAQC,WAAR,IAAuBD,QAAQH,SAAnC,EAA8C;AAC5C,cAAM,IAAI1Q,UAAJ,CAAe,iDAAf,CAAN;AACD;AACD,UAAI,EAAE2E,mBAAmBzJ,YAArB,CAAJ,EAAwC;AACtC,cAAM,IAAI2O,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAED,UAAIgH,QAAQjK,KAAR,GAAgB,CAAhB,IAAqBjC,QAAQ4B,IAAjC,EAAuC,MAAM,IAAIvG,UAAJ,kBAA8B6Q,QAAQjK,KAAtC,aAAN;AACvC,UAAIiK,QAAQjK,KAAR,KAAkB,CAAlB,IAAuBjC,QAAQ4B,IAAnC,EAAyC;;AAEzC;AACA;AACA,UAAIhH,QAAQoF,QAAQhB,SAAR,EAAZ;AAAA,UAAiC8T,QAAQ,CAAzC;AACA,WAAKhW,WAAL,CAAiBlC,KAAjB;AACA,UAAIA,UAAU,IAAd,EAAoB;AAClBkY,gBAAQ9S,QAAQiC,KAAR,GAAgB,CAAxB;AACA,YAAIiK,QAAQjK,KAAR,IAAiBiK,QAAQjK,KAAR,GAAgB6Q,KAArC,EAA4CA,QAAQ5G,QAAQjK,KAAhB;AAC5CjC,gBAAQiC,KAAR,IAAiB6Q,QAAQ,CAAzB;AACA,aAAK7Q,KAAL,IAAc6Q,QAAQ,CAAtB;AACA,YAAI5G,QAAQjK,KAAR,GAAgB6Q,KAAhB,IAAyB9S,QAAQ4B,IAArC,EAA2C,MAAM,IAAIvG,UAAJ,kBAA8B6Q,QAAQjK,KAAtC,aAAN;AAC3C,YAAIiK,QAAQjK,KAAR,KAAkB6Q,KAAlB,IAA2B9S,QAAQ4B,IAAvC,EAA6C;;AAE7C;AACA;AACA,YAAI5B,QAAQiC,KAAR,KAAkB,CAAtB,EAAyB,KAAKnF,WAAL,CAAiBkD,QAAQhB,SAAR,EAAjB;AAC1B;;AAED;AACA;AACA,UAAIkN,QAAQjK,KAAZ,EAAmBiK,QAAQjK,KAAR,IAAiB6Q,QAAQ,CAAzB;AACnB,2HAAe9S,OAAf,EAAwBkM,OAAxB;AACD;;;;EA1DwB9V,U;;AA6D3B;;;;;;IAIMG,Y;;;AACJ,wBAAYuH,MAAZ,EAAoB;AAAA;;AAAA,6HACZ,KADY,EACLA,MADK;;AAElB,WAAK+U,aAAL,GAAqB,CAArB;AAFkB;AAGnB;;AAED;;;;;;;;4BAIQ;AACN,WAAKxO,MAAL,GAAc,CAAd;AACA,WAAKmN,SAAL,GAAiB3W,SAAjB;AACA,WAAKoH,KAAL,GAAa,CAAb;AACA,WAAKsP,KAAL,GAAa1W,SAAb;AACA,WAAKgY,aAAL,GAAqB,CAArB;AACD;;AAED;;;;;;gCAGY;AACV,UAAMjY,6HAAN;AACA,UAAIA,UAAU,IAAd,EAAoB,OAAO,IAAP;AACpB,WAAKiY,aAAL,IAAsBjY,KAAtB;AACA,aAAO,KAAKiY,aAAZ;AACD;;AAED;;;;;;+BAGWJ,O,EAAS;AAClB,aAAOA,UAAU,CAAV,IAAe,CAAC,KAAK7Q,IAA5B,EAAkC;AAChC,YAAI,KAAKK,KAAL,KAAe,CAAnB,EAAsB,KAAKiQ,UAAL;AACtB,YAAMQ,UAAUpL,KAAK8K,GAAL,CAASK,OAAT,EAAkB,KAAKxQ,KAAvB,CAAhB;AACA,YAAI,KAAKsP,KAAL,KAAe,SAAnB,EAA8B;AAC5B,eAAK,IAAI/U,IAAI,CAAb,EAAgBA,IAAIkW,OAApB,EAA6BlW,GAA7B,EAAkC;AAChC,iBAAKgV,SAAL,GAAiB,KAAKc,YAAL,EAAjB;AACA,iBAAKO,aAAL,IAAsB,KAAKrB,SAA3B;AACD;AACF,SALD,MAKO,IAAI,KAAKD,KAAL,KAAe,YAAnB,EAAiC;AACtC,eAAKsB,aAAL,IAAsBH,UAAU,KAAKlB,SAArC;AACD;AACDiB,mBAAWC,OAAX;AACA,aAAKzQ,KAAL,IAAcyQ,OAAd;AACD;AACF;;;;EA9CwBrc,U;;AAiD3B;;;;;;;;;;IAQMG,c;;;AACJ,4BAAc;AAAA;;AAAA;;AAEZ,WAAKgb,SAAL,GAAiB,KAAjB;AACA,WAAKvP,KAAL,GAAa,CAAb;AAHY;AAIb;;AAED;;;;;;;;gCAIYrH,K,EAAwB;AAAA,UAAjB8W,WAAiB,uEAAH,CAAG;;AAClC,UAAI9W,UAAU,KAAV,IAAmBA,UAAU,IAAjC,EAAuC;AACrC,cAAM,IAAIS,UAAJ,4CAAwDT,KAAxD,CAAN;AACD;AACD,UAAI8W,eAAe,CAAnB,EAAsB;AACtB,UAAI,KAAKF,SAAL,KAAmB5W,KAAvB,EAA8B;AAC5B,aAAKqH,KAAL,IAAcyP,WAAd;AACD,OAFD,MAEO;AACL,aAAKlU,YAAL,CAAkB,KAAKyE,KAAvB;AACA,aAAKuP,SAAL,GAAiB5W,KAAjB;AACA,aAAKqH,KAAL,GAAayP,WAAb;AACD;AACF;;AAED;;;;;;;;6BAKS1R,O,EAAuB;AAAA,UAAdkM,OAAc,uEAAJ,EAAI;;AAC9B,UAAI,EAAElM,mBAAmBvJ,cAArB,CAAJ,EAA0C;AACxC,cAAM,IAAIyO,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAH6B,UAKtBjD,KALsB,GAKZiK,OALY,CAKtBjK,KALsB;;AAM9B,UAAI4P,YAAa,OAAO5P,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCjE,OAAOE,gBAA5D;AACA,UAAI+D,SAAS4P,YAAY,CAArB,IAA0B7R,QAAQ4B,IAAtC,EAA4C,MAAM,IAAIvG,UAAJ,kBAA8B4G,KAA9B,aAAN;AAC5C,UAAI4P,cAAc,CAAd,IAAmB7R,QAAQ4B,IAA/B,EAAqC;;AAErC;AACA,WAAK9E,WAAL,CAAiBkD,QAAQhB,SAAR,EAAjB;AACA6S;AACA,UAAMkB,YAAYzL,KAAK8K,GAAL,CAASpS,QAAQiC,KAAjB,EAAwB4P,SAAxB,CAAlB;AACA,WAAK5P,KAAL,IAAc8Q,SAAd;AACA/S,cAAQiC,KAAR,IAAiB8Q,SAAjB;AACAlB,mBAAakB,SAAb;;AAEA,aAAOlB,YAAY,CAAZ,IAAiB,CAAC7R,QAAQ4B,IAAjC,EAAuC;AACrC5B,gBAAQiC,KAAR,GAAgBjC,QAAQX,UAAR,EAAhB;AACA,YAAIW,QAAQiC,KAAR,KAAkB,CAAtB,EAAyB,MAAM,IAAI5G,UAAJ,CAAe,kCAAf,CAAN;AACzB2E,gBAAQwR,SAAR,GAAoB,CAACxR,QAAQwR,SAA7B;AACA,aAAKhU,YAAL,CAAkB,KAAKyE,KAAvB;;AAEA,YAAM+Q,YAAY1L,KAAK8K,GAAL,CAASpS,QAAQiC,KAAjB,EAAwB4P,SAAxB,CAAlB;AACA,aAAK5P,KAAL,GAAa+Q,SAAb;AACA,aAAKxB,SAAL,GAAiBxR,QAAQwR,SAAzB;AACAxR,gBAAQiC,KAAR,IAAiB+Q,SAAjB;AACAnB,qBAAamB,SAAb;AACD;;AAED,UAAI/Q,SAAS4P,YAAY,CAArB,IAA0B7R,QAAQ4B,IAAtC,EAA4C,MAAM,IAAIvG,UAAJ,kBAA8B4G,KAA9B,aAAN;AAC7C;;AAED;;;;;;;6BAIS;AACP,UAAI,KAAKA,KAAL,GAAa,CAAjB,EAAoB;AAClB,aAAKzE,YAAL,CAAkB,KAAKyE,KAAvB;AACA,aAAKA,KAAL,GAAa,CAAb;AACD;AACF;;;;EAzE0B/L,O;;AA4E7B;;;;;;IAIMO,c;;;AACJ,0BAAYqH,MAAZ,EAAoB;AAAA;;AAAA,iIACZA,MADY;;AAElB,WAAK0T,SAAL,GAAiB,IAAjB,CAFkB,CAEI;AACtB,WAAKS,QAAL,GAAgB,IAAhB;AACA,WAAKhQ,KAAL,GAAa,CAAb;AAJkB;AAKnB;;AAED;;;;;;;;;;AAQA;;;;4BAIQ;AACN,WAAKoC,MAAL,GAAc,CAAd;AACA,WAAKmN,SAAL,GAAiB,IAAjB;AACA,WAAKS,QAAL,GAAgB,IAAhB;AACA,WAAKhQ,KAAL,GAAa,CAAb;AACD;;AAED;;;;;;gCAGY;AACV,UAAI,KAAKL,IAAT,EAAe,OAAO,KAAP;AACf,aAAO,KAAKK,KAAL,KAAe,CAAtB,EAAyB;AACvB,aAAKA,KAAL,GAAa,KAAK5C,UAAL,EAAb;AACA,aAAKmS,SAAL,GAAiB,CAAC,KAAKA,SAAvB;AACA,YAAI,KAAKvP,KAAL,KAAe,CAAf,IAAoB,CAAC,KAAKgQ,QAA9B,EAAwC;AACtC,gBAAM,IAAI5W,UAAJ,CAAe,kCAAf,CAAN;AACD;AACD,aAAK4W,QAAL,GAAgB,KAAhB;AACD;AACD,WAAKhQ,KAAL,IAAc,CAAd;AACA,aAAO,KAAKuP,SAAZ;AACD;;AAED;;;;;;+BAGWiB,O,EAAS;AAClB,aAAOA,UAAU,CAAV,IAAe,CAAC,KAAK7Q,IAA5B,EAAkC;AAChC,YAAI,KAAKK,KAAL,KAAe,CAAnB,EAAsB;AACpB,eAAKA,KAAL,GAAa,KAAK5C,UAAL,EAAb;AACA,eAAKmS,SAAL,GAAiB,CAAC,KAAKA,SAAvB;AACA,cAAI,KAAKvP,KAAL,KAAe,CAAnB,EAAsB,MAAM,IAAI5G,UAAJ,CAAe,kCAAf,CAAN;AACvB;AACD,YAAI,KAAK4G,KAAL,GAAawQ,OAAjB,EAA0B;AACxBA,qBAAW,KAAKxQ,KAAhB;AACA,eAAKA,KAAL,GAAa,CAAb;AACD,SAHD,MAGO;AACL,eAAKA,KAAL,IAAcwQ,OAAd;AACAA,oBAAU,CAAV;AACD;AACF;AACF;;;wBAlDU;AACT,aAAQ,KAAKxQ,KAAL,KAAe,CAAhB,IAAuB,KAAKoC,MAAL,KAAgB,KAAKI,GAAL,CAAShF,UAAvD;AACD;;;;EAd0BtJ,O;;AAiE7B6Y,OAAOC,OAAP,GAAiB;AACfjZ,oCADe,EACGC,kCADH;AAEfC,kBAFe,EAENC,gBAFM,EAEGC,sBAFH,EAEeC,sBAFf,EAE2BC,0BAF3B,EAEyCC,0BAFzC,EAEuDC,8BAFvD,EAEuEC;AAFvE,CAAjB,C;;;;;;;;;;;;;;;;;;;eCjsCsBd,mBAAOA,CAAC,6DAAR,C;IAAdsd,G,YAAAA,G;IAAKC,I,YAAAA,I;;gBACUvd,mBAAOA,CAAC,sCAAR,C;IAAfE,U,aAAAA,U;;AACR,IAAMsd,QAAQxd,mBAAOA,CAAC,qCAAR,CAAd;;gBACqBA,mBAAOA,CAAC,2CAAR,C;IAAbyd,Q,aAAAA,Q;;gBACiFzd,mBAAOA,CAAC,yCAAR,C;IAAjF8P,e,aAAAA,e;IAAiBd,Y,aAAAA,Y;IAAciB,a,aAAAA,a;IAAe0C,c,aAAAA,c;IAAgBkB,c,aAAAA,c;;AAEtE,SAAS6J,YAAT,CAAsBC,OAAtB,EAA+B;AAC7B,MAAIA,QAAQC,MAAZ,EAAoB;AAClB,UAAM,IAAIxD,KAAJ,CACJ,qFACA,gFADA,GAEA,sCAHI,CAAN;AAKD;AACD,SAAOuD,QAAQ/B,KAAf;AACD;;AAED;;;;AAIA,SAASiC,UAAT,CAAoBC,KAApB,EAA2B9X,MAA3B,EAAmC;AACjC,MAAI+X,QAAQ,EAAZ,CADiC,CAClB;AACf/X,SAAOC,GAAP,CAAW+X,OAAX,CAAmB,UAAC7X,EAAD,EAAKuL,KAAL,EAAe;AAChC,QAAMrM,OAAUW,OAAOgB,OAAP,GAAiB0K,KAA3B,SAAoC1L,OAAOvB,KAAjD;AACA,QAAM4B,MAAMF,GAAGjD,MAAH,GAAYmC,IAAZ,GAAmBc,GAAGE,GAAlC;;AAEA,QAAI0X,MAAM5X,GAAGC,GAAT,KAAiB2X,MAAM5X,GAAGC,GAAT,EAAcC,GAAd,CAArB,EAAyC;AACvCF,SAAGI,IAAH,GAAU,CAACwX,MAAM5X,GAAGC,GAAT,EAAcC,GAAd,CAAD,CAAV;AACD,KAFD,MAEO;AACL,UAAM4X,WAAWT,MAAMU,WAAN,CAAkBJ,KAAlB,EAAyB3X,GAAGC,GAA5B,EAAiCC,GAAjC,CAAjB;AACAF,SAAGI,IAAH,GAAU0X,SAAS/X,GAAT,CAAa;AAAA,eAAWiY,QAAQC,GAAR,CAAY,MAAZ,CAAX;AAAA,OAAb,EAA6CC,IAA7C,EAAV;AACD;;AAED,QAAI,CAACN,MAAM5X,GAAGC,GAAT,CAAL,EAAoB2X,MAAM5X,GAAGC,GAAT,IAAgB,EAAhB;AACpB,QAAI,CAAC2X,MAAM5X,GAAGC,GAAT,EAAcC,GAAd,CAAL,EAAyB0X,MAAM5X,GAAGC,GAAT,EAAcC,GAAd,IAAqBhB,IAArB;AAC1B,GAbD;AAcD;;AAED;;;;;;;;AAQA,SAASiZ,oBAAT,CAA8B1C,KAA9B,EAAqCkC,KAArC,EAA4CS,OAA5C,EAAqDvX,OAArD,EAA8D;AAAA,MACpDvC,KADoD,GAChB8Z,OADgB,CACpD9Z,KADoD;AAAA,MAC7CC,GAD6C,GAChB6Z,OADgB,CAC7C7Z,GAD6C;AAAA,MACxCuI,IADwC,GAChBsR,OADgB,CACxCtR,IADwC;AAAA,MAClCrI,IADkC,GAChB2Z,OADgB,CAClC3Z,IADkC;AAAA,MAC5BC,OAD4B,GAChB0Z,OADgB,CAC5B1Z,OAD4B;;AAE5D,MAAMmB,SAAS,EAAEvB,YAAF,EAASC,QAAT,EAAcsC,gBAAd,EAAuBiG,UAAvB,EAA6BrI,UAA7B,EAAmCC,gBAAnC,EAA4CoB,KAAK,EAAjD,EAAf;;AAEA,MAAIuY,YAAY5C,MAAMwC,GAAN,CAAU,WAAV,CAAhB;AAAA,MAAwCK,cAAc,EAAtD;AAAA,MAA0DC,UAAU,EAApE;AAAA,MAAwEC,cAAc,EAAtF;AAJ4D;AAAA;AAAA;;AAAA;AAK5D,yBAAeJ,QAAQtY,GAAvB,8HAA4B;AAAA,UAAnBE,EAAmB;;AAC1B,UAAMd,OAAU2B,UAAUhB,OAAOC,GAAP,CAAWa,MAA/B,SAAyCrC,KAA/C;AACA0B,WAAKjG,WAAWiG,EAAX,CAAL;;AAEA,UAAIqY,UAAUI,GAAV,CAAczY,GAAGC,GAAjB,CAAJ,EAA2B;AACzBD,WAAGC,GAAH,GAASoY,UAAUJ,GAAV,CAAcjY,GAAGC,GAAjB,CAAT;AACD;AACD,UAAID,GAAGhD,MAAH,KAAc,MAAd,IAAwBqb,UAAUI,GAAV,CAAczY,GAAGG,KAAjB,CAA5B,EAAqD;AACnDH,WAAGG,KAAH,GAAWkY,UAAUJ,GAAV,CAAcjY,GAAGG,KAAjB,CAAX;AACD;;AAED,UAAMyN,UAAU0K,YAAYtY,GAAGC,GAAf,KAAuB0X,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa1Y,GAAGC,GAAhB,EAAqB,OAArB,EAA8B,QAA9B,CAAZ,CAAvC;;AAEA;AACA,UAAID,GAAGhD,MAAH,CAAU4N,UAAV,CAAqB,MAArB,CAAJ,EAAkC;AAChCyN,oBAAYA,UAAUnQ,GAAV,CAAclI,GAAGG,KAAjB,EAAwBjB,IAAxB,CAAZ;AACA,eAAOc,GAAGG,KAAV;AACAmY,oBAAYpZ,IAAZ,IAAoBc,GAAGhD,MAAvB;AACD;;AAED,UAAI4Q,YAAY,UAAZ,IAA0BA,YAAY,UAA1C,EAAsD;AACpD,YAAI,CAAC2K,QAAQvY,GAAGC,GAAX,CAAL,EAAsB;AACpBsY,kBAAQvY,GAAGC,GAAX,IAAkB0X,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa1Y,GAAGC,GAAhB,EAAqB,UAArB,CAAZ,KAAiD,IAAIqX,QAAJ,EAAnE;AACD;AACD,YAAI,OAAOtX,GAAGE,GAAV,KAAkB,QAAtB,EAAgC;AAC9B,gBAAM,IAAIkJ,SAAJ,gCAA2CpJ,GAAGE,GAA9C,CAAN;AACD;;AAED,YAAIF,GAAGjD,MAAP,EAAe;AACb,cAAIiD,GAAGE,GAAH,KAAW,CAAf,EAAkB;AAChBF,eAAGE,GAAH,GAAS,OAAT;AACAqY,oBAAQvY,GAAGC,GAAX,IAAkBsY,QAAQvY,GAAGC,GAAX,EAAgB0Y,WAAhB,CAA4B,IAA5B,EAAkCzZ,IAAlC,CAAlB;AACD,WAHD,MAGO;AACLc,eAAGE,GAAH,GAASqY,QAAQvY,GAAGC,GAAX,EAAgB2Y,KAAhB,CAAsB5Y,GAAGE,GAAH,GAAS,CAA/B,CAAT;AACAqY,oBAAQvY,GAAGC,GAAX,IAAkBsY,QAAQvY,GAAGC,GAAX,EAAgB0Y,WAAhB,CAA4B3Y,GAAGE,GAA/B,EAAoChB,IAApC,CAAlB;AACD;AACF,SARD,MAQO;AACLc,aAAGE,GAAH,GAASqY,QAAQvY,GAAGC,GAAX,EAAgB2Y,KAAhB,CAAsB5Y,GAAGE,GAAzB,CAAT;AACA,cAAIF,GAAGhD,MAAH,KAAc,KAAlB,EAAyB;AACvBub,oBAAQvY,GAAGC,GAAX,IAAkBsY,QAAQvY,GAAGC,GAAX,EAAgB4Y,SAAhB,CAA0B7Y,GAAGE,GAA7B,CAAlB;AACD;AACF;AACF;;AAED;AACA,UAAI,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B4Y,QAA9B,CAAuC9Y,GAAGhD,MAA1C,KAAqD,CAACgD,GAAGjD,MAA7D,EAAqE;AACnE,YAAI,CAACyb,YAAYxY,GAAGC,GAAf,CAAL,EAA0B;AACxBuY,sBAAYxY,GAAGC,GAAf,wBAAwBD,GAAGE,GAA3B,EAAiCF,EAAjC;AACD,SAFD,MAEO,IAAI,CAACwY,YAAYxY,GAAGC,GAAf,EAAoBD,GAAGE,GAAvB,CAAL,EAAkC;AACvCsY,sBAAYxY,GAAGC,GAAf,EAAoBD,GAAGE,GAAvB,IAA8BF,EAA9B;AACD,SAFM,MAEA,IAAIA,GAAGhD,MAAH,KAAc,KAAlB,EAAyB;AAC9Bwb,sBAAYxY,GAAGC,GAAf,EAAoBD,GAAGE,GAAvB,EAA4BpB,KAA5B,IAAqCkB,GAAGlB,KAAxC;AACA;AACD,SAHM,MAGA;AACL0Z,sBAAYxY,GAAGC,GAAf,EAAoBD,GAAGE,GAAvB,EAA4BlD,MAA5B,GAAqCgD,GAAGhD,MAAxC;AACAwb,sBAAYxY,GAAGC,GAAf,EAAoBD,GAAGE,GAAvB,EAA4BpB,KAA5B,GAAoCkB,GAAGlB,KAAvC;AACA;AACD;AACF;;AAEDe,aAAOC,GAAP,CAAWO,IAAX,CAAgBL,EAAhB;AACD;AAlE2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoE5D,SAAO,CAACyV,MAAMvN,GAAN,CAAU,WAAV,EAAuBmQ,SAAvB,CAAD,EAAoCxY,MAApC,CAAP;AACD;;AAED;;;AAGA,SAASkZ,IAAT,GAAgB;AACd,MAAMpB,QAAQN,MAAM0B,IAAN,EAAd;AAAA,MAA4BC,aAAa7B,IAAI,EAAC8B,SAAS,CAAV,EAAaC,WAAW,IAAxB,EAA8BvB,YAA9B,EAAJ,CAAzC;AACA,MAAMlC,QAAQ0B,IAAI,EAACQ,YAAD,EAAQwB,UAAU/B,KAAKrc,EAAL,CAAQie,UAAR,CAAlB,EAAuCX,WAAWlB,KAAlD,EAAJ,CAAd;AACA,SAAO,EAAC1B,YAAD,EAAP;AACD;;AAED,SAAS2D,KAAT,CAAe5B,OAAf,EAAwB;AACtB,SAAO,EAAC/B,OAAO8B,aAAaC,OAAb,CAAR,EAAP;AACD;;AAED,SAAS6B,IAAT,CAAc7B,OAAd,EAAuB;AACrBA,UAAQ/B,KAAR,GAAgB,IAAhB;AACA+B,UAAQC,MAAR,GAAiB,IAAjB;AACD;;AAED;;;;AAIA,SAAS6B,SAAT,CAAmB7D,KAAnB,EAA0B8D,KAA1B,EAAiCnB,OAAjC,EAA0CoB,aAA1C,EAAyD;AACvD,MAAMP,UAAUxD,MAAMwC,GAAN,CAAU,UAAV,EAAsBwB,IAAtB,GAA6BxB,GAA7B,CAAiC,SAAjC,CAAhB;AACA,MAAMyB,QAAUjE,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,CAAZ,EAAiC3Y,GAAjC,CAAqC;AAAA,WAAQ4Z,KAAKC,IAAb;AAAA,GAArC,EAAwDC,MAAxD,EAAhB;AACA,MAAM/S,OAAU2O,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,MAAV,CAAZ,EAA+BmB,MAA/B,GAAwCtZ,IAAxC,EAAhB;AACA,MAAMuZ,UAAUrE,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,SAAV,CAAZ,IAAoC,CAApD;AACA,MAAMqB,UAAU,CAACtE,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,WAAV,CAAZ,EAAoCsB,OAApC,EAAjB;AACA,MAAMC,QAAQ,EAAChB,gBAAD,EAAUS,YAAV,EAAiB5S,UAAjB,EAAuBgT,gBAAvB,EAAgCC,gBAAhC,EAAyCR,YAAzC,EAAd;;AAEA,MAAIC,iBAAiBpB,OAArB,EAA8B;AAC5B6B,UAAM3b,KAAN,GAAc8Z,QAAQ9Z,KAAtB;AACA2b,UAAM1b,GAAN,GAAc6Z,QAAQ7Z,GAAtB;AACD;AACD,SAAO0b,KAAP;AACD;;AAED;;;;AAIA,SAASC,KAAT,CAAezE,KAAf,EAAsBhW,OAAtB,EAA+B2Y,OAA/B,EAAwC+B,UAAxC,EAAoDX,aAApD,EAAmE;AACjE,MAAID,QAAQC,gBAAgB,EAAhB,GAAqB,IAAjC;AACA,MAAI7B,QAAQlC,MAAMwC,GAAN,CAAU,OAAV,CAAZ;AAFiE;AAAA;AAAA;;AAAA;AAGjE,0BAAmBxY,OAAnB,mIAA4B;AAAA,UAAnBI,MAAmB;AAAA;AAAA;AAAA;;AAAA;AAC1B,8BAAkB8J,gBAAgB9J,MAAhB,CAAlB,mIAA2C;AAAA,cAAlCqK,KAAkC;;AACzC,cAAIkO,OAAJ,EAAa;AACXT,oBAAQN,MAAM+C,cAAN,CAAqBzC,KAArB,EAA4B9X,MAA5B,EAAoCsa,UAApC,EAAgDZ,KAAhD,CAAR;AACD,WAFD,MAEO;AACL5B,oBAAQN,MAAMgD,SAAN,CAAgB1C,KAAhB,EAAuB9X,MAAvB,EAA+B0Z,KAA/B,CAAR;AACD;AACF;AAPyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ3B;AAXgE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAajElC,QAAMiD,aAAN,CAAoB3C,KAApB,EAA2B4B,KAA3B;AACA9D,UAAQA,MAAMvN,GAAN,CAAU,OAAV,EAAmByP,KAAnB,CAAR;;AAEA,MAAI6B,aAAJ,EAAmB;AACjB,QAAMP,UAAUxD,MAAMwC,GAAN,CAAU,UAAV,EAAsBwB,IAAtB,GAA6BxB,GAA7B,CAAiC,SAAjC,IAA8C,CAA9D;AACA,QAAMe,aAAa7B,IAAI,EAAC8B,gBAAD,EAAUC,WAAW,IAArB,EAA2BvB,YAA3B,EAAJ,CAAnB;AACAlC,YAAQA,MAAM5N,MAAN,CAAa,UAAb,EAAyB;AAAA,aAAYsR,SAAS9Y,IAAT,CAAc2Y,UAAd,CAAZ;AAAA,KAAzB,CAAR;AACD,GAJD,MAIO;AACL,QAAMA,cAAa7B,IAAI,EAAC8B,SAAS,CAAV,EAAaC,WAAW,IAAxB,EAA8BvB,YAA9B,EAAJ,CAAnB;AACAlC,YAAQA,MAAMvN,GAAN,CAAU,UAAV,EAAsBkP,KAAKrc,EAAL,CAAQie,WAAR,CAAtB,CAAR;AACD;;AAED,SAAO,CAACvD,KAAD,EAAQ+D,gBAAgBF,UAAU7D,KAAV,EAAiB8D,KAAjB,EAAwBnB,OAAxB,EAAiC,IAAjC,CAAhB,GAAyD,IAAjE,CAAP;AACD;;AAED;;;;;;AAMA,SAASmC,YAAT,CAAsB/C,OAAtB,EAA+B/X,OAA/B,EAAwC;AACtC,MAAIgW,QAAQ8B,aAAaC,OAAb,CAAZ;AAAA,MAAmCyC,cAAnC;;AAEA;AACA;AACA;AACAxE,UAAQA,MAAM5N,MAAN,CAAa,UAAb,EAAyB;AAAA,WAAYsR,SAASpZ,GAAT,CAAa;AAAA,aAAK3B,EAAE8J,GAAF,CAAM,WAAN,EAAmB,KAAnB,CAAL;AAAA,KAAb,CAAZ;AAAA,GAAzB,CAAR;AANsC,eAOpBgS,MAAMzE,KAAN,EAAahW,OAAb,EAAsB,IAAtB,EAA4B,KAA5B,EAAmC,IAAnC,CAPoB;;AAAA;;AAOpCgW,OAPoC;AAO7BwE,OAP6B;;AAQtCzC,UAAQC,MAAR,GAAiB,IAAjB;AACA,SAAO,CAAC,EAAChC,YAAD,EAAD,EAAUwE,KAAV,CAAP;AACD;;AAED;;;;;;;;AAQA,SAASO,gBAAT,CAA0BhD,OAA1B,EAAmCY,OAAnC,EAA4C;AAC1C,MAAI3C,QAAQ8B,aAAaC,OAAb,CAAZ;AACA,MAAI,OAAOY,QAAQ9Z,KAAf,KAAyB,QAAzB,IAAqC,OAAO8Z,QAAQ7Z,GAAf,KAAuB,QAAhE,EAA0E;AACxE,UAAM,IAAI6K,SAAJ,CAAc,sDAAd,CAAN;AACD;AACD,MAAI,OAAOgP,QAAQ3Z,IAAf,KAAwB,QAA5B,EAAsC;AACpC,UAAM,IAAI2K,SAAJ,CAAc,yCAAd,CAAN;AACD;AACD;AACA,MAAIgP,QAAQ7Z,GAAR,IAAekX,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBN,QAAQ9Z,KAA5B,CAAZ,EAAgD8Y,MAAhD,EAAwDwC,IAA3E,EAAiF;AAC/E,UAAM,IAAIra,UAAJ,CAAe,yCAAf,CAAN;AACD;;AAED,MAAMyZ,aAAavD,MAAMwC,GAAN,CAAU,UAAV,EAAsB3S,IAAtB,CAA2B;AAAA,WAAKlH,EAAE6Z,GAAF,CAAM,SAAN,MAAqBG,QAAQa,OAAlC;AAAA,GAA3B,CAAnB;AACA,MAAI,CAACD,UAAL,EAAiB;AACf,UAAM,IAAIzZ,UAAJ,oCAAgD6Y,QAAQa,OAAxD,CAAN;AACD;AACDb,UAAQtR,IAAR,GAAekS,WAAWN,KAAX,CAAiB,CAAC,OAAD,EAAU,MAAV,CAAjB,EAAoCmB,MAApC,EAAf;;AAEA,MAAIha,eAAJ;AAAA,MAAYgB,UAAUmY,WAAWN,KAAX,CAAiB,CAAC,OAAD,EAAU,OAAV,CAAjB,EAAqC,CAArC,IAA0C,CAAhE;AACA,MAAIN,QAAQqC,WAAR,KAAwB,QAA5B,EAAsC;AACpC;AADoC,gCACjBtC,qBAAqB1C,KAArB,EAA4BuD,WAAWf,GAAX,CAAe,OAAf,CAA5B,EAAqDG,OAArD,EAA8DvX,OAA9D,CADiB;;AAAA;;AAClC4U,SADkC;AAC3B5V,UAD2B;AAErC,GAFD,MAEO,IAAIuY,QAAQqC,WAAR,KAAwB,MAA5B,EAAoC;AACzC;AADyC,gBACtBC,KAAKjF,KAAL,EAAY2C,OAAZ,EAAqBvX,OAArB,CADsB;;AAAA;;AACvC4U,SADuC;AAChC5V,UADgC;AAE1C,GAFM,MAEA,IAAIuY,QAAQqC,WAAR,KAAwB,MAA5B,EAAoC;AACzC;AADyC,gBACtBE,KAAKlF,KAAL,EAAY2C,OAAZ,EAAqBvX,OAArB,CADsB;;AAAA;;AACvC4U,SADuC;AAChC5V,UADgC;AAE1C,GAFM,MAEA;AACL,UAAM,IAAIN,UAAJ,2BAAuC6Y,QAAQqC,WAA/C,CAAN;AACD;;AAED/C,aAAWsB,WAAWf,GAAX,CAAe,OAAf,CAAX,EAAoCpY,MAApC;AACA,MAAMoK,eAAepB,aAAahJ,MAAb,CAArB;AACA,MAAIoa,cAAJ;AAAA,MAAWE,aAAc/B,QAAQqC,WAAR,KAAwB,QAAxB,IAAoCrC,QAAQwC,QAAR,KAAqB,KAAlF;AAhC0C,gBAiCxBV,MAAMzE,KAAN,EAAa,CAACxL,YAAD,CAAb,EAA6BmO,OAA7B,EAAsC+B,UAAtC,EAAkD,IAAlD,CAjCwB;;AAAA;;AAiCxC1E,OAjCwC;AAiCjCwE,OAjCiC;;;AAmC1CxE,UAAQA,MAAM5N,MAAN,CAAa,UAAb,EAAyB,oBAAY;AAC3C;AACA;AACA,WAAOsR,SAAS1Y,MAAT,CAAgB;AAAA,aAAKrC,EAAE6Z,GAAF,CAAM,SAAN,KAAoBG,QAAQa,OAAjC;AAAA,KAAhB;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AAPK,KAQJlZ,GARI,CAQA,aAAK;AACR,UAAI3B,EAAE6Z,GAAF,CAAM,WAAN,CAAJ,EAAwB;AACtB,eAAO7Z,EAAE8J,GAAF,CAAM,OAAN,EAAeuN,MAAMwC,GAAN,CAAU,OAAV,CAAf,CAAP;AACD,OAFD,MAEO;AACL,eAAO7Z,EAAE8J,GAAF,CAAM,OAAN,EAAemP,MAAM+C,cAAN,CAAqBhc,EAAE6Z,GAAF,CAAM,OAAN,CAArB,EAAqChO,YAArC,EAAmD,KAAnD,EAA0D,IAA1D,CAAf,CAAP;AACD;AACF,KAdI,CAAP;AAeD,GAlBO,CAAR;AAmBAuN,UAAQC,MAAR,GAAiB,IAAjB;AACA,SAAO,CAAC,EAAChC,YAAD,EAAD,EAAUwE,KAAV,CAAP;AACD;;AAED;;;AAGA,SAASY,IAAT,CAAcrD,OAAd,EAAuB;AACrB,SAAOhL,eAAesO,WAAWtD,OAAX,EAAoB,EAApB,CAAf,CAAP;AACD;;AAED;;;;AAIA,SAASuD,IAAT,CAAc7F,IAAd,EAAoB;AAClB;AACA;AACA,MAAMnL,gBAAgBD,cAAc,CAACoL,IAAD,CAAd,EAAsBnV,GAAtB,CAA0B8I,YAA1B,CAAtB;AACA,SAAOmS,YAAYjC,MAAZ,EAAoBhP,aAApB,CAAP;AACD;;AAED;;;;;;;AAOA,SAASiR,WAAT,CAAqBxD,OAArB,EAA8B/X,OAA9B,EAAuC;AACrC,MAAMgW,QAAQ8B,aAAaC,OAAb,CAAd;;AADqC,gBAEf0C,MAAMzE,KAAN,EAAahW,OAAb,EAAsB,IAAtB,EAA4B,KAA5B,EAAmC,KAAnC,CAFe;AAAA;AAAA,MAE9Bwb,QAF8B;AAAA,MAEpB1V,CAFoB;;AAGrCiS,UAAQC,MAAR,GAAiB,IAAjB;AACA,SAAO,EAAChC,OAAOwF,QAAR,EAAP;AACD;;AAED;;;;AAIA,SAASC,QAAT,CAAkB1D,OAAlB,EAA2B;AACzB,MAAM/B,QAAQ8B,aAAaC,OAAb,CAAd;AACA,MAAM+B,QAAQ7L,eAAemN,KAAKrD,OAAL,CAAf,CAAd;AACA,SAAO8B,UAAU7D,KAAV,EAAiB8D,KAAjB,EAAwB,IAAxB,EAA8B,KAA9B,CAAP;AACD;;AAED,SAAS4B,kBAAT,CAA4B3D,OAA5B,EAAqCpY,OAArC,EAA8C;AAC5C,MAAMqW,QAAQ8B,aAAaC,OAAb,CAAd;AACA,SAAOH,MAAM8D,kBAAN,CAAyB1F,MAAMwC,GAAN,CAAU,OAAV,CAAzB,EAA6C7Y,OAA7C,CAAP;AACD;;AAED,SAAS0b,UAAT,CAAoBtD,OAApB,EAA6B4D,QAA7B,EAAuC;AACrC,MAAI,CAAClS,MAAMC,OAAN,CAAciS,QAAd,CAAL,EAA8B;AAC5B,UAAM,IAAIhS,SAAJ,CAAc,iDAAd,CAAN;AACD;AACD,MAAMqM,QAAQ8B,aAAaC,OAAb,CAAd;AACA,SAAOH,MAAMgE,iBAAN,CAAwB5F,MAAMwC,GAAN,CAAU,OAAV,CAAxB,EAA4Cb,KAAKgE,QAAL,CAA5C,CAAP;AACD;;AAED,SAASE,cAAT,CAAwB9D,OAAxB,EAAiC;AAC/B,MAAM/B,QAAQ8B,aAAaC,OAAb,CAAd;AACA,SAAOH,MAAMiE,cAAN,CAAqB7F,MAAMwC,GAAN,CAAU,OAAV,CAArB,CAAP;AACD;;AAED;;;;;;;AAOA,SAASyC,IAAT,CAAcjF,KAAd,EAAqB2C,OAArB,EAA8BvX,OAA9B,EAAuC;AACrC,MAAM0a,UAAU9F,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,SAAV,CAAZ,CAAhB;AACA,MAAM8C,UAAU/F,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,WAAV,EAAuB6C,UAAU,CAAjC,CAAZ,CAAhB;AACA,MAAIA,UAAU,CAAV,IAAe,CAACC,OAApB,EAA6B;AAC3B,UAAM,IAAIjc,UAAJ,CAAe,4CAAf,CAAN;AACD;AALoC,MAM7BjB,KAN6B,GAMO8Z,OANP,CAM7B9Z,KAN6B;AAAA,MAMtBC,GANsB,GAMO6Z,OANP,CAMtB7Z,GANsB;AAAA,MAMjBuI,IANiB,GAMOsR,OANP,CAMjBtR,IANiB;AAAA,MAMXrI,IANW,GAMO2Z,OANP,CAMX3Z,IANW;AAAA,MAMLC,OANK,GAMO0Z,OANP,CAML1Z,OANK;;AAOrC,MAAMmB,SAAS,EAACvB,YAAD,EAAQC,QAAR,EAAasC,gBAAb,EAAsBiG,UAAtB,EAA4BrI,UAA5B,EAAkCC,gBAAlC,EAA2CoB,KAAK0b,QAAQtD,IAAR,EAAhD,EAAf;;AAEA,MAAIP,QAAQlC,MAAMwC,GAAN,CAAU,OAAV,CAAZ;AACA,MAAIwD,UAAUrE,OAAOsE,aAAP,CAAqB,mBAAW;AAAA;AAAA;AAAA;;AAAA;AAC5C,4BAAeF,OAAf,mIAAwB;AAAA,YAAfxb,EAAe;;AACtB,YAAI,CAAC,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B8Y,QAA9B,CAAuC9Y,GAAGiY,GAAH,CAAO,QAAP,CAAvC,CAAL,EAA+D;AAC7D,gBAAM,IAAI1Y,UAAJ,iDAA6DS,EAA7D,CAAN;AACD;AACD;AACA,YAAME,MAAMmX,MAAMsE,eAAN,CAAsB3b,EAAtB,CAAZ;AACA,YAAM8X,WAAWT,MAAMU,WAAN,CAAkBJ,KAAlB,EAAyB3X,GAAGiY,GAAH,CAAO,KAAP,CAAzB,EAAwC/X,GAAxC,CAAjB;AACA,YAAIF,GAAGiY,GAAH,CAAO,QAAP,MAAqB,KAAzB,EAAgC;AAC9BwD,kBAAQpb,IAAR,CAAa8W,IAAI,EAACna,QAAQ,KAAT,EAAgBiD,KAAKD,GAAGiY,GAAH,CAAO,KAAP,CAArB,EAAoC/X,QAApC,EAAyCnD,QAAQ,KAAjD,EAAwD+B,OAAO,CAACkB,GAAGiY,GAAH,CAAO,OAAP,CAAhE,EAAJ,CAAb;AACD,SAFD,MAEO,IAAIH,SAASkC,OAAT,EAAJ,EAAwB;AAC7ByB,kBAAQpb,IAAR,CAAa8W,IAAI,EAACna,QAAQ,KAAT,EAAgBiD,KAAKD,GAAGiY,GAAH,CAAO,KAAP,CAArB,EAAoC/X,QAApC,EAAyCnD,QAAQ,KAAjD,EAAJ,CAAb;AACD,SAFM,MAEA;AAAA;AAAA;AAAA;;AAAA;AACL,kCAAoB+a,QAApB,mIAA8B;AAAA,kBAArBE,OAAqB;;AAC5B,kBAAIA,QAAQC,GAAR,CAAY,QAAZ,CAAJ,EAA2B;AACzBD,0BAAUA,QAAQ4D,MAAR,CAAe,QAAf,EAAyB1T,GAAzB,CAA6B,KAA7B,EAAoChI,GAApC,CAAV;AACD;AACD,kBAAI8X,QAAQC,GAAR,CAAY,QAAZ,EAAsBrN,UAAtB,CAAiC,MAAjC,CAAJ,EAA8C;AAC5C,oBAAMyC,UAAU2K,QAAQC,GAAR,CAAY,OAAZ,EAAqBD,QAAQC,GAAR,CAAY,MAAZ,CAArB,CAAhB;AACAD,0BAAUA,QAAQ9P,GAAR,CAAY,QAAZ,EAAsB,MAAtB,EAA8BA,GAA9B,CAAkC,OAAlC,EAA2CmF,OAA3C,CAAV;AACD;AACD2K,wBAAUA,QAAQ4D,MAAR,CAAe,MAAf,EAAuBA,MAAvB,CAA8B,MAA9B,EAAsC1T,GAAtC,CAA0C,QAA1C,EAAoD,KAApD,CAAV;AACAuT,sBAAQpb,IAAR,CAAa2X,OAAb;AACD;AAXI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYN;AACF;AAzB2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0B7C,GA1Ba,CAAd;;AA4BAL,UAAQA,MACLzP,GADK,CACD,SADC,EACUqT,UAAU,CADpB,EAEL1T,MAFK,CAEE,WAFF,EAEe;AAAA,WAASkD,MAAM1K,IAAN,CAAWob,OAAX,CAAT;AAAA,GAFf,CAAR;AAGA,SAAO,CAAChG,MAAMvN,GAAN,CAAU,OAAV,EAAmByP,KAAnB,CAAD,EAA4B9X,MAA5B,CAAP;AACD;;AAED;;;;;;AAMA,SAAS8a,IAAT,CAAclF,KAAd,EAAqB2C,OAArB,EAA8BvX,OAA9B,EAAuC;AACrC,MAAM4a,UAAUhG,MAAMiD,KAAN,CAAY,CAAC,OAAD,EAAU,WAAV,CAAZ,EAAoCe,IAApC,EAAhB;AACA,MAAI,CAACgC,OAAL,EAAc;AACZ,UAAM,IAAIlc,UAAJ,CAAe,8CAAf,CAAN;AACD;AAJoC,MAK7BjB,KAL6B,GAKO8Z,OALP,CAK7B9Z,KAL6B;AAAA,MAKtBC,GALsB,GAKO6Z,OALP,CAKtB7Z,GALsB;AAAA,MAKjBuI,IALiB,GAKOsR,OALP,CAKjBtR,IALiB;AAAA,MAKXrI,IALW,GAKO2Z,OALP,CAKX3Z,IALW;AAAA,MAKLC,OALK,GAKO0Z,OALP,CAKL1Z,OALK;;AAMrC,MAAMmB,SAAS,EAACvB,YAAD,EAAQC,QAAR,EAAasC,gBAAb,EAAsBiG,UAAtB,EAA4BrI,UAA5B,EAAkCC,gBAAlC,EAA2CoB,KAAK2b,QAAQvD,IAAR,EAAhD,EAAf;;AAEA,MAAIP,QAAQlC,MAAMwC,GAAN,CAAU,OAAV,EACTpQ,MADS,CACF,SADE,EACS;AAAA,WAAW0T,UAAU,CAArB;AAAA,GADT,EAET1T,MAFS,CAEF,WAFE,EAEW;AAAA,WAASkD,MAAMC,GAAN,EAAT;AAAA,GAFX,CAAZ;AAGA,SAAO,CAACyK,MAAMvN,GAAN,CAAU,OAAV,EAAmByP,KAAnB,CAAD,EAA4B9X,MAA5B,CAAP;AACD;;AAED,SAASgc,YAAT,CAAsBrE,OAAtB,EAA+B;AAC7B,SAAOD,aAAaC,OAAb,EAAsBkB,KAAtB,CAA4B,CAAC,OAAD,EAAU,WAAV,CAA5B,EAAoDR,IAApD,EAAP;AACD;;AAED,SAAS4D,YAAT,CAAsBtE,OAAtB,EAA+B;AAC7B,SAAOD,aAAaC,OAAb,EAAsBkB,KAAtB,CAA4B,CAAC,OAAD,EAAU,WAAV,CAA5B,EAAoDR,IAApD,EAAP;AACD;;AAEDhF,OAAOC,OAAP,GAAiB;AACf4F,YADe,EACTK,YADS,EACFC,UADE,EACIkB,0BADJ,EACkBC,kCADlB,EACoCK,UADpC,EAC0CE,UAD1C,EACgDC,wBADhD,EAC6DE,kBAD7D;AAEfC,wCAFe,EAEKL,sBAFL,EAEiBQ,8BAFjB,EAEiCO,0BAFjC,EAE+CC;AAF/C,CAAjB,C;;;;;;;;;;;;;;;;eC1ZmCjiB,mBAAOA,CAAC,6DAAR,C;IAA3Bsd,G,YAAAA,G;IAAKC,I,YAAAA,I;IAAM2E,G,YAAAA,G;IAAKC,M,YAAAA,M;;gBACHniB,mBAAOA,CAAC,2CAAR,C;IAAbyd,Q,aAAAA,Q;;gBACmCzd,mBAAOA,CAAC,yCAAR,C;IAAnC2P,Y,aAAAA,Y;IAAcC,gB,aAAAA,gB;;gBACS5P,mBAAOA,CAAC,sCAAR,C;IAAvBC,O,aAAAA,O;IAASE,S,aAAAA,S;;AAEjB;AACA;;;AACA,SAASiiB,aAAT,CAAuBtE,KAAvB,EAA8B9X,MAA9B,EAAsC;AAAA;AAAA;AAAA;;AAAA;AACpC,yBAAiBA,OAAOiH,IAAxB,8HAA8B;AAAA,UAArBiB,IAAqB;;AAC5B,UAAI,CAAC4P,MAAMuE,KAAN,CAAY,CAAC,QAAD,EAAWnU,IAAX,CAAZ,CAAL,EAAoC,OAAO,KAAP;AACrC;AAHmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIpC,SAAO,IAAP;AACD;;AAED;;;;;AAKA,SAASoU,OAAT,CAAiBxE,KAAjB,EAAwBhN,QAAxB,EAAkC;AAChC,MAAIyR,OAAO,EAAX;AACA,SAAOzR,aAAa7Q,OAApB,EAA6B;AAC3B,QAAM+Q,MAAM8M,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,UAAvB,CAAZ,EAAgDoR,KAAhD,EAAuDM,KAAvD,EAAZ;AACA,QAAI,CAACxR,GAAL,EAAU,MAAM,IAAItL,UAAJ,8BAA0CoL,QAA1C,CAAN;AACVyR,SAAKE,OAAL,CAAazR,GAAb;AACAF,eAAWE,IAAIoN,GAAJ,CAAQ,KAAR,CAAX;AACD;AACD,SAAOmE,IAAP;AACD;;AAED;;;;AAIA,SAASG,aAAT,CAAuB5E,KAAvB,EAA8BhN,QAA9B,EAAwC;AACtC,MAAIA,aAAa7Q,OAAjB,EAA0B,OAAO,KAAP;AAC1B,MAAM0iB,UAAU7E,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,OAAvB,EAAgC,QAAhC,CAAZ,CAAhB;AACA,MAAM6C,OAAO,EAACK,SAAS,KAAV,EAAiBG,WAAW,OAA5B,EAAqCF,UAAU,MAA/C,EAAuDC,UAAU,MAAjE,GAAyEyO,OAAzE,CAAb;AACA,MAAI,CAAChP,IAAL,EAAW,MAAM,IAAIjO,UAAJ,0BAAsCid,OAAtC,aAAqD7R,QAArD,CAAN;AACX,SAAO6C,IAAP;AACD;;AAED;AACA,SAASiP,SAAT,CAAmB9E,KAAnB,EAA0B3X,EAA1B,EAA8Bia,KAA9B,EAAqC;AACnC,MAAMtP,WAAW+R,WAAW1c,EAAX,CAAjB;AAAA,MAAiChD,SAASgD,GAAGiY,GAAH,CAAO,QAAP,CAA1C;AACA,MAAIN,MAAMuE,KAAN,CAAY,CAAC,UAAD,EAAavR,QAAb,EAAuB,OAAvB,CAAZ,CAAJ,EAAkD,MAAM,IAAIsJ,KAAJ,mCAA0CtJ,QAA1C,CAAN;;AAElD,MAAIgS,SAASxF,IAAI,EAACyF,OAAO5c,EAAR,EAAY6c,UAAUd,KAAtB,EAA6Be,OAAO3F,KAApC,EAAJ,CAAb;AACA,MAAIna,WAAW,UAAX,IAAyBA,WAAW,UAAxC,EAAoD;AAClD2f,aAASA,OAAOzU,GAAP,CAAW,UAAX,EAAuB,IAAIoP,QAAJ,EAAvB,CAAT;AACD;AACDK,UAAQA,MAAMoF,KAAN,CAAY,CAAC,UAAD,EAAapS,QAAb,CAAZ,EAAoCgS,MAApC,CAAR;;AAEA,MAAI1C,KAAJ,EAAW;AACTA,UAAMtP,QAAN,GAAiBA,QAAjB;AACAsP,UAAMzM,IAAN,GAAa+O,cAAc5E,KAAd,EAAqBhN,QAArB,CAAb;AACD;AACD,SAAOgN,KAAP;AACD;;AAED;AACA;AACA,SAASqF,WAAT,CAAqBrF,KAArB,EAA4B3X,EAA5B,EAAgC;AAC9B,MAAM2K,WAAW3K,GAAGiY,GAAH,CAAO,KAAP,CAAjB;AAAA,MAAgC/Y,OAAOc,GAAGiY,GAAH,CAAO,MAAP,CAAvC;AACA,MAAI,CAACN,MAAMM,GAAN,CAAU,UAAV,EAAsBQ,GAAtB,CAA0B9N,QAA1B,CAAL,EAA0C,MAAM,IAAIsJ,KAAJ,qCAA4CtJ,QAA5C,CAAN;AAC1C,MAAIgN,MAAMuE,KAAN,CAAY,CAAC,UAAD,EAAavR,QAAb,EAAuB,YAAvB,EAAqCzL,IAArC,CAAZ,CAAJ,EAA6D,MAAM,IAAI+U,KAAJ,gCAAuC/U,IAAvC,CAAN;;AAE7D,SAAOyY,MACJsF,QADI,CACK,CAAC,UAAD,EAAatS,QAAb,EAAuB,YAAvB,EAAqC3K,GAAGiY,GAAH,CAAO,KAAP,CAArC,CADL,EAC0Db,MAD1D,EACkE;AAAA,WAAQ8F,KAAK7c,IAAL,CAAUL,EAAV,CAAR;AAAA,GADlE,EAEJ+c,KAFI,CAEE,CAAC,UAAD,EAAapS,QAAb,EAAuB,YAAvB,EAAqCzL,IAArC,CAFF,EAE8Cc,EAF9C,CAAP;AAGD;;AAED,SAASmd,iBAAT,CAA2BxF,KAA3B,EAAkChN,QAAlC,EAA4CyS,MAA5C,EAAoDnD,KAApD,EAA2D;AACzD,MAAMna,MAAMiY,YAAYJ,KAAZ,EAAmBhN,QAAnB,EAA6ByS,MAA7B,CAAZ;AACA,MAAI7E,UAAUZ,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,UAAvB,CAAZ,CAAd;AACA,MAAIY,QAAQgN,QAAQvZ,OAAR,CAAgBoe,MAAhB,CAAZ;;AAEA,MAAInD,SAASA,MAAMxM,KAAN,KAAgB1O,SAA7B,EAAwC;AACtCkb,UAAMxM,KAAN,GAAc,EAAd;AACD;;AAED,MAAIlC,SAAS,CAAb,EAAgB;AACd,QAAIzL,IAAIka,OAAJ,EAAJ,EAAmB;AACjBzB,gBAAUA,QAAQ8E,WAAR,CAAoB9R,KAApB,CAAV;AACA,UAAI0O,KAAJ,EAAWA,MAAMxM,KAAN,CAAYpN,IAAZ,CAAiB,EAACrD,QAAQ,QAAT,EAAmBuO,YAAnB,EAAjB;AACZ,KAHD,MAGO;AACLgN,gBAAUA,QAAQ+E,QAAR,CAAiBF,MAAjB,EAAyBtd,IAAIuc,KAAJ,GAAYpE,GAAZ,CAAgB,OAAhB,CAAzB,CAAV;AACD;AAEF,GARD,MAQO;AACL,QAAInY,IAAIka,OAAJ,EAAJ,EAAmB,OAAOrC,KAAP,CADd,CAC2B;;AAEhC;AACA,QAAI4F,SAASH,MAAb;AACA,WAAO,IAAP,EAAa;AACX7R,cAAQ,CAAC,CAAT;AACAgS,eAASC,YAAY7F,KAAZ,EAAmBhN,QAAnB,EAA6B4S,MAA7B,CAAT;AACA,UAAI,CAACA,MAAL,EAAa;AACbhS,cAAQgN,QAAQvZ,OAAR,CAAgBue,MAAhB,CAAR;AACA,UAAIhS,SAAS,CAAb,EAAgB;AACjB;;AAEDA,aAAS,CAAT;AACAgN,cAAUA,QAAQkF,WAAR,CAAoBlS,KAApB,EAA2B6R,MAA3B,EAAmCtd,IAAIuc,KAAJ,GAAYpE,GAAZ,CAAgB,OAAhB,CAAnC,CAAV;AACA,QAAIgC,KAAJ,EAAWA,MAAMxM,KAAN,CAAYpN,IAAZ,CAAiB,EAACrD,QAAQ,QAAT,EAAmBuO,YAAnB,EAAjB;AACZ;AACD,SAAOoM,MAAMoF,KAAN,CAAY,CAAC,UAAD,EAAapS,QAAb,EAAuB,UAAvB,CAAZ,EAAgD4N,OAAhD,CAAP;AACD;;AAED;;;;;AAKA,SAASmF,iBAAT,CAA2B/F,KAA3B,EAAkC3X,EAAlC,EAAsC;AACpC,MAAI,CAAC2X,MAAMc,GAAN,CAAU,WAAV,CAAL,EAA6B,OAAOd,KAAP;AAC7B,MAAMhN,WAAW3K,GAAGiY,GAAH,CAAO,KAAP,CAAjB;AAAA,MAAgC/X,MAAMyb,gBAAgB3b,EAAhB,CAAtC;AAAA,MAA2DlB,QAAQkB,GAAGiY,GAAH,CAAO,OAAP,CAAnE;;AAEA,MAAIuD,gBAAJ;AACA,MAAIxb,GAAGiY,GAAH,CAAO,QAAP,MAAqB,KAAzB,EAAgC;AAC9BuD,cAAUpE,KAAKrc,EAAL,CAAQoc,IAAI,EAACna,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,QAA/B,EAAoCnD,QAAQ,KAA5C,EAAmD+B,OAAO,CAACA,KAA3D,EAAJ,CAAR,CAAV;AACD,GAFD,MAEO;AACL0c,cAAUzD,YAAYJ,KAAZ,EAAmBhN,QAAnB,EAA6BzK,GAA7B,EAAkCH,GAAlC,CAAsC,eAAO;AACrD,UAAI8K,IAAIoN,GAAJ,CAAQ,QAAR,CAAJ,EAAuB;AACrBpN,cAAMA,IAAI3C,GAAJ,CAAQ,KAAR,EAAehI,GAAf,CAAN;AACD;AACD,UAAI2K,IAAIoN,GAAJ,CAAQ,QAAR,EAAkBrN,UAAlB,CAA6B,MAA7B,CAAJ,EAA0C;AACxCC,cAAMA,IAAI3C,GAAJ,CAAQ,QAAR,EAAkB,MAAlB,EAA0BA,GAA1B,CAA8B,OAA9B,EAAuCwU,WAAW7R,GAAX,CAAvC,CAAN;AACD;AACDA,YAAMA,IAAIpK,MAAJ,CAAW,UAACrC,CAAD,EAAID,CAAJ;AAAA,eAAU,CAAC,QAAD,EAAW,KAAX,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC,UAAlC,EAA8C,OAA9C,EAAuD2a,QAAvD,CAAgE3a,CAAhE,CAAV;AAAA,OAAX,CAAN;AACA0M,YAAMA,IAAI3C,GAAJ,CAAQ,QAAR,EAAkB,KAAlB,CAAN;AACA,aAAO2C,GAAP;AACD,KAVS,CAAV;AAWD;AACD,MAAI2Q,QAAQxB,OAAR,EAAJ,EAAuB;AACrBwB,cAAUpE,KAAKrc,EAAL,CAAQoc,IAAI,EAACna,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,QAA/B,EAAoCnD,QAAQ,KAA5C,EAAJ,CAAR,CAAV;AACD;AACD,SAAO4a,MAAM9P,MAAN,CAAa,WAAb,EAA0B;AAAA,WAAa8V,UAAUnd,MAAV,CAAiBgb,OAAjB,CAAb;AAAA,GAA1B,CAAP;AACD;;AAED;;;AAGA,SAASoC,SAAT,CAAmB5d,EAAnB,EAAuB;AACrB,MAAMhD,SAASgD,GAAGiY,GAAH,CAAO,QAAP,CAAf;AACA,SAAOjb,OAAO4N,UAAP,CAAkB,MAAlB,KAA6B5N,WAAW,MAA/C;AACD;;AAED;;;AAGA,SAAS0f,UAAT,CAAoB1c,EAApB,EAAwB;AACtB,SAAOA,GAAGiY,GAAH,CAAO,OAAP,EAAgBjY,GAAGiY,GAAH,CAAO,MAAP,CAAhB,CAAP;AACD;;AAED;;;;AAIA,SAAS0D,eAAT,CAAyB3b,EAAzB,EAA6B;AAC3B,SAAOA,GAAGiY,GAAH,CAAO,QAAP,IAAmBjY,GAAGiY,GAAH,CAAO,MAAP,CAAnB,GAAoCjY,GAAGiY,GAAH,CAAO,KAAP,CAA3C;AACD;;AAED;;;;AAIA,SAAS4F,WAAT,CAAqBlG,KAArB,EAA4B3X,EAA5B,EAAgCia,KAAhC,EAAuC;AACrC,MAAMtP,WAAW3K,GAAGiY,GAAH,CAAO,KAAP,CAAjB;AAAA,MAAgCjb,SAASgD,GAAGiY,GAAH,CAAO,QAAP,CAAzC;AAAA,MAA2D/X,MAAMyb,gBAAgB3b,EAAhB,CAAjE;AACA,MAAI,CAAC2X,MAAMM,GAAN,CAAU,UAAV,EAAsBQ,GAAtB,CAA0B9N,QAA1B,CAAL,EAA0C,MAAM,IAAIpL,UAAJ,qCAAiDoL,QAAjD,CAAN;AAC1C,MAAM6C,OAAO+O,cAAc5E,KAAd,EAAqBhN,QAArB,CAAb;;AAEA,MAAIsP,KAAJ,EAAW;AACTA,UAAMtP,QAAN,GAAiBsP,MAAMtP,QAAN,IAAkBA,QAAnC;AACA,QAAIsP,MAAMtP,QAAN,KAAmBA,QAAvB,EAAiC;AAC/B,YAAM,IAAIpL,UAAJ,kCAA8C0a,MAAMtP,QAApD,YAAmEA,QAAnE,CAAN;AACD;AACD,QAAIsP,MAAM1M,KAAN,KAAgBxO,SAApB,EAA+B;AAC7Bkb,YAAM1M,KAAN,GAAc,EAAd;AACD;AACD,QAAI0M,MAAM1M,KAAN,CAAYrN,GAAZ,MAAqBnB,SAAzB,EAAoC;AAClCkb,YAAM1M,KAAN,CAAYrN,GAAZ,IAAmB,EAAnB;AACD;;AAED+Z,UAAMzM,IAAN,GAAayM,MAAMzM,IAAN,IAAcA,IAA3B;AACA,QAAIyM,MAAMzM,IAAN,KAAeA,IAAnB,EAAyB;AACvB,YAAM,IAAIjO,UAAJ,qCAAiD0a,MAAMzM,IAAvD,YAAkEA,IAAlE,CAAN;AACD;AACF;;AAED,MAAIxQ,OAAO4N,UAAP,CAAkB,MAAlB,CAAJ,EAA+B;AAC7B,QAAIqP,KAAJ,EAAW;AACTA,YAAM1M,KAAN,CAAYrN,GAAZ,EAAiBF,GAAGiY,GAAH,CAAO,MAAP,CAAjB,IAAmC,EAAnC;AACAN,cAAQ8E,UAAU9E,KAAV,EAAiB3X,EAAjB,EAAqBia,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBF,GAAGiY,GAAH,CAAO,MAAP,CAAjB,CAArB,CAAR;AACD,KAHD,MAGO;AACLN,cAAQ8E,UAAU9E,KAAV,EAAiB3X,EAAjB,CAAR;AACD;AACF;AACD,MAAIhD,WAAW,MAAX,IAAqBid,KAAzB,EAAgC;AAC9BA,UAAM1M,KAAN,CAAYrN,GAAZ,EAAiBF,GAAGiY,GAAH,CAAO,MAAP,CAAjB,IAAmC6F,gBAAgBnG,KAAhB,EAAuB+E,WAAW1c,EAAX,CAAvB,CAAnC;AACD;;AAED,MAAMF,MAAMiY,YAAYJ,KAAZ,EAAmBhN,QAAnB,EAA6BzK,GAA7B,CAAZ;AACA,MAAI6d,oBAAJ;AAAA,MAAiBhI,kBAAjB;;AAEA,MAAI/Y,WAAW,KAAf,EAAsB;AACpB+gB,kBAAc3G,MAAd;AACArB,gBAAYjW,IAAIC,GAAJ,CAAQ,iBAAS;AAC3B,UAAIie,MAAM/F,GAAN,CAAU,QAAV,MAAwB,KAAxB,IAAiC,OAAO+F,MAAM/F,GAAN,CAAU,OAAV,CAAP,KAA8B,QAA/D,IACA+F,MAAM/F,GAAN,CAAU,UAAV,MAA0B,SAD1B,IACuCjY,GAAGiY,GAAH,CAAO,MAAP,EAAea,QAAf,CAAwBkF,MAAM/F,GAAN,CAAU,MAAV,CAAxB,CAD3C,EACuF;AACrF,eAAO+F,MAAM9V,GAAN,CAAU,OAAV,EAAmB8V,MAAM/F,GAAN,CAAU,OAAV,IAAqBjY,GAAGiY,GAAH,CAAO,OAAP,CAAxC,CAAP;AACD,OAHD,MAGO;AACL,eAAO+F,KAAP;AACD;AACF,KAPW,CAAZ;AAQD,GAVD,MAUO;AACL,QAAMC,sBAAsBne,IAAIoe,OAAJ,CAAY;AAAA,aAASle,GAAGiY,GAAH,CAAO,MAAP,EAAea,QAAf,CAAwBkF,MAAM/F,GAAN,CAAU,MAAV,CAAxB,CAAT;AAAA,KAAZ,CAA5B;AACA8F,kBAAcE,oBAAoBhG,GAApB,CAAwB,IAAxB,EAA+Bb,MAA/B,CAAd;AACArB,gBAAckI,oBAAoBhG,GAApB,CAAwB,KAAxB,EAA+Bb,MAA/B,CAAd;AACD;;AAED;;AAtDqC,6BAuD5B+G,GAvD4B;AAwDnCxG,YAAQA,MAAMsF,QAAN,CAAe,CAAC,UAAD,EAAaP,WAAWyB,GAAX,CAAb,EAA8B,UAA9B,CAAf,EAA0D;AAAA,aAAOre,IAAI8b,MAAJ,CAAWuC,GAAX,CAAP;AAAA,KAA1D,CAAR;AAxDmC;;AAAA;AAAA;AAAA;;AAAA;AAuDrC,0BAAgBJ,YAAYtd,MAAZ,CAAmBmd,SAAnB,CAAhB,mIAA+C;AAAA,UAAtCO,GAAsC;;AAAA,YAAtCA,GAAsC;AAE9C;AAzDoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2DrC,MAAIP,UAAU5d,EAAV,CAAJ,EAAmB;AACjB2X,YAAQA,MAAMsF,QAAN,CAAe,CAAC,UAAD,EAAaP,WAAW1c,EAAX,CAAb,EAA6B,UAA7B,CAAf,EAAyD+b,KAAzD,EAAgE;AAAA,aAAOjc,IAAIse,GAAJ,CAAQpe,EAAR,CAAP;AAAA,KAAhE,CAAR;AACD;AACD,MAAIhD,WAAW,KAAX,IAAoB4gB,UAAU5d,EAAV,CAAxB,EAAuC;AAAE;AACvC+V,gBAAYA,UAAU1V,IAAV,CAAeL,EAAf,CAAZ;AACD;AACD+V,cAAYA,UAAUxV,IAAV,CAAe8d,cAAf,EAA+BC,OAA/B,EAAZ;AACA3G,UAAQA,MAAMoF,KAAN,CAAY,CAAC,UAAD,EAAapS,QAAb,EAAuB,OAAvB,EAAgCzK,GAAhC,CAAZ,EAAkD6V,SAAlD,CAAR;AACAwI,gBAAc5G,KAAd,EAAqBhN,QAArB,EAA+BzK,GAA/B,EAAoC+Z,KAApC;;AAEA,MAAIzM,SAAS,MAAT,IAAmBA,SAAS,MAAhC,EAAwC;AACtCmK,YAAQwF,kBAAkBxF,KAAlB,EAAyBhN,QAAzB,EAAmCzK,GAAnC,EAAwC+Z,KAAxC,CAAR;AACD;AACD,SAAOtC,KAAP;AACD;;AAED;;;;;;AAMA,SAAS6G,eAAT,CAAyB7G,KAAzB,EAAgC8G,MAAhC,EAAwCxE,KAAxC,EAA+C;AAC7C,MAAMtP,WAAW8T,OAAOxG,GAAP,CAAW,KAAX,CAAjB;AAAA,MAAoC/Y,OAAOuf,OAAOxG,GAAP,CAAW,MAAX,CAA3C;AAAA,MAA+D/X,MAAMyb,gBAAgB8C,MAAhB,CAArE;AACA,MAAMjR,OAAO+O,cAAc5E,KAAd,EAAqBhN,QAArB,CAAb;AACAsP,QAAMtP,QAAN,GAAiBsP,MAAMtP,QAAN,IAAkBA,QAAnC;AACAsP,QAAMzM,IAAN,GAAiByM,MAAMzM,IAAN,IAAkBA,IAAnC;;AAEA,MAAIyM,MAAMtP,QAAN,KAAmBA,QAAvB,EAAiC;AAC/B,UAAM,IAAIpL,UAAJ,iCAA6C0a,MAAMtP,QAAnD,YAAkEA,QAAlE,CAAN;AACD;AACD,MAAIsP,MAAMzM,IAAN,KAAeA,IAAnB,EAAyB;AACvB,UAAM,IAAIjO,UAAJ,oCAAgD0a,MAAMzM,IAAtD,YAAiEA,IAAjE,CAAN;AACD;AACD+Q,gBAAc5G,KAAd,EAAqBhN,QAArB,EAA+BzK,GAA/B,EAAoC+Z,KAApC;;AAEA,MAAIA,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,MAA2BH,SAA/B,EAA0C;AACxC,UAAM,IAAIQ,UAAJ,oBAAgCW,GAAhC,8BAA4DhB,IAA5D,CAAN;AACD;AACD,SAAO+a,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,CAAP;AACD;;AAED;;;;AAIA,SAASqf,aAAT,CAAuB5G,KAAvB,EAA8BhN,QAA9B,EAAwCzK,GAAxC,EAA6C+Z,KAA7C,EAAoD;AAClD,MAAI,CAACA,KAAL,EAAY;AACZ,MAAIA,MAAM1M,KAAN,KAAgBxO,SAApB,EAA+B;AAC7Bkb,UAAM1M,KAAN,GAAc,EAAd;AACD;AACD,MAAI0M,MAAM1M,KAAN,CAAYrN,GAAZ,MAAqBnB,SAAzB,EAAoC;AAClCkb,UAAM1M,KAAN,CAAYrN,GAAZ,IAAmB,EAAnB;AACD;;AAED,MAAMJ,MAAM,EAAZ;AATkD;AAAA;AAAA;;AAAA;AAUlD,0BAAeiY,YAAYJ,KAAZ,EAAmBhN,QAAnB,EAA6BzK,GAA7B,CAAf,mIAAkD;AAAA,UAAzCF,EAAyC;;AAChD,UAAMd,OAAOc,GAAGiY,GAAH,CAAO,MAAP,CAAb;AACAnY,UAAIZ,IAAJ,IAAY,IAAZ;;AAEA,UAAIc,GAAGiY,GAAH,CAAO,QAAP,MAAqB,KAAzB,EAAgC;AAC9BgC,cAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,IAAyB,EAACJ,OAAOkB,GAAGiY,GAAH,CAAO,OAAP,CAAR,EAAzB;AACA,YAAIjY,GAAGiY,GAAH,CAAO,UAAP,CAAJ,EAAwB;AACtBgC,gBAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,EAAuB+C,QAAvB,GAAkCjC,GAAGiY,GAAH,CAAO,UAAP,CAAlC;AACD;AACF,OALD,MAKO,IAAI2F,UAAU5d,EAAV,CAAJ,EAAmB;AACxB,YAAI,CAACia,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,CAAL,EAA6B;AAC3B,cAAMmO,UAAUqP,WAAW1c,EAAX,CAAhB;AACAia,gBAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,IAAyB,EAACyL,UAAU0C,OAAX,EAAoBG,MAAM+O,cAAc5E,KAAd,EAAqBtK,OAArB,CAA1B,EAAzB;AACD;AACF,OALM,MAKA;AACL,cAAM,IAAI9N,UAAJ,yCAAqDS,GAAGiY,GAAH,CAAO,QAAP,CAArD,CAAN;AACD;AACF;;AAED;AA7BkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AA8BlD,0BAAiB3a,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,CAAYrN,GAAZ,CAAZ,CAAjB,mIAAgD;AAAA,UAAvChB,IAAuC;;AAC9C,UAAI,CAACY,IAAIZ,IAAJ,CAAL,EAAgB;AACd,eAAO+a,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,CAAP;AACD;AACF;AAlCiD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCnD;;AAED;;;;;AAKA,SAASob,aAAT,CAAuB3C,KAAvB,EAA8BsC,KAA9B,EAAqC;AACnC,MAAI,CAACA,KAAD,IAAU,CAACA,MAAM1M,KAArB,EAA4B;;AAE5B,MAAI0M,MAAMzM,IAAN,KAAe,MAAf,IAAyByM,MAAMzM,IAAN,KAAe,MAA5C,EAAoD;AAClD,QAAM+K,UAAUZ,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAauB,MAAMtP,QAAnB,EAA6B,UAA7B,CAAZ,CAAhB;AACA,QAAM+T,WAAW,EAAjB;AAFkD;AAAA;AAAA;;AAAA;AAGlD,4BAAmBphB,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAlB,CAAnB,mIAA6C;AAAA,YAApC6P,MAAoC;;AAC3C,YAAI,WAAWlJ,IAAX,CAAgBkJ,MAAhB,CAAJ,EAA6B;AAC3BsB,mBAAStB,MAAT,IAAmBnD,MAAM1M,KAAN,CAAY6P,MAAZ,CAAnB;AACD,SAFD,MAEO,IAAI9f,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,CAAY6P,MAAZ,CAAZ,EAAiCzc,MAAjC,GAA0C,CAA9C,EAAiD;AACtD,cAAM4K,QAAQgN,QAAQvZ,OAAR,CAAgBoe,MAAhB,CAAd;AACA,cAAI7R,QAAQ,CAAZ,EAAe,MAAM,IAAIhM,UAAJ,iCAA6C6d,MAA7C,CAAN;AACfsB,mBAASnT,KAAT,IAAkB0O,MAAM1M,KAAN,CAAY6P,MAAZ,CAAlB;AACD;AACF;AAXiD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYlDnD,UAAM1M,KAAN,GAAcmR,QAAd;AACD;;AAhBkC;AAAA;AAAA;;AAAA;AAkBnC,0BAAgBphB,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAlB,CAAhB,mIAA0C;AAAA,UAAjCrN,GAAiC;AAAA;AAAA;AAAA;;AAAA;AACxC,8BAAiB5C,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,CAAYrN,GAAZ,CAAZ,CAAjB,mIAAgD;AAAA,cAAvChB,IAAuC;;AAC9Cob,wBAAc3C,KAAd,EAAqBsC,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,CAArB;AACD;AAHuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIzC;AAtBkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBpC;;AAED;;;;AAIA,SAAS+T,QAAT,CAAkB0E,KAAlB,EAAyB9X,MAAzB,EAAiCoa,KAAjC,EAAwC;AACtC,MAAM3b,QAAQuB,OAAOoY,GAAP,CAAW,OAAX,CAAd;AAAA,MAAmC1Z,MAAMsB,OAAOoY,GAAP,CAAW,KAAX,CAAzC;AAAA,MAA4DpX,UAAUhB,OAAOoY,GAAP,CAAW,SAAX,CAAtE;AACA,MAAI0G,aAAa5C,KAAjB;AACAlc,SAAOoY,GAAP,CAAW,KAAX,EAAkBJ,OAAlB,CAA0B,UAAC7X,EAAD,EAAKuL,KAAL,EAAe;AACvC,QAAMvO,SAASgD,GAAGiY,GAAH,CAAO,QAAP,CAAf;AAAA,QAAiChY,MAAMD,GAAGiY,GAAH,CAAO,KAAP,CAAvC;AAAA,QAAsDlb,SAASiD,GAAGiY,GAAH,CAAO,QAAP,CAA/D;AACA,QAAI,CAAC,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,MAAtB,EAA8B,SAA9B,EAAyC,UAAzC,EAAqD,UAArD,EAAiE,WAAjE,EAA8Ea,QAA9E,CAAuF9b,MAAvF,CAAL,EAAqG;AACnG,YAAM,IAAIuC,UAAJ,gCAA4CvC,MAA5C,CAAN;AACD;AACD,QAAI,CAACgD,GAAGiY,GAAH,CAAO,MAAP,CAAL,EAAqB;AACnB,YAAM,IAAI1Y,UAAJ,0CAAoDS,EAApD,CAAN;AACD;;AAED,QAAI4e,aAAa3E,KAAjB;AACA,QAAIA,KAAJ,EAAW;AAAA;AAAA;AAAA;;AAAA;AACT,8BAAmBkC,QAAQxE,KAAR,EAAe1X,GAAf,CAAnB,mIAAwC;AAAA,cAA/Bwe,MAA+B;;AACtCG,uBAAaJ,gBAAgB7G,KAAhB,EAAuB8G,MAAvB,EAA+BG,UAA/B,CAAb;AACD;AAHQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIV;;AAED,QAAMC,WAAW7e,GAAG8e,KAAH,CAAS,EAAC5f,MAAS2B,UAAU0K,KAAnB,SAA4BjN,KAA7B,EAAT,CAAjB;AACA,QAAIvB,MAAJ,EAAY;AACV4a,cAAQqF,YAAYrF,KAAZ,EAAmBkH,QAAnB,CAAR;AACD;AACD,QAAI7hB,OAAO4N,UAAP,CAAkB,MAAlB,CAAJ,EAA+B;AAC7B+T,mBAAaA,WAAWP,GAAX,CAAe1B,WAAWmC,QAAX,CAAf,CAAb;AACD;AACD,QAAI,CAACF,WAAWI,QAAX,CAAoB9e,GAApB,CAAL,EAA+B;AAC7B0X,cAAQ+F,kBAAkB/F,KAAlB,EAAyBkH,QAAzB,CAAR;AACD;AACDlH,YAAQkG,YAAYlG,KAAZ,EAAmBkH,QAAnB,EAA6BD,UAA7B,CAAR;AACD,GA3BD;AA4BA,SAAOjH,KAAP;AACD;;AAED;;;;;AAKA,SAASqH,WAAT,CAAqBrH,KAArB,EAA4B1N,YAA5B,EAA0CgQ,KAA1C,EAAiD;AAC/C,MAAMpa,SAASmc,OAAOxS,aAAaS,YAAb,CAAP,CAAf;AACA,MAAM3L,QAAQuB,OAAOoY,GAAP,CAAW,OAAX,CAAd;AAAA,MAAmC1Z,MAAMsB,OAAOoY,GAAP,CAAW,KAAX,CAAzC;AAAA,MAA4DpX,UAAUhB,OAAOoY,GAAP,CAAW,SAAX,CAAtE;AAAA,MAA6FlQ,OAAOlI,OAAOoY,GAAP,CAAW,MAAX,CAApG;AACA,MAAI,OAAO3Z,KAAP,KAAiB,QAAjB,IAA6B,OAAOC,GAAP,KAAe,QAA5C,IAAwD,OAAOsC,OAAP,KAAmB,QAA/E,EAAyF;AACvF,UAAM,IAAIuI,SAAJ,uCAAkD9K,KAAlD,gBAAkEC,GAAlE,oBAAoFsC,OAApF,CAAN;AACD;AACD,MAAI8W,MAAMuE,KAAN,CAAY,CAAC,QAAD,EAAWnU,IAAX,CAAZ,CAAJ,EAAmC,OAAO4P,KAAP,CANY,CAMC;;AAEhD,MAAMsH,cAActH,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAWpa,KAAX,CAAZ,EAA+B8Y,MAA/B,EAAuCwC,IAAvC,GAA8C,CAAlE;AACA,MAAIrb,QAAQ0gB,WAAZ,EAAyB;AACvB,UAAM,IAAI1f,UAAJ,sBAAkC0f,WAAlC,YAAoD3gB,KAApD,qBAAyEC,GAAzE,CAAN;AACD;;AAED,MAAI2gB,UAAU,CAAd;AAb+C;AAAA;AAAA;;AAAA;AAc/C,0BAAoBrf,OAAOoY,GAAP,CAAW,MAAX,CAApB,mIAAwC;AAAA,UAA/BkH,OAA+B;;AACtCD,gBAAU1T,KAAKiJ,GAAL,CAASyK,OAAT,EAAkBvH,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAWyG,OAAX,EAAoB,SAApB,CAAZ,CAAlB,CAAV;AACAxH,cAAQA,MAAMsF,QAAN,CAAe,CAAC,QAAD,EAAWkC,OAAX,EAAoB,YAApB,CAAf,EAAkDpD,KAAlD,EAAyD;AAAA,eAAUqD,OAAOhB,GAAP,CAAWrW,IAAX,CAAV;AAAA,OAAzD,CAAR;AACD;AAjB8C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkB/C,MAAIlH,YAAYqe,UAAU,CAA1B,EAA6B;AAC3B,UAAM,IAAI3f,UAAJ,8BAAyC2f,UAAU,CAAnD,eAA6Dre,OAA7D,CAAN;AACD;;AAED,MAAIwe,QAAQxf,OAAOoY,GAAP,CAAW,MAAX,CAAZ;AAAA,MAAgCqH,eAAgB/gB,QAAQ,CAAxD;AACA,SAAO,CAAC+gB,YAAD,IAAiB,CAACD,MAAMrF,OAAN,EAAzB,EAA0C;AACxC,QAAMhO,MAAM2L,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAW2G,MAAMhD,KAAN,EAAX,CAAZ,CAAZ;AACAgD,YAAQA,MAAMjK,KAAN,EAAR;AACA,QAAIpJ,IAAIiM,GAAJ,CAAQ,OAAR,MAAqB3Z,KAArB,IAA8B0N,IAAIiM,GAAJ,CAAQ,KAAR,MAAmB1Z,MAAM,CAA3D,EAA8D;AAC5D+gB,qBAAe,IAAf;AACD,KAFD,MAEO;AACLD,cAAQA,MAAM7e,MAAN,CAAawL,IAAIiM,GAAJ,CAAQ,UAAR,CAAb,CAAR;AACD;AACF;AACD,MAAI,CAACqH,YAAL,EAAmB;AACjB,UAAM,IAAI/f,UAAJ,CAAe,oEAAf,CAAN;AACD;;AAED,MAAMggB,aAAapI,IAAI;AACrB7Y,gBADqB,EACdC,QADc,EACTsC,gBADS;AAErBhB,YAAQoK,YAFa;AAGrBiV,aAASre,UAAUhB,OAAOoY,GAAP,CAAW,KAAX,EAAkB2B,IAA5B,GAAmC,CAHvB;AAIrB4F,cAAU3f,OAAOoY,GAAP,CAAW,MAAX,EAAmBwH,KAAnB,EAJW;AAKrBC,gBAAY3D;AALS,GAAJ,CAAnB;;AAQApE,UAAQ1E,SAAS0E,KAAT,EAAgB9X,MAAhB,EAAwBoa,KAAxB,CAAR;AACA,SAAOtC,MACJoF,KADI,CACE,CAAC,QAAD,EAAWhV,IAAX,CADF,EACoBwX,UADpB,EAEJtC,QAFI,CAEK,CAAC,QAAD,EAAW3e,KAAX,CAFL,EAEwB8Y,MAFxB,EAEgC;AAAA,WAASuI,MAAMtf,IAAN,CAAW0H,IAAX,CAAT;AAAA,GAFhC,EAGJF,MAHI,CAGG,MAHH,EAGW;AAAA,WAAQf,KAAK8Y,QAAL,CAAc/f,OAAOoY,GAAP,CAAW,MAAX,CAAd,EAAkCmG,GAAlC,CAAsCrW,IAAtC,CAAR;AAAA,GAHX,EAIJF,MAJI,CAIG,OAJH,EAIY;AAAA,WAAS2D,KAAKiJ,GAAL,CAASjW,KAAT,EAAgB+gB,WAAWtH,GAAX,CAAe,SAAf,CAAhB,CAAT;AAAA,GAJZ,EAKJpQ,MALI,CAKG,SALH,EAKc;AAAA,WAAWgY,QAAQxf,IAAR,CAAa0H,IAAb,CAAX;AAAA,GALd,CAAP;AAMD;;AAED,SAAS+X,cAAT,CAAwBnI,KAAxB,EAA+BsC,KAA/B,EAAsC;AACpC,MAAIoF,QAAQjI,MAAZ;AACA,SAAO,IAAP,EAAa;AAAA;AAAA;AAAA;;AAAA;AACX,6BAAmBO,MAAMM,GAAN,CAAU,OAAV,CAAnB,wIAAuC;AAAA,YAA9BpY,MAA8B;;AACrC,YAAIoc,cAActE,KAAd,EAAqBlO,iBAAiB5J,MAAjB,EAAyB,KAAzB,CAArB,CAAJ,EAA2D;AACzD8X,kBAAQqH,YAAYrH,KAAZ,EAAmB9X,MAAnB,EAA2Boa,KAA3B,CAAR;AACD,SAFD,MAEO;AACLoF,kBAAQA,MAAMhf,IAAN,CAAWR,MAAX,CAAR;AACD;AACF;AAPU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASX,QAAIwf,MAAMlZ,KAAN,OAAkBwR,MAAMM,GAAN,CAAU,OAAV,EAAmB9R,KAAnB,EAAtB,EAAkD,OAAOwR,KAAP;AAClDA,YAAQA,MAAMzP,GAAN,CAAU,OAAV,EAAmBmX,KAAnB,CAAR;AACAA,YAAQjI,MAAR;AACD;AACF;;AAED,SAAS2I,eAAT,CAAyBpI,KAAzB,EAAgC;AAC9B,MAAM4D,UAAU5D,MAAMM,GAAN,CAAU,SAAV,CAAhB;AACA,SAAON,MACJ9P,MADI,CACG,WADH,EACgB,iBAAS;AAC5B,WAAOkD,MACJ9B,KADI,CACE,CADF,EACKsS,OADL,EAEJlb,IAFI,CAECsX,MAAMM,GAAN,CAAU,WAAV,CAFD,CAAP;AAGD,GALI,EAMJ/P,GANI,CAMA,SANA,EAMWqT,UAAU,CANrB,EAOJrT,GAPI,CAOA,WAPA,EAOakP,MAPb,EAQJwE,MARI,CAQG,WARH,CAAP;AASD;;AAED,SAAS7C,IAAT,GAAgB;AACd,SAAO5B,MACJjP,GADI,CACA,QADA,EACYiP,KADZ,EAEJjP,GAFI,CAEA,SAFA,EAEYkP,MAFZ,EAGJlP,GAHI,CAGA,UAHA,EAGYiP,MAAMjP,GAAN,CAAUpO,OAAV,EAAmBqd,MAAMjP,GAAN,CAAU,OAAV,EAAmBiP,KAAnB,CAAnB,CAHZ,EAIJjP,GAJI,CAIA,QAJA,EAIYiP,KAJZ,EAKJjP,GALI,CAKA,MALA,EAKY6T,KALZ,EAMJ7T,GANI,CAMA,OANA,EAMa,CANb,EAOJA,GAPI,CAOA,SAPA,EAOa,CAPb,EAQJA,GARI,CAQA,WARA,EAQakP,MARb,EASJlP,GATI,CASA,WATA,EASakP,MATb,EAUJlP,GAVI,CAUA,OAVA,EAUYkP,MAVZ,CAAP;AAWD;;AAED;;;;;;AAMA,SAASiD,SAAT,CAAmB1C,KAAnB,EAA0B9X,MAA1B,EAAkCoa,KAAlC,EAAyC;AACvCtC,UAAQA,MAAM9P,MAAN,CAAa,OAAb,EAAsB;AAAA,WAASwX,MAAMhf,IAAN,CAAWR,MAAX,CAAT;AAAA,GAAtB,CAAR;AACA,SAAOigB,eAAenI,KAAf,EAAsBsC,KAAtB,CAAP;AACD;;AAED;;;;;;AAMA,SAASG,cAAT,CAAwBzC,KAAxB,EAA+B9X,MAA/B,EAAuCsa,UAAvC,EAAmDF,KAAnD,EAA0D;AACxD,MAAIE,UAAJ,EAAgB;AACdxC,YAAQA,MAAMzP,GAAN,CAAU,WAAV,EAAuBkP,MAAvB,CAAR,CADc,CACyB;AACvCO,YAAQqH,YAAYrH,KAAZ,EAAmB9X,MAAnB,EAA2Boa,KAA3B,CAAR;AACAtC,YAAQoI,gBAAgBpI,KAAhB,CAAR;AACD,GAJD,MAIO;AACLA,YAAQqH,YAAYrH,KAAZ,EAAmB9X,MAAnB,EAA2Boa,KAA3B,CAAR;AACD;AACD,SAAOtC,KAAP;AACD;;AAED;;;;;;;;;;;;;AAaA,SAAS0D,iBAAT,CAA2B1D,KAA3B,EAAkCyD,QAAlC,EAA4C;AAC1C,MAAIrQ,QAAQqQ,QAAZ;AAAA,MAAsB4E,aAAa,EAAnC;AACA,SAAO,CAACjV,MAAMiP,OAAN,EAAR,EAAyB;AACvB,QAAMjS,OAAOgD,MAAM0O,IAAN,EAAb;AACA,QAAM3S,OAAO6Q,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAW3Q,IAAX,EAAiB,UAAjB,CAAZ,CAAb;AACA,QAAI,CAACjB,IAAL,EAAW,MAAM,IAAIvH,UAAJ,sBAAkCwI,IAAlC,CAAN;AACXgD,YAAQA,MAAMC,GAAN,GAAYxK,MAAZ,CAAmBsG,IAAnB,CAAR;AACAkZ,eAAWjY,IAAX,IAAmB,IAAnB;AACD;;AAED,SAAO4P,MAAMM,GAAN,CAAU,SAAV,EACJxX,MADI,CACG;AAAA,WAAQ,CAACuf,WAAWjY,IAAX,CAAT;AAAA,GADH,EAEJhI,GAFI,CAEA;AAAA,WAAQ4X,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAW3Q,IAAX,EAAiB,QAAjB,CAAZ,CAAR;AAAA,GAFA,EAGJ8R,MAHI,EAAP;AAID;;AAED,SAASsB,kBAAT,CAA4BxD,KAA5B,EAAmCsI,QAAnC,EAA6CC,QAA7C,EAAuD;AACrDA,aAAWA,YAAY,CAAvB;;AAEA,SAAOvI,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAWuH,QAAX,CAAZ,EAAkC7I,MAAlC,EACJN,IADI,CACCoJ,QADD,EAEJngB,GAFI,CAEA;AAAA,WAAQ4X,MAAMe,KAAN,CAAY,CAAC,QAAD,EAAW3Q,IAAX,EAAiB,QAAjB,CAAZ,CAAR;AAAA,GAFA,EAGJ8R,MAHI,EAAP;AAID;;AAED,SAASyB,cAAT,CAAwB3D,KAAxB,EAA+B;AAC7B,MAAIwI,UAAU,EAAd;AAAA,MAAkBC,UAAU,EAA5B;AAD6B;AAAA;AAAA;;AAAA;AAE7B,2BAAyBzI,MAAMM,GAAN,CAAU,OAAV,CAAzB,wIAA6C;AAAA,UAApChO,YAAoC;;AAC3C,UAAMpK,SAAS4J,iBAAiBQ,YAAjB,EAA+B,IAA/B,CAAf;AACAmW,cAAQvgB,OAAOkI,IAAf,IAAuB,IAAvB;AAF2C;AAAA;AAAA;;AAAA;AAG3C,+BAAoBlI,OAAOiH,IAA3B,wIAAiC;AAAA,cAAxBqY,OAAwB;;AAC/B,cAAI,CAACxH,MAAMuE,KAAN,CAAY,CAAC,QAAD,EAAWiD,OAAX,CAAZ,CAAL,EAAuCgB,QAAQhB,OAAR,IAAmB,IAAnB;AACxC;AAL0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAM5C;AAR4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAS7B,SAAO7hB,OAAOgD,IAAP,CAAY6f,OAAZ,EAAqB1f,MAArB,CAA4B;AAAA,WAAQ,CAAC2f,QAAQrY,IAAR,CAAT;AAAA,GAA5B,EAAoDxH,IAApD,EAAP;AACD;;AAED,SAASwX,WAAT,CAAqBJ,KAArB,EAA4BhN,QAA5B,EAAsCzK,GAAtC,EAA2C;AACzC,SAAOyX,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,OAAvB,EAAgCzK,GAAhC,CAAZ,EAAkDkX,MAAlD,CAAP;AACD;;AAED,SAASiJ,SAAT,CAAmB1I,KAAnB,EAA0BhN,QAA1B,EAAoCzK,GAApC,EAAyC;AACvC,MAAIA,QAAQ,OAAZ,EAAqB;AACrB,MAAMogB,YAAY3I,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,YAAvB,EAAqCzK,GAArC,CAAZ,CAAlB;AACA,MAAI,CAACogB,SAAL,EAAgB,MAAM,IAAIlX,SAAJ,2CAAsDlJ,GAAtD,CAAN;AAChB,SAAOogB,UAAUrI,GAAV,CAAc,KAAd,CAAP;AACD;;AAED,SAASoG,cAAT,CAAwB3S,GAAxB,EAA6BC,GAA7B,EAAkC;AAChC,MAAM4U,QAAQvmB,UAAU0R,IAAIuM,GAAJ,CAAQ,MAAR,CAAV,CAAd;AAAA,MAA0CuI,QAAQxmB,UAAU2R,IAAIsM,GAAJ,CAAQ,MAAR,CAAV,CAAlD;AACA,MAAIsI,MAAMlhB,OAAN,GAAgBmhB,MAAMnhB,OAA1B,EAAmC,OAAO,CAAC,CAAR;AACnC,MAAIkhB,MAAMlhB,OAAN,GAAgBmhB,MAAMnhB,OAA1B,EAAmC,OAAQ,CAAR;AACnC,MAAIkhB,MAAMnhB,OAAN,GAAgBohB,MAAMphB,OAA1B,EAAmC,OAAO,CAAC,CAAR;AACnC,MAAImhB,MAAMnhB,OAAN,GAAgBohB,MAAMphB,OAA1B,EAAmC,OAAQ,CAAR;AACnC,SAAO,CAAP;AACD;;AAED,SAASqhB,eAAT,CAAyB9I,KAAzB,EAAgChN,QAAhC,EAA0C+V,QAA1C,EAAoDrT,OAApD,EAA6D;AAC3D,MAAIsT,WAAW,IAAf;AACA,MAAItT,OAAJ,EAAasT,WAAWxJ,IAAI,EAACjY,MAAMmO,OAAP,EAAJ,CAAX;;AAEb,SAAOsK,MACJe,KADI,CACE,CAAC,UAAD,EAAa/N,QAAb,EAAuB,YAAvB,EAAqC+V,QAArC,CADF,EACkDtJ,MADlD,EAEJ3W,MAFI,CAEG;AAAA,WAAMT,GAAGiY,GAAH,CAAO,QAAP,MAAqB,CAAC0I,QAAD,IAAatC,eAAere,EAAf,EAAmB2gB,QAAnB,IAA+B,CAAjE,CAAN;AAAA,GAFH,EAGJpgB,IAHI,CAGC8d,cAHD,EAIJC,OAJI,GAIM;AAJN,GAKJve,GALI,CAKA;AAAA,WAAMC,GAAGiY,GAAH,CAAO,MAAP,CAAN;AAAA,GALA,CAAP;AAMD;;AAED,SAAS2I,OAAT,CAAiBjJ,KAAjB,EAAwBhN,QAAxB,EAAkCzK,GAAlC,EAAuC;AACrC,MAAM2gB,WAAWJ,gBAAgB9I,KAAhB,EAAuBhN,QAAvB,EAAiCzK,GAAjC,CAAjB;AACA,MAAI,CAAC2gB,SAAS7G,OAAT,EAAL,EAAyB,OAAO6G,SAASxE,KAAT,EAAP;;AAEzB,MAAIyE,iBAAJ;AACA,SAAO,IAAP,EAAa;AACXA,eAAWT,UAAU1I,KAAV,EAAiBhN,QAAjB,EAA2BzK,GAA3B,CAAX;AACA,QAAI,CAAC4gB,QAAL,EAAe;AACf,QAAMC,WAAWN,gBAAgB9I,KAAhB,EAAuBhN,QAAvB,EAAiCmW,QAAjC,EAA2C5gB,GAA3C,CAAjB;AACA,QAAI,CAAC6gB,SAAS/G,OAAT,EAAL,EAAyB,OAAO+G,SAAS1E,KAAT,EAAP;AACzBnc,UAAM4gB,QAAN;AACD;AACF;;AAED;AACA;AACA,SAAStD,WAAT,CAAqB7F,KAArB,EAA4BhN,QAA5B,EAAsCzK,GAAtC,EAA2C;AACzC,MAAMwgB,WAAWL,UAAU1I,KAAV,EAAiBhN,QAAjB,EAA2BzK,GAA3B,CAAjB;AACA,MAAI2gB,WAAWJ,gBAAgB9I,KAAhB,EAAuBhN,QAAvB,EAAiC+V,QAAjC,CAAf;AACA,MAAIG,SAASxE,KAAT,OAAqBnc,GAAzB,EAA8B;AAC5B,QAAIwgB,aAAa,OAAjB,EAA0B,OAAO,IAAP,CAA1B,KAA4C,OAAOA,QAAP;AAC7C;;AAED,MAAInD,eAAJ;AAPyC;AAAA;AAAA;;AAAA;AAQzC,2BAAkBsD,QAAlB,wIAA4B;AAAA,UAAnB1gB,KAAmB;;AAC1B,UAAIA,UAAUD,GAAd,EAAmB;AACnBqd,eAASpd,KAAT;AACD;AAXwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYzC,SAAO,IAAP,EAAa;AACX0gB,eAAWJ,gBAAgB9I,KAAhB,EAAuBhN,QAAvB,EAAiC4S,MAAjC,CAAX;AACA,QAAIsD,SAAS7G,OAAT,EAAJ,EAAwB,OAAOuD,MAAP;AACxBA,aAASsD,SAASpH,IAAT,EAAT;AACD;AACF;;AAED,SAASuH,cAAT,CAAwBrJ,KAAxB,EAA+B3X,EAA/B,EAAmC;AACjC,MAAI4d,UAAU5d,EAAV,CAAJ,EAAmB;AACjB,WAAO8d,gBAAgBnG,KAAhB,EAAuB+E,WAAW1c,EAAX,CAAvB,CAAP;AACD,GAFD,MAEO,IAAIA,GAAGiY,GAAH,CAAO,QAAP,MAAqB,KAAzB,EAAgC;AACrC,QAAMlU,SAAS,EAACjF,OAAOkB,GAAGiY,GAAH,CAAO,OAAP,CAAR,EAAf;AACA,QAAIjY,GAAGiY,GAAH,CAAO,UAAP,CAAJ,EAAwBlU,OAAO9B,QAAP,GAAkBjC,GAAGiY,GAAH,CAAO,UAAP,CAAlB;AACxB,WAAOlU,MAAP;AACD,GAJM,MAIA;AACL,UAAM,IAAIqF,SAAJ,mCAA8CpJ,GAAGiY,GAAH,CAAO,QAAP,CAA9C,CAAN;AACD;AACF;;AAED,SAASgJ,YAAT,CAAsBtJ,KAAtB,EAA6BhN,QAA7B,EAAuC6C,IAAvC,EAA6C;AAC3C,MAAMyM,QAAQ,EAACtP,kBAAD,EAAW6C,UAAX,EAAiBD,OAAO,EAAxB,EAAd;AAD2C;AAAA;AAAA;;AAAA;AAE3C,2BAA4BoK,MAAMe,KAAN,CAAY,CAAC,UAAD,EAAa/N,QAAb,EAAuB,OAAvB,CAAZ,EAA6C3M,OAA7C,EAA5B,wIAAoF;AAAA;;AAAA;;AAAA,UAA1EkC,GAA0E;AAAA,UAArE4X,QAAqE;;AAClF,UAAI,CAACA,SAASkC,OAAT,EAAL,EAAyB;AACvBC,cAAM1M,KAAN,CAAYrN,GAAZ,IAAmB,EAAnB;AADuB;AAAA;AAAA;;AAAA;AAEvB,iCAAe4X,QAAf,wIAAyB;AAAA,gBAAhB9X,EAAgB;;AACvBia,kBAAM1M,KAAN,CAAYrN,GAAZ,EAAiBF,GAAGiY,GAAH,CAAO,MAAP,CAAjB,IAAmC+I,eAAerJ,KAAf,EAAsB3X,EAAtB,CAAnC;AACD;AAJsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKxB;AACF;AAT0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU3C,SAAOia,KAAP;AACD;;AAED,SAASiH,aAAT,CAAuBvJ,KAAvB,EAA8BhN,QAA9B,EAAwC6C,IAAxC,EAA8C;AAC5C,MAAMyM,QAAQ,EAACtP,kBAAD,EAAW6C,UAAX,EAAiBD,OAAO,EAAxB,EAA4BE,OAAO,EAAnC,EAAd;AACA,MAAI2P,SAAS,OAAb;AAAA,MAAsB7R,QAAQ,CAA9B;AAAA,MAAiC4V,aAAa,CAA9C;;AAEA,SAAO,IAAP,EAAa;AACX/D,aAASwD,QAAQjJ,KAAR,EAAehN,QAAf,EAAyByS,MAAzB,CAAT;AACA,QAAI,CAACA,MAAL,EAAa;AACX,aAAOnD,KAAP;AACD;AACDkH,iBAAa3V,KAAKiJ,GAAL,CAAS0M,UAAT,EAAqBnnB,UAAUojB,MAAV,EAAkB/d,OAAvC,CAAb;;AAEA,QAAMyY,WAAWC,YAAYJ,KAAZ,EAAmBhN,QAAnB,EAA6ByS,MAA7B,CAAjB;AACA,QAAI,CAACtF,SAASkC,OAAT,EAAL,EAAyB;AACvBC,YAAMxM,KAAN,CAAYpN,IAAZ,CAAiB,EAACrD,QAAQ,QAAT,EAAmBuO,YAAnB,EAAjB;AACA0O,YAAM1M,KAAN,CAAYhC,KAAZ,IAAqB,EAArB;AAFuB;AAAA;AAAA;;AAAA;AAGvB,+BAAeuM,QAAf,wIAAyB;AAAA,cAAhB9X,EAAgB;;AACvBia,gBAAM1M,KAAN,CAAYhC,KAAZ,EAAmBvL,GAAGiY,GAAH,CAAO,MAAP,CAAnB,IAAqC+I,eAAerJ,KAAf,EAAsB3X,EAAtB,CAArC;AACD;AALsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMvBuL,eAAS,CAAT;AACD;AACF;AACF;;AAED,SAASuS,eAAT,CAAyBnG,KAAzB,EAAgChN,QAAhC,EAA0C;AACxC,MAAM6C,OAAO+O,cAAc5E,KAAd,EAAqBhN,QAArB,CAAb;AACA,MAAI6C,SAAS,KAAT,IAAkBA,SAAS,OAA/B,EAAwC;AACtC,WAAOyT,aAAatJ,KAAb,EAAoBhN,QAApB,EAA8B6C,IAA9B,CAAP;AACD,GAFD,MAEO,IAAIA,SAAS,MAAT,IAAmBA,SAAS,MAAhC,EAAwC;AAC7C,WAAO0T,cAAcvJ,KAAd,EAAqBhN,QAArB,EAA+B6C,IAA/B,CAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAIjO,UAAJ,2BAAuCiO,IAAvC,CAAN;AACD;AACF;;AAED0F,OAAOC,OAAP,GAAiB;AACf4F,YADe,EACTsB,oBADS,EACED,8BADF,EACkBiB,oCADlB,EACqCF,sCADrC,EACyDG,8BADzD;AAEfwC,kCAFe,EAEE/F,wBAFF,EAEe4D,gCAFf,EAEgCrB,4BAFhC,EAE+CxgB;AAF/C,CAAjB,C;;;;;;;;;;;;;;;;;;;;eC3qBgBD,mBAAOA,CAAC,6DAAR,C;IAARsd,G,YAAAA,G;;AAER;AACA;AACA;AACA;;;AACA,SAASiK,WAAT,GAAuB;AACrB;AACA;AACA;AACA,SAAO;AACLC,QADK,kBACE;AACL;AACA,UAAMC,OAAO9V,KAAKC,KAAL,CAAWD,KAAK+V,MAAL,KAAgB,WAA3B,CAAb;AACA;AACA,UAAIC,QAAQ,CAAZ;AACA,aAAOF,OAAO,KAAM,KAAK,IAAIE,KAAtB,IAAgCA,QAAQ,EAA/C;AAAmDA,iBAAS,CAAT;AAAnD,OACA,OAAO,EAAE1iB,OAAO0iB,KAAT,EAAgB1b,MAAM,KAAtB,EAAP;AACD;AARI,GAAP;AAUD;;IAEK2b,I;AACJ,gBAAavhB,GAAb,EAAkBpB,KAAlB,EAAyB0iB,KAAzB,EAAgCE,OAAhC,EAAyCC,OAAzC,EAAkDC,SAAlD,EAA6DC,SAA7D,EAAwE;AAAA;;AACtE,SAAK3hB,GAAL,GAAWA,GAAX;AACA,SAAKpB,KAAL,GAAaA,KAAb;AACA,SAAK0iB,KAAL,GAAaA,KAAb;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;;;;6BAES/iB,K,EAAO;AACf,aAAO,IAAI2iB,IAAJ,CAAS,KAAKvhB,GAAd,EAAmBpB,KAAnB,EAA0B,KAAK0iB,KAA/B,EAAsC,KAAKE,OAA3C,EAAoD,KAAKC,OAAzD,EACS,KAAKC,SADd,EACyB,KAAKC,SAD9B,CAAP;AAED;;;gCAEYC,M,EAAQC,Q,EAAUC,S,EAAWC,Q,EAAU;AAClD,UAAIF,WAAW,KAAKP,KAAhB,IAAyB,KAAKthB,GAAL,KAAa,IAA1C,EAAgD;AAC9C,cAAM,IAAIX,UAAJ,CAAe,8CAAf,CAAN;AACD;AACD,UAAM2iB,WAAW1W,KAAKiJ,GAAL,CAAS,KAAK+M,KAAd,EAAqBO,QAArB,CAAjB;AACA,UAAMJ,UAAU,KAAKA,OAAL,CAAa1Y,KAAb,EAAhB;AACA,UAAM4Y,YAAY,KAAKA,SAAL,CAAe5Y,KAAf,EAAlB;;AAEA,WAAK,IAAIuY,QAAQQ,SAAjB,EAA4BR,QAAQU,QAApC,EAA8CV,OAA9C,EAAuD;AACrD,YAAIA,QAAQO,QAAZ,EAAsB;AACpBJ,kBAAQH,KAAR,IAAiBM,MAAjB;AACAD,oBAAUL,KAAV,IAAmBS,QAAnB;AACD,SAHD,MAGO;AACLJ,oBAAUL,KAAV,KAAoB,CAApB;AACD;AACF;;AAED,aAAO,IAAIC,IAAJ,CAAS,KAAKvhB,GAAd,EAAmB,KAAKpB,KAAxB,EAA+BojB,QAA/B,EACS,KAAKR,OADd,EACuBC,OADvB,EACgC,KAAKC,SADrC,EACgDC,SADhD,CAAP;AAED;;;iCAEaC,M,EAAQC,Q,EAAUC,S,EAAWC,Q,EAAU;AACnD,UAAIF,WAAW,KAAKP,KAApB,EAA2B,MAAM,IAAIjiB,UAAJ,CAAe,4BAAf,CAAN;AAC3B,UAAMmiB,UAAU,KAAKA,OAAL,CAAazY,KAAb,EAAhB;AACA,UAAM2Y,YAAY,KAAKA,SAAL,CAAe3Y,KAAf,EAAlB;;AAEA,WAAK,IAAIuY,QAAQQ,SAAjB,EAA4BR,QAAQ,KAAKA,KAAzC,EAAgDA,OAAhD,EAAyD;AACvD,YAAIA,QAAQO,QAAZ,EAAsB;AACpBL,kBAAQF,KAAR,IAAiBM,MAAjB;AACAF,oBAAUJ,KAAV,IAAmBS,QAAnB;AACD,SAHD,MAGO;AACLL,oBAAUJ,KAAV,KAAoB,CAApB;AACD;AACF;;AAED,aAAO,IAAIC,IAAJ,CAAS,KAAKvhB,GAAd,EAAmB,KAAKpB,KAAxB,EAA+B,KAAK0iB,KAApC,EACSE,OADT,EACkB,KAAKC,OADvB,EACgCC,SADhC,EAC2C,KAAKC,SADhD,CAAP;AAED;;;gCAEYG,S,EAAWG,Y,EAAcC,O,EAASC,S,EAAW;AACxD,UAAMV,UAAU,KAAKA,OAAL,CAAa1Y,KAAb,EAAhB;AACA,UAAM4Y,YAAY,KAAKA,SAAL,CAAe5Y,KAAf,EAAlB;;AAEA,WAAK,IAAIuY,QAAQQ,SAAjB,EAA4BR,QAAQ,KAAKA,KAAzC,EAAgDA,OAAhD,EAAyD;AACvD,YAAIA,QAAQW,YAAZ,EAA0B;AACxBR,kBAAQH,KAAR,IAAiBY,QAAQZ,KAAR,CAAjB;AACAK,oBAAUL,KAAV,IAAmBa,UAAUb,KAAV,CAAnB;AACD,SAHD,MAGO;AACLK,oBAAUL,KAAV,KAAoB,CAApB;AACD;AACF;;AAED,aAAO,IAAIC,IAAJ,CAAS,KAAKvhB,GAAd,EAAmB,KAAKpB,KAAxB,EAA+B,KAAK0iB,KAApC,EACS,KAAKE,OADd,EACuBC,OADvB,EACgC,KAAKC,SADrC,EACgDC,SADhD,CAAP;AAED;;;iCAEaG,S,EAAWG,Y,EAAcC,O,EAASC,S,EAAW;AACzD,UAAMX,UAAU,KAAKA,OAAL,CAAazY,KAAb,EAAhB;AACA,UAAM2Y,YAAY,KAAKA,SAAL,CAAe3Y,KAAf,EAAlB;;AAEA,WAAK,IAAIuY,QAAQQ,SAAjB,EAA4BR,QAAQ,KAAKA,KAAzC,EAAgDA,OAAhD,EAAyD;AACvD,YAAIA,QAAQW,YAAZ,EAA0B;AACxBT,kBAAQF,KAAR,IAAiBY,QAAQZ,KAAR,CAAjB;AACAI,oBAAUJ,KAAV,IAAmBa,UAAUb,KAAV,CAAnB;AACD,SAHD,MAGO;AACLI,oBAAUJ,KAAV,KAAoB,CAApB;AACD;AACF;;AAED,aAAO,IAAIC,IAAJ,CAAS,KAAKvhB,GAAd,EAAmB,KAAKpB,KAAxB,EAA+B,KAAK0iB,KAApC,EACSE,OADT,EACkB,KAAKC,OADvB,EACgCC,SADhC,EAC2C,KAAKC,SADhD,CAAP;AAED;;;;;;IAGGvK,Q;AACJ,oBAAagL,YAAb,EAA2B;AAAA;;AACzB,QAAM3V,OAAO,IAAI8U,IAAJ,CAAS,IAAT,EAAe,IAAf,EAAqB,CAArB,EAAwB,EAAxB,EAA4B,CAAC,IAAD,CAA5B,EAAoC,EAApC,EAAwC,CAAC,IAAD,CAAxC,CAAb;AACA,QAAMF,SAASe,eAAeA,cAAf,GAAgClB,aAA/C;AACA,WAAOmB,aAAa,CAAb,EAAgBpL,MAAMjP,GAAN,CAAU,IAAV,EAAgByE,IAAhB,CAAhB,EAAuC4U,MAAvC,CAAP;AACD;;;;iCAMaiB,W,EAAaN,Q,EAAU;AACnC,UAAMO,UAAU,CAACD,WAAD,CAAhB;AAAA,UAA+BE,YAAY,CAAC,CAAD,CAA3C;;AAEA,WAAK,IAAIlB,QAAQ,CAAjB,EAAoBA,QAAQU,QAA5B,EAAsCV,OAAtC,EAA+C;AAC7C,YAAImB,SAASF,QAAQjB,QAAQ,CAAhB,CAAb;AACA,YAAIrb,QAAQuc,UAAUlB,QAAQ,CAAlB,CAAZ;AACA,eAAOmB,MAAP,EAAe;AACb,cAAIC,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB0K,MAAhB,CAAX;AACA,cAAIC,KAAKpB,KAAL,GAAaA,KAAjB,EAAwB;AACxB,cAAIoB,KAAKpB,KAAL,GAAaA,KAAjB,EAAwB;AACtB,kBAAM,IAAIjiB,UAAJ,CAAe,UAAUojB,MAAV,GAAmB,wBAAnB,IAA+CnB,QAAQ,CAAvD,CAAf,CAAN;AACD;AACDrb,mBAASyc,KAAKhB,SAAL,CAAeJ,QAAQ,CAAvB,CAAT;AACAmB,mBAASC,KAAKlB,OAAL,CAAaF,QAAQ,CAArB,CAAT;AACD;AACDiB,gBAAQjB,KAAR,IAAiBmB,MAAjB;AACAD,kBAAUlB,KAAV,IAAmBrb,KAAnB;AACD;;AAED,aAAO,EAACsc,gBAAD,EAAUC,oBAAV,EAAP;AACD;;;+BAEWI,S,EAAWZ,Q,EAAU;AAC/B,UAAMa,UAAU,CAACD,SAAD,CAAhB;AAAA,UAA6BE,YAAY,CAAC,CAAD,CAAzC;;AAEA,WAAK,IAAIxB,QAAQ,CAAjB,EAAoBA,QAAQU,QAA5B,EAAsCV,OAAtC,EAA+C;AAC7C,YAAIyB,SAASF,QAAQvB,QAAQ,CAAhB,CAAb;AACA,YAAIrb,QAAQ6c,UAAUxB,QAAQ,CAAlB,CAAZ;AACA,eAAOyB,MAAP,EAAe;AACb,cAAIL,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgBgL,MAAhB,CAAX;AACA,cAAIL,KAAKpB,KAAL,GAAaA,KAAjB,EAAwB;AACxB,cAAIoB,KAAKpB,KAAL,GAAaA,KAAjB,EAAwB;AACtB,kBAAM,IAAIjiB,UAAJ,CAAe,UAAU0jB,MAAV,GAAmB,wBAAnB,IAA+CzB,QAAQ,CAAvD,CAAf,CAAN;AACD;AACDrb,mBAASyc,KAAKf,SAAL,CAAeL,QAAQ,CAAvB,CAAT;AACAyB,mBAASL,KAAKjB,OAAL,CAAaH,QAAQ,CAArB,CAAT;AACD;AACDuB,gBAAQvB,KAAR,IAAiByB,MAAjB;AACAD,kBAAUxB,KAAV,IAAmBrb,KAAnB;AACD;;AAED,aAAO,EAAC4c,gBAAD,EAAUC,oBAAV,EAAP;AACD;;AAED;AACA;;;;gCACaR,W,EAAatiB,G,EAAKpB,K,EAAO;AACpC,UAAI,OAAOoB,GAAP,KAAe,QAAf,IAA2BA,QAAQ,EAAvC,EAA2C;AACzC,cAAM,IAAIX,UAAJ,CAAe,+BAAf,CAAN;AACD;AACD,UAAI,CAAC,KAAKsjB,MAAL,CAAYpK,GAAZ,CAAgB+J,WAAhB,CAAL,EAAmC;AACjC,cAAM,IAAIjjB,UAAJ,CAAe,+CAAf,CAAN;AACD;AACD,UAAI,KAAKsjB,MAAL,CAAYpK,GAAZ,CAAgBvY,GAAhB,CAAJ,EAA0B;AACxB,cAAM,IAAIX,UAAJ,CAAe,yCAAf,CAAN;AACD;;AAED,UAAMwiB,WAAW,KAAKmB,aAAL,CAAmB7B,IAAnB,GAA0BviB,KAA3C;AACA,UAAMojB,WAAW1W,KAAKiJ,GAAL,CAASsN,QAAT,EAAmB,KAAKoB,QAAL,CAAc3B,KAAjC,CAAjB;AACA,UAAMsB,YAAY,KAAKD,MAAL,CAAY5K,GAAZ,CAAgBuK,WAAhB,EAA6Bb,OAA7B,CAAqC,CAArC,KAA2C,IAA7D;;AAboC,0BAcL,KAAKyB,YAAL,CAAkBZ,WAAlB,EAA+BN,QAA/B,CAdK;AAAA,UAc5BO,OAd4B,iBAc5BA,OAd4B;AAAA,UAcnBC,SAdmB,iBAcnBA,SAdmB;;AAAA,wBAeL,KAAKW,UAAL,CAAgBP,SAAhB,EAA2BZ,QAA3B,CAfK;AAAA,UAe5Ba,OAf4B,eAe5BA,OAf4B;AAAA,UAenBC,SAfmB,eAenBA,SAfmB;;AAiBpC,aAAOT,aAAa,KAAK5hB,MAAL,GAAc,CAA3B,EAA8B,KAAKkiB,MAAL,CAAYnH,aAAZ,CAA0B,iBAAS;AACtE,YAAI4H,WAAW,CAAf;AAAA,YAAkBC,WAAW,CAA7B;;AADsE,mCAE7D/B,KAF6D;AAGpE,cAAMgC,cAAchY,KAAK8K,GAAL,CAASkL,KAAT,EAAgBO,QAAhB,CAApB;AACA,cAAIP,UAAUU,QAAV,IAAsBO,QAAQjB,KAAR,MAAmBiB,QAAQa,QAAR,CAA7C,EAAgE;AAC9DG,kBAAM5b,MAAN,CAAa4a,QAAQa,QAAR,CAAb,EACa;AAAA,qBAAQV,KAAKjK,WAAL,CAAiBzY,GAAjB,EAAsBsjB,WAAtB,EAAmCF,QAAnC,EAA6CZ,UAAUY,QAAV,CAA7C,CAAR;AAAA,aADb;AAEAA,uBAAW9B,KAAX;AACD;AACD,cAAIuB,QAAQQ,QAAR,MAAsB/B,UAAUU,QAAV,IAAsBa,QAAQvB,KAAR,MAAmBuB,QAAQQ,QAAR,CAA/D,CAAJ,EAAuF;AACrFE,kBAAM5b,MAAN,CAAakb,QAAQQ,QAAR,CAAb,EACa;AAAA,qBAAQX,KAAKc,YAAL,CAAkBxjB,GAAlB,EAAuBsjB,WAAvB,EAAoCD,QAApC,EAA8CP,UAAUO,QAAV,CAA9C,CAAR;AAAA,aADb;AAEAA,uBAAW/B,KAAX;AACD;AAbmE;;AAEtE,aAAK,IAAIA,QAAQ,CAAjB,EAAoBA,SAASU,QAA7B,EAAuCV,OAAvC,EAAgD;AAAA,gBAAvCA,KAAuC;AAY/C;;AAEDiC,cAAMvb,GAAN,CAAUhI,GAAV,EAAe,IAAIuhB,IAAJ,CAASvhB,GAAT,EAAcpB,KAAd,EAAqBijB,QAArB,EACSU,QAAQxZ,KAAR,CAAc,CAAd,EAAiB8Y,QAAjB,CADT,EAESgB,QAAQ9Z,KAAR,CAAc,CAAd,EAAiB8Y,QAAjB,CAFT,EAGSW,UAAUzZ,KAAV,CAAgB,CAAhB,EAAmB8Y,QAAnB,CAHT,EAISiB,UAAU/Z,KAAV,CAAgB,CAAhB,EAAmB8Y,QAAnB,CAJT,CAAf;AAKD,OArBoC,CAA9B,EAqBH,KAAKmB,aArBF,CAAP;AAsBD;;;gCAEY3X,K,EAAOrL,G,EAAKpB,K,EAAO;AAC9B,UAAI,OAAOyM,KAAP,KAAiB,QAAjB,IAA6BA,QAAQ,CAAzC,EAA4C;AAC1C,cAAM,IAAIhM,UAAJ,CAAe,sCAAf,CAAN;AACD;AACD,UAAIgM,UAAU,CAAd,EAAiB;AACf,eAAO,KAAKoN,WAAL,CAAiB,IAAjB,EAAuBzY,GAAvB,EAA4BpB,KAA5B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK6Z,WAAL,CAAiB,KAAKC,KAAL,CAAWrN,QAAQ,CAAnB,CAAjB,EAAwCrL,GAAxC,EAA6CpB,KAA7C,CAAP;AACD;AACF;;;8BAEUoB,G,EAAK;AACd,UAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAAC,KAAK2iB,MAAL,CAAYpK,GAAZ,CAAgBvY,GAAhB,CAAhC,EAAsD;AACpD,cAAM,IAAIX,UAAJ,CAAe,2DAAf,CAAN;AACD;AACD,UAAMokB,cAAc,KAAKd,MAAL,CAAY5K,GAAZ,CAAgB/X,GAAhB,CAApB;AACA,UAAMgiB,WAAW,KAAKiB,QAAL,CAAc3B,KAA/B;;AALc,2BAMiB,KAAK4B,YAAL,CAAkBO,YAAYjC,OAAZ,CAAoB,CAApB,CAAlB,EAA0CQ,QAA1C,CANjB;AAAA,UAMNO,OANM,kBAMNA,OANM;AAAA,UAMGC,SANH,kBAMGA,SANH;;AAAA,yBAOiB,KAAKW,UAAL,CAAkBM,YAAYhC,OAAZ,CAAoB,CAApB,CAAlB,EAA0CO,QAA1C,CAPjB;AAAA,UAONa,OAPM,gBAONA,OAPM;AAAA,UAOGC,SAPH,gBAOGA,SAPH;;AAQd,UAAMX,YAAY,IAAInZ,KAAJ,CAAUgZ,QAAV,CAAlB;;AAEA,WAAK,IAAIV,QAAQ,CAAjB,EAAoBA,QAAQU,QAA5B,EAAsCV,OAAtC,EAA+C;AAC7Ca,kBAAUb,KAAV,IAAmBkB,UAAUlB,KAAV,IAAmBwB,UAAUxB,KAAV,CAAnB,GAAsC,CAAzD;AACD;;AAED,aAAOe,aAAa,KAAK5hB,MAAL,GAAc,CAA3B,EAA8B,KAAKkiB,MAAL,CAAYnH,aAAZ,CAA0B,iBAAS;AACtE+H,cAAM7H,MAAN,CAAa1b,GAAb;AACA,YAAIojB,WAAW,CAAf;AAAA,YAAkBC,WAAW,CAA7B;;AAFsE,qCAI7D/B,MAJ6D;AAKpE,cAAMgC,cAAchY,KAAK8K,GAAL,CAASkL,MAAT,EAAgBmC,YAAYnC,KAA5B,CAApB;AACA,cAAIA,WAAUU,QAAV,IAAsBO,QAAQjB,MAAR,MAAmBiB,QAAQa,QAAR,CAA7C,EAAgE;AAC9DG,kBAAM5b,MAAN,CAAa4a,QAAQa,QAAR,CAAb,EACa;AAAA,qBAAQV,KAAKgB,WAAL,CAAiBN,QAAjB,EAA2BE,WAA3B,EAAwCT,OAAxC,EAAiDV,SAAjD,CAAR;AAAA,aADb;AAEAiB,uBAAW9B,MAAX;AACD;AACD,cAAIuB,QAAQQ,QAAR,MAAsB/B,WAAUU,QAAV,IAAsBa,QAAQvB,MAAR,MAAmBuB,QAAQQ,QAAR,CAA/D,CAAJ,EAAuF;AACrFE,kBAAM5b,MAAN,CAAakb,QAAQQ,QAAR,CAAb,EACa;AAAA,qBAAQX,KAAKiB,YAAL,CAAkBN,QAAlB,EAA4BC,WAA5B,EAAyCf,OAAzC,EAAkDJ,SAAlD,CAAR;AAAA,aADb;AAEAkB,uBAAW/B,MAAX;AACD;AAfmE;;AAItE,aAAK,IAAIA,SAAQ,CAAjB,EAAoBA,UAASU,QAA7B,EAAuCV,QAAvC,EAAgD;AAAA,iBAAvCA,MAAuC;AAY/C;AACF,OAjBoC,CAA9B,EAiBH,KAAK0B,aAjBF,CAAP;AAkBD;;;gCAEY3X,K,EAAO;AAClB,aAAO,KAAKsN,SAAL,CAAe,KAAKD,KAAL,CAAWrN,KAAX,CAAf,CAAP;AACD;;;4BAEQrL,G,EAAK;AACZ,UAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,QAAQ,EAAnC,IAAyC,CAAC,KAAK2iB,MAAL,CAAYpK,GAAZ,CAAgBvY,GAAhB,CAA9C,EAAoE,OAAO,CAAC,CAAR;AACpE,UAAI0iB,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB/X,GAAhB,CAAX;AAAA,UAAiCiG,QAAQ,CAAzC;AACA,aAAOyc,QAAQA,KAAK1iB,GAApB,EAAyB;AACvBiG,iBAASyc,KAAKhB,SAAL,CAAegB,KAAKpB,KAAL,GAAa,CAA5B,CAAT;AACAoB,eAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB2K,KAAKlB,OAAL,CAAakB,KAAKpB,KAAL,GAAa,CAA1B,CAAhB,CAAP;AACD;AACD,aAAOrb,QAAQ,CAAf;AACD;;;0BAEMoF,K,EAAO;AACZ,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,OAAO,IAAP;AAC/B,UAAIA,QAAQ,CAAZ,EAAeA,QAAQA,QAAQ,KAAK5K,MAArB;AACf,UAAI4K,QAAQ,CAAR,IAAaA,SAAS,KAAK5K,MAA/B,EAAuC,OAAO,IAAP;;AAEvC,UAAIiiB,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB,IAAhB,CAAX;AAAA,UAAkCuJ,QAAQoB,KAAKpB,KAAL,GAAa,CAAvD;AAAA,UAA0Drb,QAAQ,CAAlE;AACA,aAAO,IAAP,EAAa;AACX,YAAIA,UAAUoF,QAAQ,CAAtB,EAAyB;AACvB,iBAAOqX,KAAK1iB,GAAZ;AACD,SAFD,MAEO,IAAIiG,QAAQyc,KAAKf,SAAL,CAAeL,KAAf,CAAR,GAAgCjW,QAAQ,CAA5C,EAA+C;AACpDiW,mBAAS,CAAT;AACD,SAFM,MAEA;AACLrb,mBAASyc,KAAKf,SAAL,CAAeL,KAAf,CAAT;AACAoB,iBAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB2K,KAAKjB,OAAL,CAAaH,KAAb,CAAhB,CAAP;AACD;AACF;AACF;;;6BAESthB,G,EAAK;AACb,UAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,QAAQ,EAAvC,EAA2C;AACzC,cAAM,IAAIX,UAAJ,CAAe,+BAAf,CAAN;AACD;AACD,UAAMqjB,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB/X,GAAhB,CAAb;AACA,aAAO0iB,QAAQA,KAAK9jB,KAApB;AACD;;;6BAESoB,G,EAAKpB,K,EAAO;AACpB,UAAI,OAAOoB,GAAP,KAAe,QAAf,IAA2BA,QAAQ,EAAvC,EAA2C;AACzC,cAAM,IAAIX,UAAJ,CAAe,+BAAf,CAAN;AACD;AACD,UAAIqjB,OAAO,KAAKC,MAAL,CAAY5K,GAAZ,CAAgB/X,GAAhB,CAAX;AACA,UAAI,CAAC0iB,IAAL,EAAW,MAAM,IAAIrjB,UAAJ,CAAe,mCAAf,CAAN;;AAEXqjB,aAAOA,KAAKtF,QAAL,CAAcxe,KAAd,CAAP;AACA,aAAOyjB,aAAa,KAAK5hB,MAAlB,EAA0B,KAAKkiB,MAAL,CAAY3a,GAAZ,CAAgBhI,GAAhB,EAAqB0iB,IAArB,CAA1B,EAAsD,KAAKM,aAA3D,CAAP;AACD;;;6BAESY,I,EAAM;AAAA;;AACd;AACA;AACA;AACA,UAAML,QAAQ,KAAKZ,MAAnB;AACA,UAAI3iB,MAAMujB,MAAMxL,GAAN,CAAU,IAAV,EAAgB0J,OAAhB,CAAwB,CAAxB,CAAV;AACA;AACEN,YADF,kBACU;AACN,cAAI,CAACnhB,GAAL,EAAU,OAAO,EAAEpB,OAAOC,SAAT,EAAoB+G,MAAM,IAA1B,EAAP;AACV,cAAM8c,OAAOa,MAAMxL,GAAN,CAAU/X,GAAV,CAAb;AACA,cAAI6jB,OAAOhlB,SAAX;AACA,kBAAQ+kB,IAAR;AACE,iBAAK,MAAL;AAAgBC,qBAAO,EAACjlB,OAAOoB,GAAR,EAA2B4F,MAAM,KAAjC,EAAP,CAAgD;AAChE,iBAAK,QAAL;AAAgBie,qBAAO,EAACjlB,OAAO8jB,KAAK9jB,KAAb,EAA2BgH,MAAM,KAAjC,EAAP,CAAgD;AAChE,iBAAK,SAAL;AAAgBie,qBAAO,EAACjlB,OAAO,CAACoB,GAAD,EAAM0iB,KAAK9jB,KAAX,CAAR,EAA2BgH,MAAM,KAAjC,EAAP,CAAgD;AAHlE;AAKA5F,gBAAM0iB,KAAKjB,OAAL,CAAa,CAAb,CAAN;AACA,iBAAOoC,IAAP;AACD;AAZH,SAaGC,OAAOC,QAbV,EAaqB;AAAA,eAAM,MAAKA,QAAL,CAAcH,IAAd,CAAN;AAAA,OAbrB;AAeD;;SAEAE,OAAOC,Q;4BAAa;AACnB,aAAO,KAAKA,QAAL,CAAc,QAAd,CAAP;AACD;;;wBApNe;AACd,aAAO,KAAKpB,MAAL,CAAY5K,GAAZ,CAAgB,IAAhB,CAAP;AACD;;;;;;AAqNH,SAASsK,YAAT,CAAsB5hB,MAAtB,EAA8B8iB,KAA9B,EAAqCnB,YAArC,EAAmD;AACjD,MAAM4B,WAAW5mB,OAAO6mB,MAAP,CAAc7M,SAAS8M,SAAvB,CAAjB;AACAF,WAASvjB,MAAT,GAAkBA,MAAlB;AACAujB,WAASrB,MAAT,GAAkBY,KAAlB;AACAS,WAAShB,aAAT,GAAyBZ,YAAzB;AACA,SAAO4B,QAAP;AACD;;AAEDhR,OAAOC,OAAP,GAAiB,EAACmE,kBAAD,EAAjB,C;;;;;;;;;;;;;;eCtVqDzd,mBAAOA,CAAC,sCAAR,C;IAA7CC,O,YAAAA,O;IAASuqB,Q,YAAAA,Q;IAAUtqB,U,YAAAA,U;IAAYC,S,YAAAA,S;;gBACGH,mBAAOA,CAAC,4CAAR,C;IAAlCyqB,O,aAAAA,O;IAASC,S,aAAAA,S;IAAWC,S,aAAAA,S;;gBACM3qB,mBAAOA,CAAC,kCAAR,C;IAA1B4qB,I,aAAAA,I;IAAMC,e,aAAAA,e;;gBACsB7qB,mBAAOA,CAAC,oCAAR,C;IAA5B8qB,K,aAAAA,K;IAAOC,gB,aAAAA,gB;;gBACK/qB,mBAAOA,CAAC,wCAAR,C;IAAZgrB,O,aAAAA,O;;AAER;;;;;AAGA,SAASC,QAAT,CAAkB7K,KAAlB,EAAyB0C,MAAzB,EAAiCoI,OAAjC,EAA0C;AACxC,MAAI9K,MAAMtP,QAAV,EAAoB;AAClB;AACA;AACA,QAAIgS,UAAUA,OAAO4H,SAAP,MAAsBtK,MAAMtP,QAA1C,EAAoD;AAClDgS,eAAS5d,SAAT;AACD;AACD,WAAOimB,eAAe/K,KAAf,EAAsB0C,MAAtB,EAA8BoI,OAA9B,CAAP;AACD,GAPD,MAOO,IAAI9K,MAAMhY,QAAN,KAAmB,WAAvB,EAAoC;AACzC;AACA,WAAO,IAAIgjB,IAAJ,CAAShL,MAAMnb,KAAf,CAAP;AACD,GAHM,MAGA,IAAImb,MAAMhY,QAAN,KAAmB,SAAvB,EAAkC;AACvC,WAAO,IAAI4iB,OAAJ,CAAY5K,MAAMnb,KAAlB,CAAP;AACD,GAFM,MAEA,IAAImb,MAAMhY,QAAN,KAAmBlD,SAAvB,EAAkC;AACvC,UAAM,IAAIqK,SAAJ,wBAAmC6Q,MAAMhY,QAAzC,CAAN;AACD,GAFM,MAEA;AACL;AACA,WAAOgY,MAAMnb,KAAb;AACD;AACF;;AAED;;;;AAIA,SAASuf,cAAT,CAAwB6G,GAAxB,EAA6BC,GAA7B,EAAkC;AAChC,MAAMC,QAAQ,cAAd;AACA,MAAM7E,QAAQ6E,MAAMlR,IAAN,CAAWgR,GAAX,IAAkBlrB,UAAUkrB,GAAV,CAAlB,GAAmC,EAAC7lB,SAAS,CAAV,EAAaD,SAAS8lB,GAAtB,EAAjD;AACA,MAAM1E,QAAQ4E,MAAMlR,IAAN,CAAWiR,GAAX,IAAkBnrB,UAAUmrB,GAAV,CAAlB,GAAmC,EAAC9lB,SAAS,CAAV,EAAaD,SAAS+lB,GAAtB,EAAjD;AACA,MAAI5E,MAAMlhB,OAAN,GAAgBmhB,MAAMnhB,OAA1B,EAAmC,OAAO,CAAC,CAAR;AACnC,MAAIkhB,MAAMlhB,OAAN,GAAgBmhB,MAAMnhB,OAA1B,EAAmC,OAAQ,CAAR;AACnC,MAAIkhB,MAAMnhB,OAAN,GAAgBohB,MAAMphB,OAA1B,EAAmC,OAAO,CAAC,CAAR;AACnC,MAAImhB,MAAMnhB,OAAN,GAAgBohB,MAAMphB,OAA1B,EAAmC,OAAQ,CAAR;AACnC,SAAO,CAAP;AACD;;AAED;;;;;;;;;;;;;AAaA,SAASimB,eAAT,CAAyB9X,KAAzB,EAAgCoP,MAAhC,EAAwC2I,SAAxC,EAAmDP,OAAnD,EAA4D;AAC1D,MAAI,CAACxX,KAAL,EAAY;;AAD8C;AAAA;AAAA;;AAAA;AAG1D,yBAAgBjQ,OAAOgD,IAAP,CAAYiN,KAAZ,CAAhB,8HAAoC;AAAA,UAA3BrN,GAA2B;;AAClC,UAAMgG,SAAS,EAAf;AAAA,UAAmBqf,QAAQjoB,OAAOgD,IAAP,CAAYiN,MAAMrN,GAAN,CAAZ,EAAwBK,IAAxB,CAA6B8d,cAA7B,EAA6CC,OAA7C,EAA3B;AADkC;AAAA;AAAA;;AAAA;AAElC,8BAAiBiH,KAAjB,mIAAwB;AAAA,cAAfrmB,IAAe;;AACtB,cAAMsmB,WAAWjY,MAAMrN,GAAN,EAAWhB,IAAX,CAAjB;AACA,cAAIomB,UAAUplB,GAAV,KAAkBolB,UAAUplB,GAAV,EAAehB,IAAf,CAAtB,EAA4C;AAC1CgH,mBAAOhH,IAAP,IAAe4lB,SAASU,QAAT,EAAmBF,UAAUplB,GAAV,EAAehB,IAAf,CAAnB,EAAyC6lB,OAAzC,CAAf;AACD,WAFD,MAEO;AACL7e,mBAAOhH,IAAP,IAAe4lB,SAASU,QAAT,EAAmBzmB,SAAnB,EAA8BgmB,OAA9B,CAAf;AACD;AACF;AATiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWlC,UAAIQ,MAAM5kB,MAAN,KAAiB,CAArB,EAAwB;AACtB,eAAOgc,OAAOzc,GAAP,CAAP;AACA,eAAOolB,UAAUplB,GAAV,CAAP;AACD,OAHD,MAGO;AACLyc,eAAOzc,GAAP,IAAcgG,OAAOqf,MAAM,CAAN,CAAP,CAAd;AACAD,kBAAUplB,GAAV,IAAiBgG,MAAjB;AACD;AACF;AArByD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsB3D;;AAED;;;;;;AAMA,SAASuf,YAAT,CAAsBhY,KAAtB,EAA6BiY,cAA7B,EAA6CC,cAA7C,EAA6D;AAC3D,MAAI,CAAClY,KAAL,EAAY;AACZ,MAAImY,YAAY,CAAC,CAAjB;AAAA,MAAoBC,kBAApB;AAAA,MAA+BC,mBAA/B;;AAEA,OAAK,IAAIplB,IAAI,CAAb,EAAgBA,IAAI+M,MAAM9M,MAA1B,EAAkCD,GAAlC,EAAuC;AACrC,QAAMqlB,OAAOtY,MAAM/M,CAAN,CAAb;AAAA,QAAuB1D,SAAS+oB,KAAK/oB,MAArC;AAAA,QAA6CuO,QAAQwa,KAAKxa,KAA1D;;AAEA,QAAIvO,WAAW,QAAf,EAAyB;AACvB,UAAI4oB,YAAY,CAAhB,EAAmB;AACjBA,oBAAYra,KAAZ;AACAsa,oBAAY,CAAZ;AACAC,qBAAa,CAAb;AACD;AACDA,oBAAc,CAAd;;AAEA;AACA;AACA,UAAIplB,MAAM+M,MAAM9M,MAAN,GAAe,CAArB,IACA8M,MAAM/M,IAAI,CAAV,EAAa1D,MAAb,KAAwB,QADxB,IAEAyQ,MAAM/M,IAAI,CAAV,EAAa6K,KAAb,KAAwBA,QAAQ,CAFpC,EAEuC;AACrCma,uBAAeE,SAAf,EAA0BE,UAA1B;AACAF,oBAAY,CAAC,CAAb;AACD;AAEF,KAjBD,MAiBO,IAAI5oB,WAAW,QAAf,EAAyB;AAC9B,UAAI4oB,YAAY,CAAhB,EAAmB;AACjBA,oBAAYra,KAAZ;AACAsa,oBAAY,CAAZ;AACAC,qBAAa,CAAb;AACD;AACDD,mBAAa,CAAb;;AAEA;AACA;AACA,UAAInlB,MAAM+M,MAAM9M,MAAN,GAAe,CAArB,IACA8M,MAAM/M,IAAI,CAAV,EAAa1D,MAAb,KAAwB,QADxB,IAEAyQ,MAAM/M,IAAI,CAAV,EAAa6K,KAAb,KAAwBA,KAF5B,EAEmC;AACjCoa,uBAAeC,SAAf,EAA0BC,SAA1B;AACAD,oBAAY,CAAC,CAAb;AACD;AACF,KAhBM,MAgBA;AACL,YAAM,IAAIrmB,UAAJ,gCAA4CvC,MAA5C,CAAN;AACD;AACF;AACF;;AAED;;;;AAIA,SAASgpB,cAAT,CAAwBC,cAAxB,EAAwCtb,QAAxC,EAAkD;AAChD,MAAMgS,SAAY5iB,WAAWksB,cAAX,CAAlB;AACA,MAAMX,YAAYvrB,WAAWksB,iBAAiBA,eAAezB,SAAf,CAAjB,GAA6CzlB,SAAxD,CAAlB;AACAzB,SAAO4oB,cAAP,CAAsBvJ,MAAtB,EAA8B4H,SAA9B,EAAyC,EAACzlB,OAAO6L,QAAR,EAAzC;AACArN,SAAO4oB,cAAP,CAAsBvJ,MAAtB,EAA8B6H,SAA9B,EAAyC,EAAC1lB,OAAOwmB,SAAR,EAAzC;AACA,SAAO3I,MAAP;AACD;;AAED;;;;;AAKA,SAASwJ,eAAT,CAAyBlM,KAAzB,EAAgCha,GAAhC,EAAqC8kB,OAArC,EAA8C;AAC5C,MAAMpa,WAAWsP,MAAMtP,QAAvB;AACA,MAAI,CAACoa,QAAQpa,QAAR,CAAL,EAAwB;AACtBoa,YAAQpa,QAAR,IAAoBqb,eAAe/lB,GAAf,EAAoB0K,QAApB,CAApB;AACD;;AAED,MAAMgS,SAASoI,QAAQpa,QAAR,CAAf;AACA0a,kBAAgBpL,MAAM1M,KAAtB,EAA6BoP,MAA7B,EAAqCA,OAAO6H,SAAP,CAArC,EAAwDO,OAAxD;AACA,SAAOpI,MAAP;AACD;;AAED;;;;;AAKA,SAASyJ,iBAAT,CAA2BnM,KAA3B,EAAkCha,GAAlC,EAAuC8kB,OAAvC,EAAgD;AAC9C,MAAMpa,WAAWsP,MAAMtP,QAAvB;AACA,MAAI,CAACoa,QAAQpa,QAAR,CAAL,EAAwB;AACtBoa,YAAQpa,QAAR,IAAoB1K,MAAMA,IAAIomB,MAAJ,EAAN,GAAqBzB,iBAAiBja,QAAjB,CAAzC;AACD;;AAED,MAAMgS,SAASoI,QAAQpa,QAAR,CAAf;;AAN8C;AAAA;AAAA;;AAAA;AAQ9C,0BAAgBrN,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,IAAe,EAA3B,CAAhB,mIAAgD;AAAA,UAAvCrN,GAAuC;;AAC9C,UAAMgG,SAAS,EAAf;AAAA,UAAmBqf,QAAQjoB,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,CAAYrN,GAAZ,CAAZ,CAA3B;;AAEA,UAAIqlB,MAAM5kB,MAAN,KAAiB,CAArB,EAAwB;AACtBgc,eAAOf,MAAP,CAAc1b,GAAd;AACD,OAFD,MAEO,IAAIqlB,MAAM5kB,MAAN,KAAiB,CAArB,EAAwB;AAC7B,YAAM6kB,WAAWvL,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBqlB,MAAM,CAAN,CAAjB,CAAjB;AACA5I,eAAO2J,IAAP,CAAYpmB,GAAZ,EAAiB4kB,SAASU,QAAT,EAAmB7I,OAAO4J,IAAP,CAAYrmB,GAAZ,CAAnB,EAAqC6kB,OAArC,CAAjB,EAAgEQ,MAAM,CAAN,CAAhE;AACD,OAHM,MAGA;AACL,cAAM,IAAIhmB,UAAJ,CAAe,sDAAf,CAAN;AACD;AACF;AAnB6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoB9C,SAAOod,MAAP;AACD;;AAED;;;;AAIA,SAAS6J,eAAT,CAAyBC,YAAzB,EAAuC9b,QAAvC,EAAiD;AAC/C,MAAMuS,OAAOuJ,eAAeA,aAAaxd,KAAb,EAAf,GAAsC,EAAnD,CAD+C,CACO;AACtD,MAAMqc,YAAamB,gBAAgBA,aAAajC,SAAb,CAAjB,GAA4CiC,aAAajC,SAAb,EAAwBvb,KAAxB,EAA5C,GAA8E,EAAhG;AACA3L,SAAO4oB,cAAP,CAAsBhJ,IAAtB,EAA4BqH,SAA5B,EAAuC,EAACzlB,OAAO6L,QAAR,EAAvC;AACArN,SAAO4oB,cAAP,CAAsBhJ,IAAtB,EAA4BsH,SAA5B,EAAuC,EAAC1lB,OAAOwmB,SAAR,EAAvC;AACA,SAAOpI,IAAP;AACD;;AAED;;;;;AAKA,SAASwJ,gBAAT,CAA0BzM,KAA1B,EAAiCha,GAAjC,EAAsC8kB,OAAtC,EAA+C;AAC7C,MAAMpa,WAAWsP,MAAMtP,QAAvB;AACA,MAAI,CAACoa,QAAQpa,QAAR,CAAL,EAAwB;AACtBoa,YAAQpa,QAAR,IAAoB6b,gBAAgBvmB,GAAhB,EAAqB0K,QAArB,CAApB;AACD;;AAED,MAAMuS,OAAO6H,QAAQpa,QAAR,CAAb;AAAA,MAAgC2a,YAAYpI,KAAKsH,SAAL,CAA5C;;AAEAiB,eAAaxL,MAAMxM,KAAnB,EACE,UAAClC,KAAD,EAAQua,UAAR,EAAuB;AAAE;AACvB,QAAMa,SAAS,IAAIzd,KAAJ,CAAU4c,UAAV,CAAf;AACA5I,SAAU7K,MAAV,cAAiB9G,KAAjB,EAAwB,CAAxB,SAA8Bob,MAA9B;AACArB,cAAUjT,MAAV,mBAAiB9G,KAAjB,EAAwB,CAAxB,SAA8Bob,MAA9B;AACD,GALH,EAME,UAACpb,KAAD,EAAQpF,KAAR,EAAkB;AAAE;AAClB+W,SAAU7K,MAAV,CAAiB9G,KAAjB,EAAwBpF,KAAxB;AACAmf,cAAUjT,MAAV,CAAiB9G,KAAjB,EAAwBpF,KAAxB;AACD,GATH;;AAYAkf,kBAAgBpL,MAAM1M,KAAtB,EAA6B2P,IAA7B,EAAmCoI,SAAnC,EAA8CP,OAA9C;AACA,SAAO7H,IAAP;AACD;;AAED;;;;;AAKA,SAAS0J,gBAAT,CAA0B3M,KAA1B,EAAiCha,GAAjC,EAAsC8kB,OAAtC,EAA+C;AAC7C,MAAMpa,WAAWsP,MAAMtP,QAAvB;AACA,MAAIkc,cAAJ;AACA,MAAI9B,QAAQpa,QAAR,CAAJ,EAAuB;AACrBkc,YAAQ9B,QAAQpa,QAAR,EAAkBkc,KAA1B;AACD,GAFD,MAEO,IAAI5mB,GAAJ,EAAS;AACd4mB,YAAQ5mB,IAAI4mB,KAAJ,CAAU5d,KAAV,EAAR;AACD,GAFM,MAEA;AACL4d,YAAQ,EAAR;AACD;;AAEDpB,eAAaxL,MAAMxM,KAAnB,EACE,UAAClC,KAAD,EAAQua,UAAR,EAAuB;AAAA;;AAAE;AACvB,QAAMa,SAAS,EAAf;AACA,SAAK,IAAIjmB,IAAI,CAAb,EAAgBA,IAAIolB,UAApB,EAAgCplB,GAAhC;AAAqCimB,aAAOtmB,IAAP,CAAY,EAAZ;AAArC,KACA,iBAAMgS,MAAN,gBAAa9G,KAAb,EAAoB,CAApB,SAA0Bob,MAA1B;AACD,GALH,EAME,UAACpb,KAAD,EAAQsa,SAAR,EAAsB;AAAE;AACtBgB,UAAMxU,MAAN,CAAa9G,KAAb,EAAoBsa,SAApB;AACD,GARH;;AAX6C;AAAA;AAAA;;AAAA;AAsB7C,0BAAgBvoB,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,IAAe,EAA3B,CAAhB,mIAAgD;AAAA,UAAvCrN,GAAuC;;AAC9C,UAAMhB,OAAO5B,OAAOgD,IAAP,CAAY2Z,MAAM1M,KAAN,CAAYrN,GAAZ,CAAZ,EAA8BK,IAA9B,CAAmC8d,cAAnC,EAAmDC,OAAnD,GAA6D,CAA7D,CAAb;AACA,UAAI,CAACpf,IAAL,EAAW,MAAM,IAAIK,UAAJ,gCAA4CW,GAA5C,CAAN;;AAEX;AACA,UAAM4mB,WAAYD,MAAM3mB,GAAN,EAAWhB,IAAX,KAAoBA,IAArB,GAA6B2nB,MAAM3mB,GAAN,EAAWpB,KAAxC,GAAgDC,SAAjE;AACA8nB,YAAM3mB,GAAN,EAAWpB,KAAX,GAAmBgmB,SAAS7K,MAAM1M,KAAN,CAAYrN,GAAZ,EAAiBhB,IAAjB,CAAT,EAAiC4nB,QAAjC,EAA2C/B,OAA3C,CAAnB;AACA8B,YAAM3mB,GAAN,EAAWhB,IAAX,GAAkBA,IAAlB;AACD;AA9B4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgC7C6lB,UAAQpa,QAAR,IAAoB+Z,gBAAgB/Z,QAAhB,EAA0Bkc,KAA1B,CAApB;AACA,SAAO9B,QAAQpa,QAAR,CAAP;AACD;;AAED;;;;;AAKA,SAASqa,cAAT,CAAwB/K,KAAxB,EAA+Bha,GAA/B,EAAoC8kB,OAApC,EAA6C;AAC3C;AACA,MAAIV,SAASpkB,GAAT,KAAiB,CAACga,MAAM1M,KAAxB,IAAiC,CAAC0M,MAAMxM,KAAxC,IAAiD,CAACsX,QAAQ9K,MAAMtP,QAAd,CAAtD,EAA+E;AAC7E,WAAO1K,GAAP;AACD;;AAED,MAAIga,MAAMzM,IAAN,KAAe,KAAnB,EAA0B;AACxB,WAAO2Y,gBAAgBlM,KAAhB,EAAuBha,GAAvB,EAA4B8kB,OAA5B,CAAP;AACD,GAFD,MAEO,IAAI9K,MAAMzM,IAAN,KAAe,OAAnB,EAA4B;AACjC,WAAO4Y,kBAAkBnM,KAAlB,EAAyBha,GAAzB,EAA8B8kB,OAA9B,CAAP;AACD,GAFM,MAEA,IAAI9K,MAAMzM,IAAN,KAAe,MAAnB,EAA2B;AAChC,WAAOkZ,iBAAiBzM,KAAjB,EAAwBha,GAAxB,EAA6B8kB,OAA7B,CAAP;AACD,GAFM,MAEA,IAAI9K,MAAMzM,IAAN,KAAe,MAAnB,EAA2B;AAChC,WAAOoZ,iBAAiB3M,KAAjB,EAAwBha,GAAxB,EAA6B8kB,OAA7B,CAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAI3b,SAAJ,2BAAsC6Q,MAAMzM,IAA5C,CAAN;AACD;AACF;;AAED;;;AAGA,SAASuZ,eAAT,CAAyBC,IAAzB,EAA+B;AAC7B,MAAIA,KAAKzC,SAAL,MAAoBzqB,OAAxB,EAAiC;AAC/B,UAAM,IAAIyF,UAAJ,2BAAuCynB,KAAKzC,SAAL,CAAvC,CAAN;AACD;AACD,SAAOyB,eAAegB,IAAf,EAAqBltB,OAArB,CAAP;AACD;;AAEDoZ,OAAOC,OAAP,GAAiB;AACf6R,gCADe,EACC+B;AADD,CAAjB,C;;;;;;;;;;;;;;AClTA;AACA,IAAMzC,UAAYN,OAAO,UAAP,CAAlB,C,CAAuC;AACvC,IAAMiD,QAAYjD,OAAO,QAAP,CAAlB,C,CAAuC;AACvC,IAAMkD,QAAYlD,OAAO,QAAP,CAAlB,C,CAAuC;;AAEvC;AACA,IAAMO,YAAYP,OAAO,WAAP,CAAlB,C,CAAuC;AACvC,IAAMQ,YAAYR,OAAO,YAAP,CAAlB,C,CAAuC;AACvC,IAAMmD,SAAYnD,OAAO,SAAP,CAAlB,C,CAAuC;;AAEvC9Q,OAAOC,OAAP,GAAiB;AACfmR,kBADe,EACN2C,YADM,EACCC,YADD,EACQ3C,oBADR,EACmBC,oBADnB,EAC8B2C;AAD9B,CAAjB,C;;;;;;;;;;;;;;;;;;;;;;;;eCVwCttB,mBAAOA,CAAC,4CAAR,C;IAAhCotB,K,YAAAA,K;IAAO1C,S,YAAAA,S;IAAWC,S,YAAAA,S;;gBACC3qB,mBAAOA,CAAC,gDAAR,C;IAAnBmrB,c,aAAAA,c;;gBACSnrB,mBAAOA,CAAC,kCAAR,C;IAAT4qB,I,aAAAA,I;;gBACU5qB,mBAAOA,CAAC,oCAAR,C;IAAV8qB,K,aAAAA,K;;gBACiC9qB,mBAAOA,CAAC,wCAAR,C;IAAjCgrB,O,aAAAA,O;IAASuC,mB,aAAAA,mB;;gBACyBvtB,mBAAOA,CAAC,sCAAR,C;IAAlCC,O,aAAAA,O;IAASuqB,Q,aAAAA,Q;IAAUtqB,U,aAAAA,U;;AAC3B,IAAMstB,OAAOxtB,mBAAOA,CAAC,kCAAR,CAAb;;AAGA;;;;;;IAKMytB,O;AACJ,mBAAa7V,GAAb,EAAkBrS,OAAlB,EAA2BmoB,UAA3B,EAAuC;AAAA;;AACrC,SAAKnoB,OAAL,GAAeA,OAAf;AACA,SAAKooB,KAAL,GAAa/V,IAAIwV,KAAJ,CAAb;AACA,SAAKlC,OAAL,GAAe,EAAf;AACA,SAAKjlB,GAAL,GAAW,EAAX;AACA,SAAKynB,UAAL,GAAkBA,aAAaA,UAAb,GAA0BvC,cAA5C;AACD;;AAED;;;;;;;0BAGMxU,S,EAAW;AACf,WAAK1Q,GAAL,CAASO,IAAT,CAAcmQ,SAAd;AACD;;AAED;;;;;;wCAGoB1R,K,EAAO;AACzB,UAAI,CAAC,CAAC,QAAD,EAAW,SAAX,EAAsB,QAAtB,EAAgC,QAAhC,EAA0Cga,QAA1C,QAA0Dha,KAA1D,yCAA0DA,KAA1D,EAAL,EAAuE;AACrE,cAAM,IAAIsK,SAAJ,yCAAmDtK,KAAnD,yCAAmDA,KAAnD,GAAN;AACD;;AAED,UAAIulB,SAASvlB,KAAT,CAAJ,EAAqB;AACnB,YAAIA,iBAAiBmmB,IAArB,EAA2B;AACzB;AACA,iBAAO,EAACnmB,OAAOA,MAAM2oB,OAAN,EAAR,EAAyBxlB,UAAU,WAAnC,EAAP;AAED,SAJD,MAIO,IAAInD,iBAAiB+lB,OAArB,EAA8B;AACnC;AACA,iBAAO,EAAC/lB,OAAOA,MAAMA,KAAd,EAAqBmD,UAAU,SAA/B,EAAP;AAED,SAJM,MAIA;AACL;AACA,cAAM0I,WAAW7L,MAAMylB,SAAN,CAAjB;AACA,cAAI,CAAC5Z,QAAL,EAAe;AACb,kBAAM,IAAIpL,UAAJ,aAAyB0B,KAAKC,SAAL,CAAepC,KAAf,CAAzB,sBAAN;AACD;AACD,iBAAO,EAAC6L,kBAAD,EAAW6C,MAAM,KAAK+O,aAAL,CAAmB5R,QAAnB,CAAjB,EAAP;AACD;AACF,OAjBD,MAiBO;AACL;AACA,eAAO,EAAC7L,YAAD,EAAP;AACD;AACF;;AAED;;;;;;;;0CAKsBsd,I,EAAMO,M,EAAQzc,G,EAAK;AACvC,UAAIyc,kBAAkBgI,KAAtB,EAA6B;AAC3B;AACA,YAAM7lB,QAAQ6d,OAAO4J,IAAP,CAAYrmB,GAAZ,CAAd;AACA,YAAIpB,KAAJ,EAAW;AACT,qCAASoB,GAAT,EAAe,KAAKwnB,mBAAL,CAAyB5oB,KAAzB,CAAf;AACD,SAFD,MAEO;AACL,iBAAO,EAAP;AACD;AACF,OARD,MAQO;AACL;AACA,YAAMwmB,YAAY3I,OAAO6H,SAAP,EAAkBtkB,GAAlB,CAAlB;AAAA,YAA0CgG,SAAS,EAAnD;AACA,YAAI,CAACof,SAAL,EAAgB;AACd,gBAAM,IAAI/lB,UAAJ,yBAAqCW,GAArC,iBAAoDe,KAAKC,SAAL,CAAekb,IAAf,CAApD,CAAN;AACD;AALI;AAAA;AAAA;;AAAA;AAML,+BAAiB9e,OAAOgD,IAAP,CAAYglB,SAAZ,CAAjB,8HAAyC;AAAA,gBAAhCpmB,IAAgC;;AACvCgH,mBAAOhH,IAAP,IAAe,KAAKwoB,mBAAL,CAAyBpC,UAAUpmB,IAAV,CAAzB,CAAf;AACD;AARI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASL,eAAOgH,MAAP;AACD;AACF;;AAED;;;;;;;qCAIiByW,M,EAAQzc,G,EAAKhB,I,EAAM;AAClC,UAAIyd,kBAAkBgI,KAAtB,EAA6B;AAC3B,eAAOhI,OAAO4J,IAAP,CAAYrmB,GAAZ,CAAP;AACD,OAFD,MAEO;AACL,eAAOyc,OAAO6H,SAAP,EAAkBtkB,GAAlB,EAAuBhB,IAAvB,CAAP;AACD;AACF;;AAED;;;;;;;gCAIY+a,K,EAAOmC,I,EAAM;AACvB,UAAIoJ,WAAWvL,MAAMV,KAArB;AAAA,UAA4BoD,SAAS,KAAKgL,SAAL,CAAe7tB,OAAf,CAArC;;AADuB;AAAA;AAAA;;AAAA;AAGvB,8BAAqBsiB,IAArB,mIAA2B;AAAA,cAAlBwL,QAAkB;;AACzB,cAAI,CAACpC,SAASjY,KAAd,EAAqB;AACnBiY,qBAASjY,KAAT,GAAiB,EAAjB;AACD;AACD,cAAI,CAACiY,SAASjY,KAAT,CAAeqa,SAAS1nB,GAAxB,CAAL,EAAmC;AACjCslB,qBAASjY,KAAT,CAAeqa,SAAS1nB,GAAxB,IAA+B,KAAK2nB,qBAAL,CAA2BzL,IAA3B,EAAiCO,MAAjC,EAAyCiL,SAAS1nB,GAAlD,CAA/B;AACD;;AAED,cAAI4nB,WAAW,IAAf;AAAA,cAAqB5hB,SAASsf,SAASjY,KAAT,CAAeqa,SAAS1nB,GAAxB,CAA9B;AARyB;AAAA;AAAA;;AAAA;AASzB,kCAAiB5C,OAAOgD,IAAP,CAAY4F,MAAZ,CAAjB,mIAAsC;AAAA,kBAA7BhH,IAA6B;;AACpC,kBAAIgH,OAAOhH,IAAP,EAAayL,QAAb,KAA0Bid,SAASjd,QAAvC,EAAiD;AAC/Cmd,2BAAW5oB,IAAX;AACD;AACF;AAbwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAczB,cAAI,CAAC4oB,QAAL,EAAe;AACb,kBAAM,IAAIvoB,UAAJ,4CAAwDqoB,SAASjd,QAAjE,CAAN;AACD;AACD6a,qBAAWtf,OAAO4hB,QAAP,CAAX;AACAnL,mBAAS,KAAKoL,gBAAL,CAAsBpL,MAAtB,EAA8BiL,SAAS1nB,GAAvC,EAA4C4nB,QAA5C,CAAT;AACD;AAtBsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBvB,UAAI,CAACtC,SAASjY,KAAd,EAAqB;AACnBiY,iBAASjY,KAAT,GAAiB,EAAjB;AACD;AACD,aAAOiY,QAAP;AACD;;AAED;;;;;;8BAGU7a,Q,EAAU;AAClB,UAAMgS,SAAS,KAAKoI,OAAL,CAAapa,QAAb,KAA0B,KAAK6c,KAAL,CAAW7c,QAAX,CAAzC;AACA,UAAI,CAACgS,MAAL,EAAa,MAAM,IAAIpd,UAAJ,oCAAgDoL,QAAhD,CAAN;AACb,aAAOgS,MAAP;AACD;;AAED;;;;;;;kCAIchS,Q,EAAU;AACtB,UAAIA,aAAa7Q,OAAjB,EAA0B,OAAO,KAAP;AAC1B,UAAM6iB,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;AACA,UAAIgS,kBAAkB8H,IAAtB,EAA4B,OAAO,MAAP;AAC5B,UAAI9H,kBAAkBgI,KAAtB,EAA6B,OAAO,OAAP;AAC7B,UAAIzb,MAAMC,OAAN,CAAcwT,MAAd,CAAJ,EAA2B,OAAO,MAAP;AAC3B,aAAO,KAAP;AACD;;AAED;;;;;;;mCAIeP,I,EAAMzR,Q,EAAUzK,G,EAAK;AAClC,UAAI,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqB4Y,QAArB,QAAqC5Y,GAArC,yCAAqCA,GAArC,EAAL,EAAgD;AAChD,UAAMyc,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;;AAEA,UAAIgS,OAAOzc,GAAP,aAAuB2kB,OAA3B,EAAoC;AAClC,eAAOuC,oBAAoBzK,OAAOzc,GAAP,EAAYpB,KAAhC,EAAuC,IAAvC,EAA6Csd,IAA7C,EAAmDzR,QAAnD,EAA6DzK,GAA7D,CAAP;AAED,OAHD,MAGO,IAAImkB,SAAS1H,OAAOzc,GAAP,CAAT,CAAJ,EAA2B;AAChC,YAAMmN,UAAUsP,OAAOzc,GAAP,EAAYqkB,SAAZ,CAAhB;AACA,YAAMyD,UAAU5L,KAAK5b,MAAL,CAAY,CAAC,EAACN,QAAD,EAAMyK,UAAU0C,OAAhB,EAAD,CAAZ,CAAhB;AACA;AACA,eAAO,KAAK4a,iBAAL,CAAuBD,OAAvB,EAAgC3a,OAAhC,CAAP;AAED,OANM,MAMA;AACL,eAAOsP,OAAOzc,GAAP,CAAP;AACD;AACF;;AAED;;;;;;;;;;;wCAQoBD,G,EAAKC,G,EAAKpB,K,EAAO/B,M,EAAQ;AAC3C,UAAI+B,MAAMylB,SAAN,CAAJ,EAAsB;AACpB,cAAM,IAAIhlB,UAAJ,CAAe,0DAAf,CAAN;AACD;AACD,UAAMY,QAAQknB,MAAd;AACA,UAAInnB,QAAQ,IAAZ,EAAkBA,MAAMC,KAAN;;AAElB,UAAIrB,iBAAiB2lB,IAArB,EAA2B;AACzB;AACA,aAAKyD,KAAL,CAAW,EAAClrB,QAAQ,UAAT,EAAqBiD,QAArB,EAA0BC,QAA1B,EAA+BnD,cAA/B,EAAuCoD,YAAvC,EAAX;AACA,YAAMqlB,WAAW,EAAC7a,UAAUxK,KAAX,EAAkBqN,MAAM,MAAxB,EAAgCC,OAAO,EAAvC,EAA2CF,OAAO,EAAlD,EAAjB;AACA,aAAK4a,eAAL,CAAqB3C,QAArB,EAA+B,CAA/B,+BAAsC1mB,KAAtC,IAA8C,IAA9C;AACA,eAAO0mB,QAAP;AAED,OAPD,MAOO,IAAI1mB,iBAAiB6lB,KAArB,EAA4B;AACjC;AACA,YAAI7lB,MAAMqH,KAAN,GAAc,CAAlB,EAAqB;AACnB,gBAAM,IAAI5G,UAAJ,CAAe,qDAAf,CAAN;AACD;AACD,aAAK2oB,KAAL,CAAW,EAAClrB,QAAQ,WAAT,EAAsBiD,QAAtB,EAA2BC,QAA3B,EAAgCnD,cAAhC,EAAwCoD,YAAxC,EAAX;AACA,eAAO,EAACwK,UAAUxK,KAAX,EAAkBqN,MAAM,OAAxB,EAAiCD,OAAO,EAAxC,EAAP;AAED,OARM,MAQA,IAAIrE,MAAMC,OAAN,CAAcrK,KAAd,CAAJ,EAA0B;AAC/B;AACA,aAAKopB,KAAL,CAAW,EAAClrB,QAAQ,UAAT,EAAqBiD,QAArB,EAA0BC,QAA1B,EAA+BnD,cAA/B,EAAuCoD,YAAvC,EAAX;AACA,YAAMqlB,YAAW,EAAC7a,UAAUxK,KAAX,EAAkBqN,MAAM,MAAxB,EAAgCC,OAAO,EAAvC,EAA2CF,OAAO,EAAlD,EAAjB;AACA,aAAK4a,eAAL,CAAqB3C,SAArB,EAA+B,CAA/B,EAAkC1mB,KAAlC,EAAyC,IAAzC;AACA,eAAO0mB,SAAP;AAED,OAPM,MAOA;AACL;AACA,aAAK0C,KAAL,CAAW,EAAClrB,QAAQ,SAAT,EAAoBiD,QAApB,EAAyBC,QAAzB,EAA8BnD,cAA9B,EAAsCoD,YAAtC,EAAX;AACA,YAAIoN,QAAQ,EAAZ;AAHK;AAAA;AAAA;;AAAA;AAIL,gCAAmBjQ,OAAOgD,IAAP,CAAYxB,KAAZ,CAAnB,mIAAuC;AAAA,gBAA9BspB,MAA8B;;AACrC,gBAAMC,aAAa,KAAK/K,QAAL,CAAcnd,KAAd,EAAqBioB,MAArB,EAA6BtpB,MAAMspB,MAAN,CAA7B,EAA4C,KAA5C,CAAnB;AACA7a,kBAAM6a,MAAN,wBAAkB,KAAKhpB,OAAvB,EAAiCipB,UAAjC;AACD;AAPI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQL,eAAO,EAAC1d,UAAUxK,KAAX,EAAkBqN,MAAM,KAAxB,EAA+BD,YAA/B,EAAP;AACD;AACF;;AAED;;;;;;;;;;;;6BASS5C,Q,EAAUzK,G,EAAKpB,K,EAAO/B,M,EAAQ;AACrC,UAAI,CAAC4N,QAAL,EAAe;AACb,cAAM,IAAIpL,UAAJ,CAAe,4BAAf,CAAN;AACD;AACD,UAAIW,QAAQ,EAAZ,EAAgB;AACd,cAAM,IAAIX,UAAJ,CAAe,oDAAf,CAAN;AACD;;AAED,UAAI8kB,SAASvlB,KAAT,KAAmB,EAAEA,iBAAiBmmB,IAAnB,CAAnB,IAA+C,EAAEnmB,iBAAiB+lB,OAAnB,CAAnD,EAAgF;AAC9E;AACA,eAAO,KAAKyD,mBAAL,CAAyB3d,QAAzB,EAAmCzK,GAAnC,EAAwCpB,KAAxC,EAA+C/B,MAA/C,CAAP;AACD,OAHD,MAGO;AACL;AACA,YAAMwrB,cAAc,KAAKb,mBAAL,CAAyB5oB,KAAzB,CAApB;AACA,aAAKopB,KAAL,CAAW5qB,OAAOC,MAAP,CAAc,EAACP,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,QAA/B,EAAoCnD,cAApC,EAAd,EAA2DwrB,WAA3D,CAAX;AACA,eAAOA,WAAP;AACD;AACF;;AAED;;;;;;;gCAIYnM,I,EAAMoM,Q,EAAU;AAC1B,UAAIvO,QAAQ,EAACV,OAAO,EAAC5O,UAAU7Q,OAAX,EAAoB0T,MAAM,KAA1B,EAAR,EAAZ;AACAgb,eAAS,KAAKC,WAAL,CAAiBxO,KAAjB,EAAwBmC,IAAxB,CAAT;AACA,WAAKmL,UAAL,CAAgBtN,MAAMV,KAAtB,EAA6B,KAAKiO,KAAL,CAAW1tB,OAAX,CAA7B,EAAkD,KAAKirB,OAAvD;AACD;;AAED;;;;;;;8BAIU3I,I,EAAMlc,G,EAAKpB,K,EAAO;AAAA;;AAC1B,UAAI,OAAOoB,GAAP,KAAe,QAAnB,EAA6B;AAC3B,cAAM,IAAIX,UAAJ,2DAAsEW,GAAtE,yCAAsEA,GAAtE,GAAN;AACD;;AAED,UAAMyK,WAAWyR,KAAKzb,MAAL,KAAgB,CAAhB,GAAoB7G,OAApB,GAA8BsiB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAArE;AACA,UAAMgS,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;AACA,UAAIgS,OAAOzc,GAAP,aAAuB2kB,OAA3B,EAAoC;AAClC,cAAM,IAAItlB,UAAJ,CAAe,0FAAf,CAAN;AACD;;AAED;AACA;AACA,UAAIod,OAAOzc,GAAP,MAAgBpB,KAAhB,IAAyBxB,OAAOgD,IAAP,CAAYqc,OAAO6H,SAAP,EAAkBtkB,GAAlB,KAA0B,EAAtC,EAA0CS,MAA1C,GAAmD,CAA5E,IAAiF7B,UAAUC,SAA/F,EAA0G;AACxG,aAAK2pB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjC,cAAMiM,aAAa,MAAK/K,QAAL,CAAc3S,QAAd,EAAwBzK,GAAxB,EAA6BpB,KAA7B,EAAoC,KAApC,CAAnB;AACA0mB,mBAASjY,KAAT,CAAerN,GAAf,wBAAwB,MAAKd,OAA7B,EAAuCipB,UAAvC;AACD,SAHD;AAID;AACF;;AAED;;;;;;iCAGajM,I,EAAMlc,G,EAAK;AACtB,UAAMyK,WAAWyR,KAAKzb,MAAL,KAAgB,CAAhB,GAAoB7G,OAApB,GAA8BsiB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAArE;AACA,UAAMgS,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;;AAEA,UAAIgS,OAAOzc,GAAP,MAAgBnB,SAApB,EAA+B;AAC7B,aAAKmpB,KAAL,CAAW,EAAClrB,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,QAA/B,EAAoCnD,QAAQ,KAA5C,EAAX;AACA,aAAK2rB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjCoJ,mBAASjY,KAAT,CAAerN,GAAf,IAAsB,EAAtB;AACD,SAFD;AAGD;AACF;;AAED;;;;;;;;;oCAMgBslB,Q,EAAUja,K,EAAOrF,M,EAAQyiB,S,EAAW;AAClD,UAAMzL,OAAOyL,YAAY,EAAZ,GAAiB,KAAKhB,SAAL,CAAenC,SAAS7a,QAAxB,CAA9B;AACA,UAAIY,QAAQ,CAAR,IAAaA,QAAQ2R,KAAKvc,MAA9B,EAAsC;AACpC,cAAM,IAAIpB,UAAJ,iBAA6BgM,KAA7B,6CAA0E2R,KAAKvc,MAA/E,CAAN;AACD;;AAED,WAAK,IAAI4H,SAAS,CAAlB,EAAqBA,SAASrC,OAAOvF,MAArC,EAA6C4H,QAA7C,EAAuD;AACrD,YAAM8f,aAAa,KAAK/K,QAAL,CAAckI,SAAS7a,QAAvB,EAAiCY,QAAQhD,MAAzC,EAAiDrC,OAAOqC,MAAP,CAAjD,EAAiE,IAAjE,CAAnB;AACAid,iBAAS/X,KAAT,CAAepN,IAAf,CAAoB,EAACrD,QAAQ,QAAT,EAAmBuO,OAAOA,QAAQhD,MAAlC,EAApB;AACAid,iBAASjY,KAAT,CAAehC,QAAQhD,MAAvB,wBAAmC,KAAKnJ,OAAxC,EAAkDipB,UAAlD;AACD;AACF;;AAED;;;;;;;iCAIajM,I,EAAM7Q,K,EAAOzM,K,EAAO;AAAA;;AAC/B,UAAM6L,WAAWyR,KAAKzb,MAAL,KAAgB,CAAhB,GAAoB7G,OAApB,GAA8BsiB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAArE;AACA,UAAMuS,OAAO,KAAKyK,SAAL,CAAehd,QAAf,CAAb;AACA,UAAIY,UAAU2R,KAAKvc,MAAnB,EAA2B;AACzB,eAAO,KAAK0R,MAAL,CAAY+J,IAAZ,EAAkB7Q,KAAlB,EAAyB,CAAzB,EAA4B,CAACzM,KAAD,CAA5B,CAAP;AACD;AACD,UAAIyM,QAAQ,CAAR,IAAaA,QAAQ2R,KAAKvc,MAA9B,EAAsC;AACpC,cAAM,IAAIpB,UAAJ,iBAA6BgM,KAA7B,6CAA0E2R,KAAKvc,MAA/E,CAAN;AACD;AACD,UAAIuc,KAAK3R,KAAL,aAAuBsZ,OAA3B,EAAoC;AAClC,cAAM,IAAItlB,UAAJ,CAAe,0FAAf,CAAN;AACD;;AAED;AACA;AACA,UAAI2d,KAAK3R,KAAL,MAAgBzM,KAAhB,IAAyBxB,OAAOgD,IAAP,CAAY4c,KAAKsH,SAAL,EAAgBjZ,KAAhB,KAA0B,EAAtC,EAA0C5K,MAA1C,GAAmD,CAA5E,IAAiF7B,UAAUC,SAA/F,EAA0G;AACxG,aAAK2pB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjC,cAAMiM,aAAa,OAAK/K,QAAL,CAAc3S,QAAd,EAAwBY,KAAxB,EAA+BzM,KAA/B,EAAsC,KAAtC,CAAnB;AACA0mB,mBAASjY,KAAT,CAAehC,KAAf,wBAA0B,OAAKnM,OAA/B,EAAyCipB,UAAzC;AACD,SAHD;AAID;AACF;;AAED;;;;;;;2BAIOjM,I,EAAM5G,K,EAAOqQ,S,EAAWC,U,EAAY;AACzC,UAAMnb,WAAWyR,KAAKzb,MAAL,KAAgB,CAAhB,GAAoB7G,OAApB,GAA8BsiB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAArE;AACA,UAAIuS,OAAO,KAAKyK,SAAL,CAAehd,QAAf,CAAX;AACA,UAAI6K,QAAQ,CAAR,IAAaqQ,YAAY,CAAzB,IAA8BrQ,QAAQ0H,KAAKvc,MAAL,GAAcklB,SAAxD,EAAmE;AACjE,cAAM,IAAItmB,UAAJ,CAAkBsmB,SAAlB,qCAA2DrQ,KAA3D,8CAAyG0H,KAAKvc,MAA9G,CAAN;AACD;AACD,UAAIklB,cAAc,CAAd,IAAmBC,WAAWnlB,MAAX,KAAsB,CAA7C,EAAgD;;AAEhD,UAAIsZ,QAAQ,EAACV,OAAO,EAAC5O,UAAU7Q,OAAX,EAAoB0T,MAAM,KAA1B,EAAR,EAAZ;AACA,UAAIgY,WAAW,KAAKiD,WAAL,CAAiBxO,KAAjB,EAAwBmC,IAAxB,CAAf;AACA,UAAI,CAACoJ,SAAS/X,KAAd,EAAqB+X,SAAS/X,KAAT,GAAiB,EAAjB;;AAErB,UAAIoY,YAAY,CAAhB,EAAmB;AACjB,aAAK,IAAInlB,IAAI,CAAb,EAAgBA,IAAImlB,SAApB,EAA+BnlB,GAA/B,EAAoC;AAClC,eAAKwnB,KAAL,CAAW,EAAClrB,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,KAAKsV,KAApC,EAA2CzY,QAAQ,KAAnD,EAAX;AACAyoB,mBAAS/X,KAAT,CAAepN,IAAf,CAAoB,EAACrD,QAAQ,QAAT,EAAmBuO,OAAOiK,KAA1B,EAApB;AACD;AACF;;AAED,UAAIsQ,WAAWnlB,MAAX,GAAoB,CAAxB,EAA2B;AACzB,aAAKwnB,eAAL,CAAqB3C,QAArB,EAA+BhQ,KAA/B,EAAsCsQ,UAAtC,EAAkD,KAAlD;AACD;AACD,WAAKyB,UAAL,CAAgBtN,MAAMV,KAAtB,EAA6B,KAAKiO,KAAL,CAAW1tB,OAAX,CAA7B,EAAkD,KAAKirB,OAAvD;AACD;;AAED;;;;;;;gCAIY3I,I,EAAMrW,G,EAAK;AACrB,UAAI,CAACse,SAASte,GAAT,CAAD,IAAkBmD,MAAMC,OAAN,CAAcpD,GAAd,CAAtB,EAA0C;AACxC,cAAM,IAAIqD,SAAJ,CAAc,+BAAd,CAAN;AACD;AACD,UAAIrD,IAAIwe,SAAJ,CAAJ,EAAoB;AAClB,cAAM,IAAInb,SAAJ,CAAc,8CAAd,CAAN;AACD;AACD,UAAIrD,IAAInF,EAAR,EAAY;AACV,cAAM,IAAIwI,SAAJ,CAAc,2EAAd,CAAN;AACD;;AAED,UAAMif,aAAa,KAAK/K,QAAL,CAAclB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAApC,EAA8C,IAA9C,EAAoD5E,GAApD,EAAyD,KAAzD,CAAnB;AACA,WAAK2iB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjCoJ,iBAASjY,KAAT,CAAe8a,WAAW1d,QAA1B,wBAAwC0d,WAAW1d,QAAnD,EAA8D0d,UAA9D;AACD,OAFD;AAGA,aAAOA,WAAW1d,QAAlB;AACD;;AAED;;;;;;mCAGeyR,I,EAAMwM,K,EAAO;AAC1B,UAAMje,WAAWyR,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAAvC;AAAA,UAAiDke,QAAQ,KAAKlB,SAAL,CAAehd,QAAf,CAAzD;;AAEA,UAAIke,MAAMtC,IAAN,CAAWqC,KAAX,CAAJ,EAAuB;AACrB,aAAKV,KAAL,CAAW,EAAClrB,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,KAAK0oB,KAApC,EAA2C7rB,QAAQ,KAAnD,EAAX;AACA,aAAK2rB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjCoJ,mBAASjY,KAAT,CAAeqb,KAAf,IAAwB,EAAxB;AACD,SAFD;AAGD;AACF;;AAED;;;;;;;8BAIUxM,I,EAAMlc,G,EAAK4oB,K,EAAO;AAAA;;AAC1B,UAAMne,WAAWyR,KAAKzb,MAAL,KAAgB,CAAhB,GAAoB7G,OAApB,GAA8BsiB,KAAKA,KAAKzb,MAAL,GAAc,CAAnB,EAAsBgK,QAArE;AACA,UAAMgS,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;AACA,UAAI,EAAEgS,OAAOzc,GAAP,aAAuB2kB,OAAzB,CAAJ,EAAuC;AACrC,cAAM,IAAIzb,SAAJ,CAAc,wCAAd,CAAN;AACD;;AAED;AACA,UAAMtK,QAAQ6d,OAAOzc,GAAP,EAAYpB,KAAZ,GAAoBgqB,KAAlC;AACA,WAAKZ,KAAL,CAAW,EAAClrB,QAAQ,KAAT,EAAgBiD,KAAK0K,QAArB,EAA+BzK,QAA/B,EAAoCpB,OAAOgqB,KAA3C,EAAkD/rB,QAAQ,KAA1D,EAAX;AACA,WAAK2rB,WAAL,CAAiBtM,IAAjB,EAAuB,oBAAY;AACjCoJ,iBAASjY,KAAT,CAAerN,GAAf,wBAAwB,OAAKd,OAA7B,EAAuC,EAACN,YAAD,EAAQmD,UAAU,SAAlB,EAAvC;AACD,OAFD;AAGD;;;;;;AAGHiR,OAAOC,OAAP,GAAiB;AACfmU;AADe,CAAjB,C;;;;;;;;;;;;;;;;;;;;;;ACpbA;;;;;IAKMzC,O;AACJ,mBAAY/lB,KAAZ,EAAmB;AAAA;;AACjB,SAAKA,KAAL,GAAaA,SAAS,CAAtB;AACAxB,WAAOyrB,MAAP,CAAc,IAAd;AACD;;AAED;;;;;;;;;;;;8BAQU;AACR,aAAO,KAAKjqB,KAAZ;AACD;;AAED;;;;;;;;+BAKW;AACT,aAAO,KAAKkqB,OAAL,GAAexjB,QAAf,EAAP;AACD;;AAED;;;;;;;6BAIS;AACP,aAAO,KAAK1G,KAAZ;AACD;;;;;;AAGH;;;;;;IAIMmqB,gB;;;;;;;;;;;;AACJ;;;;8BAIUH,K,EAAO;AACfA,cAAQ,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,CAA5C;AACA,WAAKI,OAAL,CAAaC,SAAb,CAAuB,KAAK/M,IAA5B,EAAkC,KAAKlc,GAAvC,EAA4C4oB,KAA5C;AACA,WAAKhqB,KAAL,IAAcgqB,KAAd;AACA,aAAO,KAAKhqB,KAAZ;AACD;;AAED;;;;;;;8BAIUgqB,K,EAAO;AACf,aAAO,KAAKK,SAAL,CAAe,OAAOL,KAAP,KAAiB,QAAjB,GAA4B,CAACA,KAA7B,GAAqC,CAAC,CAArD,CAAP;AACD;;;;EAlB4BjE,O;;AAqB/B;;;;;;;;;AAOA,SAASuC,mBAAT,CAA6BtoB,KAA7B,EAAoCoqB,OAApC,EAA6C9M,IAA7C,EAAmDzR,QAAnD,EAA6DzK,GAA7D,EAAkE;AAChE,MAAMgkB,WAAW5mB,OAAO6mB,MAAP,CAAc8E,iBAAiB7E,SAA/B,CAAjB;AACAF,WAASplB,KAAT,GAAiBA,KAAjB;AACAolB,WAASgF,OAAT,GAAmBA,OAAnB;AACAhF,WAAS9H,IAAT,GAAgBA,IAAhB;AACA8H,WAASvZ,QAAT,GAAoBA,QAApB;AACAuZ,WAAShkB,GAAT,GAAeA,GAAf;AACA,SAAOgkB,QAAP;AACD;;AAEDhR,OAAOC,OAAP,GAAiB,EAAE0R,gBAAF,EAAWuC,wCAAX,EAAjB,C;;;;;;;;;;;;;;;;;;;;eCnFgEvtB,mBAAOA,CAAC,4CAAR,C;IAAxDyqB,O,YAAAA,O;IAAS2C,K,YAAAA,K;IAAOC,K,YAAAA,K;IAAO3C,S,YAAAA,S;IAAWC,S,YAAAA,S;IAAW2C,M,YAAAA,M;;gBACXttB,mBAAOA,CAAC,sCAAR,C;IAAlCC,O,aAAAA,O;IAASuqB,Q,aAAAA,Q;IAAUtqB,U,aAAAA,U;;AAC3B,IAAMstB,OAAOxtB,mBAAOA,CAAC,kCAAR,CAAb;;gBAC4CA,mBAAOA,CAAC,gDAAR,C;IAApCmrB,c,aAAAA,c;IAAgB+B,e,aAAAA,e;;gBACIltB,mBAAOA,CAAC,wCAAR,C;IAApBuvB,e,aAAAA,e;;gBACYvvB,mBAAOA,CAAC,wCAAR,C;IAAZytB,O,aAAAA,O;;gBACSztB,mBAAOA,CAAC,kCAAR,C;IAAT4qB,I,aAAAA,I;;gBACU5qB,mBAAOA,CAAC,oCAAR,C;IAAV8qB,K,aAAAA,K;;gBACY9qB,mBAAOA,CAAC,wCAAR,C;IAAZgrB,O,aAAAA,O;;AAER;;;;;;AAIA,SAASwE,YAAT,CAAsBjqB,OAAtB,EAA+B;AAC7B,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAIgK,SAAJ,2CAAqDhK,OAArD,yCAAqDA,OAArD,GAAN;AACD;AACD,MAAI,CAAC,cAAc8U,IAAd,CAAmB9U,OAAnB,CAAL,EAAkC;AAChC,UAAM,IAAIG,UAAJ,CAAe,mDAAf,CAAN;AACD;AACD,MAAIH,QAAQuB,MAAR,GAAiB,CAAjB,KAAuB,CAA3B,EAA8B;AAC5B,UAAM,IAAIpB,UAAJ,CAAe,kDAAf,CAAN;AACD;AACF;;AAED;;;;;AAKA,SAAS+pB,gBAAT,CAA0B7X,GAA1B,EAA+BsT,OAA/B,EAAwCtP,KAAxC,EAA+C;AAC7C,MAAI8T,SAASxE,QAAQjrB,OAAR,CAAb;AACA,MAAI,CAACyvB,MAAL,EAAa;AACXA,aAASxC,gBAAgBtV,IAAIwV,KAAJ,EAAWntB,OAAX,CAAhB,CAAT;AACAirB,YAAQjrB,OAAR,IAAmByvB,MAAnB;AACD;AACDjsB,SAAO4oB,cAAP,CAAsBqD,MAAtB,EAA8BjF,OAA9B,EAAwC,EAACxlB,OAAO2S,IAAI6S,OAAJ,CAAR,EAAxC;AACAhnB,SAAO4oB,cAAP,CAAsBqD,MAAtB,EAA8BtC,KAA9B,EAAwC,EAACnoB,OAAOimB,OAAR,EAAxC;AACAznB,SAAO4oB,cAAP,CAAsBqD,MAAtB,EAA8BrC,KAA9B,EAAwC,EAACpoB,OAAO2W,KAAR,EAAxC;;AAEA,MAAIhE,IAAI6S,OAAJ,EAAayE,MAAjB,EAAyB;AAAA;AAAA;AAAA;;AAAA;AACvB,2BAAqBzrB,OAAOgD,IAAP,CAAYykB,OAAZ,CAArB,8HAA2C;AAAA,YAAlCpa,QAAkC;;AACzC,YAAIoa,QAAQpa,QAAR,aAA6Bga,KAAjC,EAAwC;AACtCI,kBAAQpa,QAAR,EAAkB6e,OAAlB;AACD,SAFD,MAEO,IAAIzE,QAAQpa,QAAR,aAA6B8Z,IAAjC,EAAuC;AAC5CnnB,iBAAOyrB,MAAP,CAAchE,QAAQpa,QAAR,EAAkBkc,KAAhC;AACAvpB,iBAAOyrB,MAAP,CAAchE,QAAQpa,QAAR,CAAd;AACD,SAHM,MAGA;AACLrN,iBAAOyrB,MAAP,CAAchE,QAAQpa,QAAR,CAAd;AACArN,iBAAOyrB,MAAP,CAAchE,QAAQpa,QAAR,EAAkB6Z,SAAlB,CAAd;AACD;AACF;AAXsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYxB;;AAtB4C;AAAA;AAAA;;AAAA;AAwB7C,0BAAqBlnB,OAAOgD,IAAP,CAAYmR,IAAIwV,KAAJ,CAAZ,CAArB,mIAA8C;AAAA,UAArCtc,SAAqC;;AAC5C,UAAI,CAACoa,QAAQpa,SAAR,CAAL,EAAwB;AACtBoa,gBAAQpa,SAAR,IAAoB8G,IAAIwV,KAAJ,EAAWtc,SAAX,CAApB;AACD;AACF;AA5B4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA8B7C,MAAI8G,IAAI6S,OAAJ,EAAayE,MAAjB,EAAyB;AACvBzrB,WAAOyrB,MAAP,CAAchE,OAAd;AACD;AACD,SAAOwE,MAAP;AACD;;AAED;;;;;;;;;AASA,SAASE,UAAT,CAAoBhY,GAApB,EAAyBgJ,WAAzB,EAAsCyO,OAAtC,EAA+C9Y,OAA/C,EAAwD;AACtD,MAAM9R,QAAQorB,WAAWjY,GAAX,CAAd;AACA,MAAI,CAACnT,KAAL,EAAY;AACV,UAAM,IAAI2V,KAAJ,CAAU,uEAAV,CAAN;AACD;AACD,MAAMwB,QAAQ1b,WAAW0X,IAAIyV,KAAJ,CAAX,CAAd;AACAzR,QAAMlX,GAAN,IAAa,CAAb;;AAEA,MAAM6Z,UAAU;AACdqC,4BADc,EACDnc,YADC,EACMC,KAAKkX,MAAMlX,GADjB;AAEdE,UAAM+M,KAAKme,KAAL,CAAW,IAAI1E,IAAJ,GAAWwC,OAAX,KAAuB,IAAlC,CAFQ;AAGd/oB,aAAU0R,WAAW,OAAOA,QAAQ1R,OAAf,KAA2B,QAAvC,GAAmD0R,QAAQ1R,OAA3D,GAAqE,EAHhE;AAIdua,aAASxD,MAAMwD;AAJD,GAAhB;AAMA,MAAI7I,WAAWA,QAAQwK,QAAR,KAAqB,KAApC,EAA2C;AACzCxC,YAAQwC,QAAR,GAAmB,KAAnB;AACD;AACD,MAAIsO,OAAJ,EAAa;AACX9Q,YAAQtY,GAAR,GAAcopB,QAAQppB,GAAtB;AACD;;AAED,MAAI2R,IAAI6S,OAAJ,EAAa9M,OAAjB,EAA0B;AAAA,gCACM/F,IAAI6S,OAAJ,EAAa9M,OAAb,CAAqBgD,gBAArB,CAAsC/E,MAAM8B,YAA5C,EAA0Da,OAA1D,CADN;AAAA;AAAA,QACjBb,YADiB;AAAA,QACH0C,KADG;;AAExBxE,UAAM8B,YAAN,GAAqBA,YAArB;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,CAACqS,gBAAgBnY,GAAhB,EAAqBwI,KAArB,EAA4BxE,KAA5B,EAAmC,IAAnC,CAAD,EAA2C2C,OAA3C,CAAP;AAED,GAVD,MAUO;AACL,QAAI,CAAC8Q,OAAL,EAAcA,UAAU,IAAI5B,OAAJ,CAAY7V,GAAZ,EAAiBnT,KAAjB,CAAV;AACd,QAAMurB,gBAAgB9vB,WAAWqe,OAAX,CAAtB;AACAyR,kBAAcC,MAAd,GAAuBrY,GAAvB;AACAgE,UAAMsU,QAAN,GAAiBtU,MAAMsU,QAAN,CAAevpB,MAAf,CAAsB,CAACqpB,aAAD,CAAtB,CAAjB;AACA,WAAO,CAACP,iBAAiB7X,GAAjB,EAAsByX,QAAQnE,OAA9B,EAAuCtP,KAAvC,CAAD,EAAgD2C,OAAhD,CAAP;AACD;AACF;;AAED;;;;;;;AAOA,SAASwR,eAAT,CAAyBnY,GAAzB,EAA8BwI,KAA9B,EAAqCxE,KAArC,EAA4CuU,WAA5C,EAAyD;AACvD,MAAM1rB,QAAQorB,WAAWjY,GAAX,CAAd;AACA,MAAMsT,UAAU,EAAhB;AACAC,iBAAe/K,MAAMV,KAArB,EAA4B9H,GAA5B,EAAiCsT,OAAjC;;AAEA,MAAIiF,WAAJ,EAAiB;AACf,QAAI,CAAC/P,MAAMP,KAAX,EAAkB,MAAM,IAAIna,UAAJ,CAAe,8BAAf,CAAN;AAClB,QAAI0a,MAAMP,KAAN,CAAYpb,KAAZ,KAAsB2b,MAAMP,KAAN,CAAYpb,KAAZ,IAAqBmX,MAAMlX,GAArD,EAA0D;AACxDkX,YAAMlX,GAAN,GAAY0b,MAAMP,KAAN,CAAYpb,KAAZ,CAAZ;AACD;AACDmX,UAAMiE,KAAN,GAAgBO,MAAMP,KAAtB;AACAjE,UAAM3O,IAAN,GAAgBmT,MAAMnT,IAAtB;AACA2O,UAAMwD,OAAN,GAAgBgB,MAAMhB,OAAtB;AACAxD,UAAMqE,OAAN,GAAgBG,MAAMH,OAAtB;AACArE,UAAMsE,OAAN,GAAgBE,MAAMF,OAAtB;AACD;AACD,SAAOuP,iBAAiB7X,GAAjB,EAAsBsT,OAAtB,EAA+BtP,KAA/B,CAAP;AACD;;AAED;;;AAGA,SAASsD,IAAT,CAAc3I,OAAd,EAAuB;AACrB,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,cAAU,EAAChR,SAASgR,OAAV,EAAV;AACD,GAFD,MAEO,IAAI,OAAOA,OAAP,KAAmB,WAAvB,EAAoC;AACzCA,cAAU,EAAV;AACD,GAFM,MAEA,IAAI,CAACiU,SAASjU,OAAT,CAAL,EAAwB;AAC7B,UAAM,IAAIhH,SAAJ,4CAAuDgH,OAAvD,CAAN;AACD;;AAED,MAAI,CAACA,QAAQ6Z,YAAb,EAA2B;AACzB,QAAI7Z,QAAQhR,OAAR,KAAoBL,SAAxB,EAAmC;AACjCqR,cAAQhR,OAAR,GAAkBioB,MAAlB;AACD;AACDgC,iBAAajZ,QAAQhR,OAArB;AACD;;AAED,MAAM4nB,OAAO,EAAb;AAAA,MAAiBQ,4BAAU1tB,OAAV,EAAoBktB,IAApB,CAAjB;AACA,MAAMvR,QAAQ,EAAClX,KAAK,CAAN,EAASwrB,UAAU,EAAnB,EAAuB9Q,SAAS,CAAhC,EAAmCS,OAAO,EAA1C,EAA8C5S,MAAM,EAApD,EAAwDgT,SAAS,KAAjE,EAAwEC,SAAS,KAAjF,EAAd;AACA,MAAI3J,QAAQoH,OAAZ,EAAqB;AACnB/B,UAAM8B,YAAN,GAAqBnH,QAAQoH,OAAR,CAAgBuB,IAAhB,EAArB;AACD;AACDzb,SAAO4oB,cAAP,CAAsBc,IAAtB,EAA4BzC,SAA5B,EAAuC,EAACzlB,OAAOhF,OAAR,EAAvC;AACAwD,SAAO4oB,cAAP,CAAsBc,IAAtB,EAA4B1C,OAA5B,EAAuC,EAACxlB,OAAOxB,OAAOyrB,MAAP,CAAc3Y,OAAd,CAAR,EAAvC;AACA9S,SAAO4oB,cAAP,CAAsBc,IAAtB,EAA4BxC,SAA5B,EAAuC,EAAC1lB,OAAOxB,OAAOyrB,MAAP,CAAc,EAAd,CAAR,EAAvC;AACAzrB,SAAO4oB,cAAP,CAAsBc,IAAtB,EAA4BC,KAA5B,EAAuC,EAACnoB,OAAOxB,OAAOyrB,MAAP,CAAcvB,KAAd,CAAR,EAAvC;AACAlqB,SAAO4oB,cAAP,CAAsBc,IAAtB,EAA4BE,KAA5B,EAAuC,EAACpoB,OAAOxB,OAAOyrB,MAAP,CAActT,KAAd,CAAR,EAAvC;AACA,SAAOnY,OAAOyrB,MAAP,CAAc/B,IAAd,CAAP;AACD;;AAED;;;AAGA,SAASjT,IAAT,CAAcmW,YAAd,EAA4B9Z,OAA5B,EAAqC;AACnC,SAAOvQ,OAAOkZ,KAAK3I,OAAL,CAAP,EAAsB,gBAAtB,EAAwC;AAAA,WAAO9S,OAAOC,MAAP,CAAckU,GAAd,EAAmByY,YAAnB,CAAP;AAAA,GAAxC,CAAP;AACD;;AAGD;;;;;;;;;;;;;AAaA,SAASrqB,MAAT,CAAgB4R,GAAhB,EAAqBrB,OAArB,EAA8BoY,QAA9B,EAAwC;AACtC,MAAI/W,IAAI8S,SAAJ,MAAmBzqB,OAAvB,EAAgC;AAC9B,UAAM,IAAIsP,SAAJ,CAAc,kEAAd,CAAN;AACD;AACD,MAAIqI,IAAI0V,MAAJ,CAAJ,EAAiB;AACf,UAAM,IAAI/d,SAAJ,CAAc,4CAAd,CAAN;AACD;AACD,MAAI,OAAOgH,OAAP,KAAmB,UAAnB,IAAiCoY,aAAazpB,SAAlD,EAA6D;AAC3D,KAD2D,WACpC,CAACypB,QAAD,EAAWpY,OAAX,CADoC;AACzDA,WADyD;AAChDoY,YADgD;AAE5D;AACD,MAAI,OAAOpY,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,cAAU,EAAC1R,SAAS0R,OAAV,EAAV;AACD;AACD,MAAIA,YAAYrR,SAAZ,IAAyB,CAACslB,SAASjU,OAAT,CAA9B,EAAiD;AAC/C,UAAM,IAAIhH,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,MAAMhK,UAAUsqB,WAAWjY,GAAX,CAAhB;AACA,MAAI,CAACrS,OAAL,EAAc;AACZ,UAAM,IAAI6U,KAAJ,CAAU,uEAAV,CAAN;AACD;AACD,MAAMiV,UAAU,IAAI5B,OAAJ,CAAY7V,GAAZ,EAAiBrS,OAAjB,CAAhB;AACAopB,WAASY,gBAAgBF,OAAhB,CAAT;;AAEA,MAAI5rB,OAAOgD,IAAP,CAAY4oB,QAAQnE,OAApB,EAA6BpkB,MAA7B,KAAwC,CAA5C,EAA+C;AAC7C;AACA,WAAO,CAAC8Q,GAAD,EAAM,IAAN,CAAP;AACD,GAHD,MAGO;AACL,WAAOgY,WAAWhY,GAAX,EAAgB,QAAhB,EAA0ByX,OAA1B,EAAmC9Y,OAAnC,CAAP;AACD;AACF;;AAED;;;;;;;;AAQA,SAAS+Z,WAAT,CAAqB1Y,GAArB,EAA0BrB,OAA1B,EAAmC;AACjC,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,cAAU,EAAC1R,SAAS0R,OAAV,EAAV;AACD;AACD,MAAIA,YAAYrR,SAAZ,IAAyB,CAACslB,SAASjU,OAAT,CAA9B,EAAiD;AAC/C,UAAM,IAAIhH,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,MAAMhK,UAAUsqB,WAAWjY,GAAX,CAAhB;AACA,MAAI,CAACrS,OAAL,EAAc;AACZ,UAAM,IAAI6U,KAAJ,CAAU,uEAAV,CAAN;AACD;AACD,SAAOwV,WAAWhY,GAAX,EAAgB,QAAhB,EAA0B,IAAI6V,OAAJ,CAAY7V,GAAZ,EAAiBrS,OAAjB,CAA1B,EAAqDgR,OAArD,CAAP;AACD;;AAED;;;;;;AAMA,SAASmX,UAAT,CAAoB9V,GAApB,EAAyBwI,KAAzB,EAAgC;AAC9B,MAAMxE,QAAQ1b,WAAW0X,IAAIyV,KAAJ,CAAX,CAAd;;AAEA,MAAIzV,IAAI6S,OAAJ,EAAa9M,OAAjB,EAA0B;AACxB,QAAI,CAACyC,MAAMxE,KAAX,EAAkB;AAChB,YAAM,IAAIlW,UAAJ,CAAe,+EAAf,CAAN;AACD;AACDkW,UAAM8B,YAAN,GAAqB0C,MAAMxE,KAA3B;AACA,WAAOmU,gBAAgBnY,GAAhB,EAAqBwI,KAArB,EAA4BxE,KAA5B,EAAmC,IAAnC,CAAP;AACD;;AAED,MAAI2U,gBAAJ;;AAEA,MAAI3U,MAAMsU,QAAN,CAAeppB,MAAf,GAAwB,CAA5B,EAA+B;AAC7BypB,cAAU3U,MAAMsU,QAAN,CAAe,CAAf,EAAkBD,MAA5B;AACA,QAAI7P,MAAM3b,KAAN,KAAgBorB,WAAWjY,GAAX,CAAhB,IAAmCwI,MAAM1b,GAAN,KAAcQ,SAArD,EAAgE;AAC9D,UAAI0W,MAAMsU,QAAN,CAAe,CAAf,EAAkBxrB,GAAlB,KAA0B0b,MAAM1b,GAApC,EAAyC;AACvC,cAAM,IAAIgB,UAAJ,wCAAoD0a,MAAM1b,GAA1D,qCAA6FkX,MAAMsU,QAAN,CAAe,CAAf,EAAkBxrB,GAA/G,CAAN;AACD;AACDkX,YAAMsU,QAAN,GAAiBtU,MAAMsU,QAAN,CAAe9gB,KAAf,CAAqB,CAArB,EAAwBlJ,GAAxB,CAA4BhG,UAA5B,CAAjB;AACD,KALD,MAKO;AACL0b,YAAMsU,QAAN,GAAiBtU,MAAMsU,QAAN,CAAe9gB,KAAf,GAAuBlJ,GAAvB,CAA2BhG,UAA3B,CAAjB;AACD;AACF,GAVD,MAUO;AACLqwB,cAAU3Y,GAAV;AACAgE,UAAMsU,QAAN,GAAiB,EAAjB;AACD;;AAED,MAAIR,SAASK,gBAAgBQ,OAAhB,EAAyBnQ,KAAzB,EAAgCxE,KAAhC,EAAuC,IAAvC,CAAb;AACA,MAAIA,MAAMsU,QAAN,CAAeppB,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,WAAO4oB,MAAP;AACD,GAFD,MAEO;AACL9T,UAAMsU,QAAN,CAAe,CAAf,EAAkBD,MAAlB,GAA2BP,MAA3B;AACA,WAAOD,iBAAiB7X,GAAjB,EAAsB,EAAtB,EAA0BgE,KAA1B,CAAP;AACD;AACF;;AAED;;;;AAIA,SAASqE,OAAT,CAAiBrI,GAAjB,EAAsB;AACpB,SAAO,CAAC,CAACA,IAAIyV,KAAJ,EAAWpN,OAAb,IAAwB,CAACuQ,mBAAmB5Y,GAAnB,CAAhC;AACD;;AAED;;;AAGA,SAAS4Y,kBAAT,CAA4B5Y,GAA5B,EAAiC;AAC/B,SAAOA,IAAIyV,KAAJ,EAAW6C,QAAX,CAAoBnkB,IAApB,CAAyB;AAAA,WAAO,CAAC,MAAD,EAAS,MAAT,EAAiBkT,QAAjB,CAA0BwR,IAAI7P,WAA9B,CAAP;AAAA,GAAzB,CAAP;AACD;;AAED;;;;;;;;;;AAUA,SAASC,IAAT,CAAcjJ,GAAd,EAAmBrB,OAAnB,EAA4B;AAC1B,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,cAAU,EAAC1R,SAAS0R,OAAV,EAAV;AACD;AACD,MAAIA,YAAYrR,SAAZ,IAAyB,CAACslB,SAASjU,OAAT,CAA9B,EAAiD;AAC/C,UAAM,IAAIhH,SAAJ,CAAc,6BAAd,CAAN;AACD;AACD,MAAI,CAACqI,IAAIyV,KAAJ,EAAWpN,OAAhB,EAAyB;AACvB,UAAM,IAAI7F,KAAJ,CAAU,4CAAV,CAAN;AACD;AACD,MAAIoW,mBAAmB5Y,GAAnB,CAAJ,EAA6B;AAC3B,UAAM,IAAIwC,KAAJ,CAAU,kDAAV,CAAN;AACD;AACD,SAAOwV,WAAWhY,GAAX,EAAgB,MAAhB,EAAwB,IAAxB,EAA8BrB,OAA9B,CAAP;AACD;;AAED;;;;AAIA,SAAS2J,OAAT,CAAiBtI,GAAjB,EAAsB;AACpB,SAAO,CAAC,CAACA,IAAIyV,KAAJ,EAAWnN,OAAb,IAAwB,CAACsQ,mBAAmB5Y,GAAnB,CAAhC;AACD;;AAED;;;;;;;;;;AAUA,SAASkJ,IAAT,CAAclJ,GAAd,EAAmBrB,OAAnB,EAA4B;AAC1B,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,cAAU,EAAC1R,SAAS0R,OAAV,EAAV;AACD;AACD,MAAIA,YAAYrR,SAAZ,IAAyB,CAACslB,SAASjU,OAAT,CAA9B,EAAiD;AAC/C,UAAM,IAAIhH,SAAJ,CAAc,6BAAd,CAAN;AACD;AACD,MAAI,CAACqI,IAAIyV,KAAJ,EAAWnN,OAAhB,EAAyB;AACvB,UAAM,IAAI9F,KAAJ,CAAU,qCAAV,CAAN;AACD;AACD,MAAIoW,mBAAmB5Y,GAAnB,CAAJ,EAA6B;AAC3B,UAAM,IAAIwC,KAAJ,CAAU,kDAAV,CAAN;AACD;AACD,SAAOwV,WAAWhY,GAAX,EAAgB,MAAhB,EAAwB,IAAxB,EAA8BrB,OAA9B,CAAP;AACD;;AAED;;;AAGA,SAASma,WAAT,CAAqB5N,MAArB,EAA6B;AAC3B,SAAOA,OAAO4H,SAAP,CAAP;AACD;;AAED;;;;;AAKA,SAASiG,aAAT,CAAuB/Y,GAAvB,EAA4B9G,QAA5B,EAAsC;AACpC;AACA;AACA;AACA;AACA,MAAI8G,IAAI0V,MAAJ,CAAJ,EAAiB;AACf,UAAM,IAAI/d,SAAJ,CAAc,+CAAd,CAAN;AACD;AACD,SAAOqI,IAAIwV,KAAJ,EAAWtc,QAAX,CAAP;AACD;;AAED;;;AAGA,SAAS+e,UAAT,CAAoBjY,GAApB,EAAyB;AACvB,SAAOA,IAAIyV,KAAJ,EAAW9nB,OAAX,IAAsBqS,IAAI6S,OAAJ,EAAallB,OAA1C;AACD;;AAED;;;;AAIA,SAASqrB,UAAT,CAAoBhZ,GAApB,EAAyBrS,OAAzB,EAAkC;AAChCiqB,eAAajqB,OAAb;AACA,MAAMqW,QAAQnY,OAAOC,MAAP,CAAc,EAAd,EAAkBkU,IAAIyV,KAAJ,CAAlB,EAA8B,EAAC9nB,gBAAD,EAA9B,CAAd;AACA,SAAOkqB,iBAAiB7X,GAAjB,EAAsB,EAAtB,EAA0BgE,KAA1B,CAAP;AACD;;AAED;;;;AAIA,SAASiV,OAAT,CAAiBjZ,GAAjB,EAAsB;AACpB,SAAOA,IAAIyV,KAAJ,EAAWpgB,IAAlB;AACD;;AAED;;;;;AAKA,SAAS6jB,YAAT,CAAsBhO,MAAtB,EAA8Bzc,GAA9B,EAAmC;AACjC,MAAIyc,OAAO6H,SAAP,KAAqB7H,OAAO6H,SAAP,EAAkBtkB,GAAlB,CAArB,IACA5C,OAAOgD,IAAP,CAAYqc,OAAO6H,SAAP,EAAkBtkB,GAAlB,CAAZ,EAAoCS,MAApC,GAA6C,CADjD,EACoD;AAClD,WAAOgc,OAAO6H,SAAP,EAAkBtkB,GAAlB,CAAP;AACD;AACF;;AAED;;;;AAIA,SAAS0qB,eAAT,CAAyBnZ,GAAzB,EAA8B;AAC5B,SAAOA,IAAIyV,KAAJ,EAAW3P,YAAlB;AACD;;AAEDrE,OAAOC,OAAP,GAAiB;AACf4F,YADe,EACThF,UADS,EACHlU,cADG,EACKsqB,wBADL,EACkB5C,sBADlB;AAEfzN,kBAFe,EAENY,UAFM,EAEAX,gBAFA,EAESY,UAFT;AAGf4P,0BAHe,EAGFC,4BAHE,EAGad,sBAHb,EAGyBe,sBAHzB,EAGqCC,gBAHrC,EAG8CC,0BAH9C;AAIfC,kCAJe;AAKfnG,YALe,EAKTE,YALS,EAKFE;AALE,CAAjB,C;;;;;;;;;;;;;;;;eCpboBhrB,mBAAOA,CAAC,sCAAR,C;IAAZC,O,YAAAA,O;;gBAC6BD,mBAAOA,CAAC,4CAAR,C;IAA7B0qB,S,aAAAA,S;IAAW4C,M,aAAAA,M;IAAQD,K,aAAAA,K;;gBACVrtB,mBAAOA,CAAC,kCAAR,C;IAAT4qB,I,aAAAA,I;;gBACU5qB,mBAAOA,CAAC,oCAAR,C;IAAV8qB,K,aAAAA,K;;AAER,SAASkG,cAAT,CAAwB3qB,GAAxB,EAA6B;AAC3B,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,WAAWgU,IAAX,CAAgBhU,GAAhB,CAA/B,EAAqDA,MAAMuF,SAASvF,GAAT,CAAN;AACrD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAM,IAAIkJ,SAAJ,CAAc,mDAAmDnI,KAAKC,SAAL,CAAehB,GAAf,CAAjE,CAAN;AACD;AACD,MAAIA,MAAM,CAAN,IAAW4qB,MAAM5qB,GAAN,CAAX,IAAyBA,QAAQ6qB,QAAjC,IAA6C7qB,QAAQ,CAAC6qB,QAA1D,EAAoE;AAClE,UAAM,IAAIxrB,UAAJ,CAAe,mDAAmDW,GAAlE,CAAN;AACD;AACD,SAAOA,GAAP;AACD;;AAED,SAAS8qB,WAAT,CAAqB9B,OAArB,EAA8B+B,MAA9B,EAAsC7O,IAAtC,EAA4C;AAC1C,MAAM8O,UAAU;AACdC,YADc,oBACL5f,KADK,EACE6f,SADF,EACa;AACzBlC,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqByO,eAAetf,KAAf,CAArB,EAA4C6f,aAAa,CAAzD,EAA4D,EAA5D;AACA,aAAO,IAAP;AACD,KAJa;AAMdC,QANc,gBAMTvsB,KANS,EAMF0W,KANE,EAMKxB,GANL,EAMU;AACtB,UAAIkJ,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;AACA,WAAK,IAAI1f,QAAQsf,eAAerV,SAAS,CAAxB,CAAjB,EAA6CjK,QAAQsf,eAAe7W,OAAOkJ,KAAKvc,MAA3B,CAArD,EAAyF4K,OAAzF,EAAkG;AAChG2d,gBAAQoC,YAAR,CAAqBlP,IAArB,EAA2B7Q,KAA3B,EAAkCzM,KAAlC;AACD;AACD,aAAO,IAAP;AACD,KAZa;AAcdysB,YAdc,oBAcLhgB,KAdK,EAca;AAAA,wCAARrF,MAAQ;AAARA,cAAQ;AAAA;;AACzBgjB,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqByO,eAAetf,KAAf,CAArB,EAA4C,CAA5C,EAA+CrF,MAA/C;AACA,aAAO,IAAP;AACD,KAjBa;AAmBd8E,OAnBc,iBAmBR;AACJ,UAAIkS,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;AACA,UAAI/N,KAAKvc,MAAL,IAAe,CAAnB,EAAsB;AACtB,UAAM8Y,OAAOyP,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6B6O,MAA7B,EAAqC/N,KAAKvc,MAAL,GAAc,CAAnD,CAAb;AACAuoB,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqBc,KAAKvc,MAAL,GAAc,CAAnC,EAAsC,CAAtC,EAAyC,EAAzC;AACA,aAAO8Y,IAAP;AACD,KAzBa;AA2BdpZ,QA3Bc,kBA2BE;AACd,UAAI6c,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;;AADc,yCAAR/kB,MAAQ;AAARA,cAAQ;AAAA;;AAEdgjB,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqBc,KAAKvc,MAA1B,EAAkC,CAAlC,EAAqCuF,MAArC;AACA;AACA,aAAOgjB,QAAQvB,SAAR,CAAkBsD,MAAlB,EAA0BtqB,MAAjC;AACD,KAhCa;AAkCdyU,SAlCc,mBAkCN;AACN,UAAI8H,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;AACA,UAAI/N,KAAKvc,MAAL,IAAe,CAAnB,EAAsB;AACtB,UAAM0b,QAAQ6M,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6B6O,MAA7B,EAAqC,CAArC,CAAd;AACA/B,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,EAA3B;AACA,aAAOC,KAAP;AACD,KAxCa;AA0CdhK,UA1Cc,kBA0CPmD,KA1CO,EA0CAiW,WA1CA,EA0CwB;AACpC,UAAIvO,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;AACAzV,cAAQqV,eAAerV,KAAf,CAAR;AACA,UAAIiW,gBAAgB1sB,SAApB,EAA+B;AAC7B0sB,sBAAcvO,KAAKvc,MAAL,GAAc6U,KAA5B;AACD;AACD,UAAMkW,UAAU,EAAhB;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,WAApB,EAAiCE,GAAjC,EAAsC;AACpCD,gBAAQrrB,IAAR,CAAa6oB,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6B6O,MAA7B,EAAqCzV,QAAQmW,CAA7C,CAAb;AACD;;AATmC,yCAARzlB,MAAQ;AAARA,cAAQ;AAAA;;AAUpCgjB,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqB5G,KAArB,EAA4BiW,WAA5B,EAAyCvlB,MAAzC;AACA,aAAOwlB,OAAP;AACD,KAtDa;AAwDdpP,WAxDc,qBAwDK;AAAA,yCAARpW,MAAQ;AAARA,cAAQ;AAAA;;AACjBgjB,cAAQ7W,MAAR,CAAe+J,IAAf,EAAqB,CAArB,EAAwB,CAAxB,EAA2BlW,MAA3B;AACA,aAAOgjB,QAAQvB,SAAR,CAAkBsD,MAAlB,EAA0BtqB,MAAjC;AACD;AA3Da,GAAhB;;AAD0C,6BA+DjCsjB,QA/DiC;AAgExC,QAAI/G,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,CAAX;AACAC,YAAQjH,QAAR,IAAoB;AAAA,aAAM/G,KAAK+G,QAAL,GAAN;AAAA,KAApB;AAjEwC;;AAAA,aA+DrB,CAAC,SAAD,EAAY,MAAZ,EAAoB,QAApB,CA/DqB;AA+D1C,2CAAoD;AAA/C,QAAIA,mBAAJ;AAA+C,UAA3CA,QAA2C;AAGnD;;AAED;;AApE0C,+BAqEjC2H,MArEiC;AAwExCV,YAAQU,MAAR,IAAkB,YAAa;AAAA;;AAAA,yCAATC,IAAS;AAATA,YAAS;AAAA;;AAC7B,UAAM3O,OAAOgM,QAAQvB,SAAR,CAAkBsD,MAAlB,EACVlrB,GADU,CACN,UAAC+rB,IAAD,EAAOvgB,KAAP;AAAA,eAAiB2d,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6B6O,MAA7B,EAAqC1f,KAArC,CAAjB;AAAA,OADM,CAAb;AAEA,aAAO,qBAAKqgB,MAAL,GAAaG,IAAb,sBAAkB7O,IAAlB,SAA2B2O,IAA3B,EAAP;AACD,KAJD;AAxEwC;;AAAA,cAqEvB,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,EAA8B,MAA9B,EAAsC,WAAtC,EAAmD,SAAnD,EAA8D,UAA9D,EACC,SADD,EACY,MADZ,EACoB,aADpB,EACmC,KADnC,EAC0C,QAD1C,EACoD,aADpD,EAEC,OAFD,EAEU,MAFV,EAEkB,gBAFlB,EAEoC,UAFpC,CArEuB;AAqE1C,+CAEoE;AAF/D,QAAID,mBAAJ;AAE+D,WAF3DA,MAE2D;AAMnE;;AAED,SAAOV,OAAP;AACD;;AAED,IAAMc,aAAa;AACjB/T,KADiB,eACZgU,MADY,EACJ/rB,GADI,EACC;AAAA,QACRgpB,OADQ,GACoB+C,MADpB,CACR/C,OADQ;AAAA,QACCve,QADD,GACoBshB,MADpB,CACCthB,QADD;AAAA,QACWyR,IADX,GACoB6P,MADpB,CACW7P,IADX;;AAEhB,QAAIlc,QAAQqkB,SAAZ,EAAuB,OAAO5Z,QAAP;AACvB,QAAIzK,QAAQinB,MAAZ,EAAoB,OAAO+B,OAAP;AACpB,QAAIhpB,QAAQgnB,KAAZ,EAAmB,OAAO,EAAC9nB,SAAS8pB,QAAQ9pB,OAAlB,EAAP;AACnB,WAAO8pB,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6BzR,QAA7B,EAAuCzK,GAAvC,CAAP;AACD,GAPgB;AASjBgI,KATiB,eASZ+jB,MATY,EASJ/rB,GATI,EASCpB,KATD,EASQ;AAAA,QACfoqB,OADe,GACuB+C,MADvB,CACf/C,OADe;AAAA,QACNve,QADM,GACuBshB,MADvB,CACNthB,QADM;AAAA,QACIyR,IADJ,GACuB6P,MADvB,CACI7P,IADJ;AAAA,QACU8P,QADV,GACuBD,MADvB,CACUC,QADV;;AAEvB,QAAIhjB,MAAMC,OAAN,CAAc+iB,QAAd,KAA2BA,SAASltB,OAAT,CAAiBkB,GAAjB,KAAyB,CAAxD,EAA2D;AACzD,YAAM,IAAIX,UAAJ,uBAAmCW,GAAnC,0BAAN;AACD;AACDgpB,YAAQiD,SAAR,CAAkB/P,IAAlB,EAAwBlc,GAAxB,EAA6BpB,KAA7B;AACA,WAAO,IAAP;AACD,GAhBgB;AAkBjBstB,gBAlBiB,0BAkBDH,MAlBC,EAkBO/rB,GAlBP,EAkBY;AAAA,QACnBgpB,OADmB,GACmB+C,MADnB,CACnB/C,OADmB;AAAA,QACVve,QADU,GACmBshB,MADnB,CACVthB,QADU;AAAA,QACAyR,IADA,GACmB6P,MADnB,CACA7P,IADA;AAAA,QACM8P,QADN,GACmBD,MADnB,CACMC,QADN;;AAE3B,QAAIhjB,MAAMC,OAAN,CAAc+iB,QAAd,KAA2BA,SAASltB,OAAT,CAAiBkB,GAAjB,KAAyB,CAAxD,EAA2D;AACzD,YAAM,IAAIX,UAAJ,uBAAmCW,GAAnC,0BAAN;AACD;AACDgpB,YAAQmD,YAAR,CAAqBjQ,IAArB,EAA2Blc,GAA3B;AACA,WAAO,IAAP;AACD,GAzBgB;AA2BjBuY,KA3BiB,eA2BZwT,MA3BY,EA2BJ/rB,GA3BI,EA2BC;AAAA,QACRgpB,OADQ,GACc+C,MADd,CACR/C,OADQ;AAAA,QACCve,QADD,GACcshB,MADd,CACCthB,QADD;;AAEhB,WAAO,CAAC4Z,SAAD,EAAY4C,MAAZ,EAAoBrO,QAApB,CAA6B5Y,GAA7B,KAAsCA,OAAOgpB,QAAQvB,SAAR,CAAkBhd,QAAlB,CAApD;AACD,GA9BgB;AAgCjB2hB,0BAhCiB,oCAgCSL,MAhCT,EAgCiB/rB,GAhCjB,EAgCsB;AAAA,QAC7BgpB,OAD6B,GACP+C,MADO,CAC7B/C,OAD6B;AAAA,QACpBve,QADoB,GACPshB,MADO,CACpBthB,QADoB;;AAErC,QAAMgS,SAASuM,QAAQvB,SAAR,CAAkBhd,QAAlB,CAAf;AACA,QAAIzK,OAAOyc,MAAX,EAAmB;AACjB,aAAO,EAAC4P,cAAc,IAAf,EAAqBC,YAAY,IAAjC,EAAP;AACD;AACF,GAtCgB;AAwCjBC,SAxCiB,mBAwCRR,MAxCQ,EAwCA;AAAA,QACP/C,OADO,GACe+C,MADf,CACP/C,OADO;AAAA,QACEve,QADF,GACeshB,MADf,CACEthB,QADF;;AAEf,WAAOrN,OAAOgD,IAAP,CAAY4oB,QAAQvB,SAAR,CAAkBhd,QAAlB,CAAZ,CAAP;AACD;AA3CgB,CAAnB;;AA8CA,IAAM+hB,cAAc;AAClBzU,KADkB,eACbgU,MADa,EACL/rB,GADK,EACA;AAAA,iCACkB+rB,MADlB;AAAA,QACT/C,OADS;AAAA,QACAve,QADA;AAAA,QACUyR,IADV;;AAEhB,QAAIlc,QAAQ8jB,OAAOC,QAAnB,EAA6B,OAAOiF,QAAQvB,SAAR,CAAkBhd,QAAlB,EAA4BqZ,OAAOC,QAAnC,CAAP;AAC7B,QAAI/jB,QAAQqkB,SAAZ,EAAuB,OAAO5Z,QAAP;AACvB,QAAIzK,QAAQinB,MAAZ,EAAoB,OAAO+B,OAAP;AACpB,QAAIhpB,QAAQ,QAAZ,EAAsB,OAAOgpB,QAAQvB,SAAR,CAAkBhd,QAAlB,EAA4BhK,MAAnC;AACtB,QAAI,OAAOT,GAAP,KAAe,QAAf,IAA2B,WAAWgU,IAAX,CAAgBhU,GAAhB,CAA/B,EAAqD;AACnD,aAAOgpB,QAAQsC,cAAR,CAAuBpP,IAAvB,EAA6BzR,QAA7B,EAAuCkgB,eAAe3qB,GAAf,CAAvC,CAAP;AACD;AACD,WAAO8qB,YAAY9B,OAAZ,EAAqBve,QAArB,EAA+ByR,IAA/B,EAAqClc,GAArC,CAAP;AACD,GAXiB;AAalBgI,KAbkB,eAab+jB,MAba,EAaL/rB,GAbK,EAaApB,KAbA,EAaO;AAAA,kCACWmtB,MADX;AAAA,QAChB/C,OADgB;AAAA,QACPve,QADO;AAAA,QACGyR,IADH;;AAEvB8M,YAAQoC,YAAR,CAAqBlP,IAArB,EAA2ByO,eAAe3qB,GAAf,CAA3B,EAAgDpB,KAAhD;AACA,WAAO,IAAP;AACD,GAjBiB;AAmBlBstB,gBAnBkB,0BAmBFH,MAnBE,EAmBM/rB,GAnBN,EAmBW;AAAA,kCACO+rB,MADP;AAAA,QACpB/C,OADoB;AAAA,QACXve,QADW;AAAA,QACDyR,IADC;;AAE3B8M,YAAQ7W,MAAR,CAAe+J,IAAf,EAAqByO,eAAe3qB,GAAf,CAArB,EAA0C,CAA1C,EAA6C,EAA7C;AACA,WAAO,IAAP;AACD,GAvBiB;AAyBlBuY,KAzBkB,eAyBbwT,MAzBa,EAyBL/rB,GAzBK,EAyBA;AAAA,kCACkB+rB,MADlB;AAAA,QACT/C,OADS;AAAA,QACAve,QADA;AAAA,QACUyR,IADV;;AAEhB,QAAI,OAAOlc,GAAP,KAAe,QAAf,IAA2B,WAAWgU,IAAX,CAAgBhU,GAAhB,CAA/B,EAAqD;AACnD,aAAO2qB,eAAe3qB,GAAf,IAAsBgpB,QAAQvB,SAAR,CAAkBhd,QAAlB,EAA4BhK,MAAzD;AACD;AACD,WAAO,CAAC,QAAD,EAAW4jB,SAAX,EAAsB4C,MAAtB,EAA8BrO,QAA9B,CAAuC5Y,GAAvC,CAAP;AACD,GA/BiB;AAiClBosB,0BAjCkB,oCAiCQL,MAjCR,EAiCgB/rB,GAjChB,EAiCqB;AACrC,QAAIA,QAAQ,QAAZ,EAAsB,OAAO,EAACysB,UAAU,IAAX,EAAP;AACtB,QAAIzsB,QAAQqkB,SAAZ,EAAuB,OAAO,EAACgI,cAAc,KAAf,EAAsBC,YAAY,KAAlC,EAAP;;AAFc,kCAIHP,MAJG;AAAA,QAI9B/C,OAJ8B;AAAA,QAIrBve,QAJqB;AAAA,QAIXyR,IAJW;;AAKrC,QAAMO,SAASuM,QAAQvB,SAAR,CAAkBhd,QAAlB,CAAf;;AAEA,QAAI,OAAOzK,GAAP,KAAe,QAAf,IAA2B,WAAWgU,IAAX,CAAgBhU,GAAhB,CAA/B,EAAqD;AACnD,UAAMqL,QAAQsf,eAAe3qB,GAAf,CAAd;AACA,UAAIqL,QAAQoR,OAAOhc,MAAnB,EAA2B,OAAO,EAAC4rB,cAAc,IAAf,EAAqBC,YAAY,IAAjC,EAAP;AAC5B;AACF,GA5CiB;AA8ClBC,SA9CkB,mBA8CTR,MA9CS,EA8CD;AAAA,kCACmBA,MADnB;AAAA,QACR/C,OADQ;AAAA,QACCve,QADD;AAAA,QACWyR,IADX;;AAEf,QAAMO,SAASuM,QAAQvB,SAAR,CAAkBhd,QAAlB,CAAf;AACA,QAAIrK,OAAO,CAAC,QAAD,CAAX;AAHe;AAAA;AAAA;;AAAA;AAIf,2BAAgBhD,OAAOgD,IAAP,CAAYqc,MAAZ,CAAhB;AAAA,YAASzc,GAAT;AAAqCI,aAAKD,IAAL,CAAUH,GAAV;AAArC;AAJe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKf,WAAOI,IAAP;AACD;AApDiB,CAApB;;AAuDA,SAASssB,QAAT,CAAkB1D,OAAlB,EAA2Bve,QAA3B,EAAqCyR,IAArC,EAA2C8P,QAA3C,EAAqD;AACnD,SAAO,IAAIW,KAAJ,CAAU,EAAC3D,gBAAD,EAAUve,kBAAV,EAAoByR,UAApB,EAA0B8P,kBAA1B,EAAV,EAA+CF,UAA/C,CAAP;AACD;;AAED,SAASc,SAAT,CAAmB5D,OAAnB,EAA4Bve,QAA5B,EAAsCyR,IAAtC,EAA4C;AAC1C,SAAO,IAAIyQ,KAAJ,CAAU,CAAC3D,OAAD,EAAUve,QAAV,EAAoByR,IAApB,CAAV,EAAqCsQ,WAArC,CAAP;AACD;;AAED;;;;;;AAMA,SAASK,gBAAT,CAA0B3Q,IAA1B,EAAgCzR,QAAhC,EAA0CuhB,QAA1C,EAAoD;AAClD,MAAMvP,SAAS,KAAKgL,SAAL,CAAehd,QAAf,CAAf;AACA,MAAIzB,MAAMC,OAAN,CAAcwT,MAAd,CAAJ,EAA2B;AACzB,WAAOmQ,UAAU,IAAV,EAAgBniB,QAAhB,EAA0ByR,IAA1B,CAAP;AACD,GAFD,MAEO,IAAIO,kBAAkB8H,IAAlB,IAA0B9H,kBAAkBgI,KAAhD,EAAuD;AAC5D,WAAOhI,OAAOqQ,YAAP,CAAoB,IAApB,EAA0B5Q,IAA1B,CAAP;AACD,GAFM,MAEA;AACL,WAAOwQ,SAAS,IAAT,EAAejiB,QAAf,EAAyByR,IAAzB,EAA+B8P,QAA/B,CAAP;AACD;AACF;;AAED,SAAS9C,eAAT,CAAyBF,OAAzB,EAAkC;AAChCA,UAAQjB,iBAAR,GAA4B8E,gBAA5B;AACA,SAAOH,SAAS1D,OAAT,EAAkBpvB,OAAlB,EAA2B,EAA3B,CAAP;AACD;;AAEDoZ,OAAOC,OAAP,GAAiB,EAAEiW,gCAAF,EAAjB,C;;;;;;;;;;;;;;;;;;;;;;eCrOiCvvB,mBAAOA,CAAC,4CAAR,C;IAAzB0qB,S,YAAAA,S;IAAWC,S,YAAAA,S;;gBACc3qB,mBAAOA,CAAC,sCAAR,C;IAAzBwqB,Q,aAAAA,Q;IAAUtqB,U,aAAAA,U;;AAElB,SAASkzB,WAAT,CAAqBC,UAArB,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA6C;AAAA;AAAA;AAAA;;AAAA;AAC3C,yBAAiBF,UAAjB,8HAA6B;AAAA,UAApBG,IAAoB;;AAC3B,UAAIF,KAAKE,IAAL,MAAeD,KAAKC,IAAL,CAAnB,EAA+B;;AAE/B,UAAI,OAAOF,KAAKE,IAAL,CAAP,KAAsB,QAAtB,IAAkC,OAAOD,KAAKC,IAAL,CAAP,KAAsB,QAA5D,EAAsE;AACpE,eAAOF,KAAKE,IAAL,IAAaD,KAAKC,IAAL,CAApB;AACD,OAFD,MAEO;AACL,YAAMC,QAAQ,KAAKH,KAAKE,IAAL,CAAnB;AAAA,YAA+BE,QAAQ,KAAKH,KAAKC,IAAL,CAA5C;AACA,YAAIC,UAAUC,KAAd,EAAqB;AACrB,YAAID,QAAQC,KAAZ,EAAmB,OAAO,CAAC,CAAR,CAAnB,KAAmC,OAAO,CAAC,CAAR;AACpC;AACF;AAX0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY3C,SAAO,CAAP;AACD;;AAGD;;;;;;IAKM5I,K;AACJ;;;;AAIA,mBAAc;AAAA;;AACZ,SAAK3mB,OAAL,GAAeV,OAAOyrB,MAAP,CAAc,EAAd,CAAf;AACAzrB,WAAOyrB,MAAP,CAAc,IAAd;AACD;;AAED;;;;;;;yBAGKnoB,E,EAAI;AACP,aAAO,KAAK5C,OAAL,CAAa4C,EAAb,CAAP;AACD;;AAED;;;;;;;;;AA0BA;;;;2BAIO4nB,Q,EAAUgF,O,EAAS;AACxB,aAAO,KAAKC,IAAL,CAAUhtB,MAAV,CAAiB+nB,QAAjB,EAA2BgF,OAA3B,CAAP;AACD;;AAED;;;;;;;yBAIKhF,Q,EAAUgF,O,EAAS;AACtB,aAAO,KAAKC,IAAL,CAAUnoB,IAAV,CAAekjB,QAAf,EAAyBgF,OAAzB,CAAP;AACD;;AAED;;;;;;;wBAIIhF,Q,EAAUgF,O,EAAS;AACrB,aAAO,KAAKC,IAAL,CAAU1tB,GAAV,CAAcyoB,QAAd,EAAwBgF,OAAxB,CAAP;AACD;;AAED;;;;;;;;;;;;;yBAUKE,G,EAAK;AACR,UAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B,eAAO,KAAKD,IAAL,CAAUltB,IAAV,CAAemtB,GAAf,CAAP;AACD,OAFD,MAEO,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAClC,eAAO,KAAKD,IAAL,CAAUltB,IAAV,CAAe,UAAC4sB,IAAD,EAAOC,IAAP;AAAA,iBAAgBH,YAAY,CAACS,GAAD,CAAZ,EAAmBP,IAAnB,EAAyBC,IAAzB,CAAhB;AAAA,SAAf,CAAP;AACD,OAFM,MAEA,IAAIlkB,MAAMC,OAAN,CAAcukB,GAAd,CAAJ,EAAwB;AAC7B,eAAO,KAAKD,IAAL,CAAUltB,IAAV,CAAe,UAAC4sB,IAAD,EAAOC,IAAP;AAAA,iBAAgBH,YAAYS,GAAZ,EAAiBP,IAAjB,EAAuBC,IAAvB,CAAhB;AAAA,SAAf,CAAP;AACD,OAFM,MAEA,IAAIM,QAAQ3uB,SAAZ,EAAuB;AAC5B,eAAO,KAAK0uB,IAAL,CAAUltB,IAAV,CAAe,UAAC4sB,IAAD,EAAOC,IAAP;AAAA,iBAAgBH,YAAY,CAAC,IAAD,CAAZ,EAAoBE,IAApB,EAA0BC,IAA1B,CAAhB;AAAA,SAAf,CAAP;AACD,OAFM,MAEA;AACL,cAAM,IAAIhkB,SAAJ,oCAA+CskB,GAA/C,CAAN;AACD;AACF;;AAED;;;;;;SAIC1J,OAAOC,Q;4BAAa;AACnB,UAAIwJ,OAAO,KAAKA,IAAhB;AAAA,UAAsBliB,QAAQ,CAAC,CAA/B;AACA,aAAO;AACL8V,YADK,kBACG;AACN9V,mBAAS,CAAT;AACA,cAAIA,QAAQkiB,KAAK9sB,MAAjB,EAAyB;AACvB,mBAAO,EAACmF,MAAM,KAAP,EAAchH,OAAO2uB,KAAKliB,KAAL,CAArB,EAAP;AACD,WAFD,MAEO;AACL,mBAAO,EAACzF,MAAM,IAAP,EAAP;AACD;AACF;AARI,OAAP;AAUD;;AAED;;;;;;;;6BAKS;AACP,UAAI,CAAC,KAAKye,SAAL,CAAL,EAAsB;AACpB,cAAM,IAAIhlB,UAAJ,CAAe,yCAAf,CAAN;AACD;AACD,aAAOqlB,iBAAiB,KAAKL,SAAL,CAAjB,EAAkCxqB,WAAW,KAAKiE,OAAhB,CAAlC,CAAP;AACD;;AAED;;;;;;;yBAIK4C,E,EAAI9B,K,EAAO;AACd,UAAIxB,OAAOqwB,QAAP,CAAgB,KAAK3vB,OAArB,CAAJ,EAAmC;AACjC,cAAM,IAAIiW,KAAJ,CAAU,mDAAV,CAAN;AACD;AACD,UAAIoQ,SAASvlB,KAAT,KAAmB,CAACoK,MAAMC,OAAN,CAAcrK,KAAd,CAAxB,EAA8C;AAC5CxB,eAAO4oB,cAAP,CAAsBpnB,KAAtB,EAA6B,IAA7B,EAAmC,EAACA,OAAO8B,EAAR,EAAY4rB,YAAY,IAAxB,EAAnC;AACD;AACD,WAAKxuB,OAAL,CAAa4C,EAAb,IAAmB9B,KAAnB;AACD;;AAED;;;;;;2BAGO8B,E,EAAI;AACT,UAAItD,OAAOqwB,QAAP,CAAgB,KAAK3vB,OAArB,CAAJ,EAAmC;AACjC,cAAM,IAAIiW,KAAJ,CAAU,mDAAV,CAAN;AACD;AACD,aAAO,KAAKjW,OAAL,CAAa4C,EAAb,CAAP;AACD;;AAED;;;;;;8BAGU;AACRtD,aAAOyrB,MAAP,CAAc,KAAK/qB,OAAnB;AACAV,aAAOyrB,MAAP,CAAc,IAAd;AACD;;AAED;;;;;;;;iCAKaG,O,EAAS9M,I,EAAM;AAC1B,UAAI,CAAC,KAAKmI,SAAL,CAAL,EAAsB;AACpB,cAAM,IAAIhlB,UAAJ,CAAe,gDAAf,CAAN;AACD;;AAED,UAAM2kB,WAAW5mB,OAAO6mB,MAAP,CAAcyJ,eAAexJ,SAA7B,CAAjB;AACAF,eAASK,SAAT,IAAsB,KAAKA,SAAL,CAAtB;AACAL,eAASgF,OAAT,GAAmBA,OAAnB;AACAhF,eAASlmB,OAAT,GAAmB,KAAKA,OAAxB;AACAkmB,eAAS9H,IAAT,GAAgBA,IAAhB;AACA,aAAO8H,QAAP;AACD;;AAED;;;;;;;6BAIS;AACP,UAAMuJ,OAAO,EAAb;AADO;AAAA;AAAA;;AAAA;AAEP,8BAAe,KAAKI,GAApB;AAAA,cAASjtB,EAAT;AAAyB6sB,eAAK7sB,EAAL,IAAW,KAAK2lB,IAAL,CAAU3lB,EAAV,CAAX;AAAzB;AAFO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGP,aAAO6sB,IAAP;AACD;;;wBA9JS;AAAA;;AACR,aAAOnwB,OAAOgD,IAAP,CAAY,KAAKtC,OAAjB,EAA0ByC,MAA1B,CAAiC,eAAO;AAC7C,YAAMqtB,QAAQ,MAAK9vB,OAAL,CAAakC,GAAb,CAAd;AACA,eAAOmkB,SAASyJ,KAAT,KAAmBA,MAAMltB,EAAN,KAAaV,GAAvC;AACD,OAHM,CAAP;AAID;;AAED;;;;;;wBAGY;AACV,aAAO,KAAK2tB,GAAL,CAASltB,MAAhB;AACD;;AAED;;;;;;;wBAIW;AAAA;;AACT,aAAO,KAAKktB,GAAL,CAAS9tB,GAAT,CAAa;AAAA,eAAM,OAAKwmB,IAAL,CAAU3lB,EAAV,CAAN;AAAA,OAAb,CAAP;AACD;;;;;;AA6IH;;;;;;IAIMgtB,c;;;;;;;;;;;;AACJ;;;;yBAIKhtB,E,EAAI;AACP,UAAIyjB,SAAS,KAAKrmB,OAAL,CAAa4C,EAAb,CAAT,KAA8B,KAAK5C,OAAL,CAAa4C,EAAb,EAAiBA,EAAjB,KAAwBA,EAA1D,EAA8D;AAC5D,YAAM+J,WAAW,KAAK3M,OAAL,CAAa4C,EAAb,EAAiB2jB,SAAjB,CAAjB;AACA,YAAMnI,OAAO,KAAKA,IAAL,CAAU5b,MAAV,CAAiB,CAAC,EAACN,KAAKU,EAAN,EAAU+J,kBAAV,EAAD,CAAjB,CAAb;AACA,eAAO,KAAKue,OAAL,CAAajB,iBAAb,CAA+B7L,IAA/B,EAAqCzR,QAArC,EAA+C,CAAC,IAAD,CAA/C,CAAP;AACD;AACF;;AAED;;;;;;;wBAII5E,G,EAAK;AACP,aAAO,KAAKmjB,OAAL,CAAa6E,WAAb,CAAyB,KAAK3R,IAA9B,EAAoCrW,GAApC,CAAP;AACD;;AAED;;;;;;;2BAIOnF,E,EAAI;AACT,UAAIyjB,SAAS,KAAKrmB,OAAL,CAAa4C,EAAb,CAAT,KAA8B,KAAK5C,OAAL,CAAa4C,EAAb,EAAiBA,EAAjB,KAAwBA,EAA1D,EAA8D;AAC5D,aAAKsoB,OAAL,CAAa8E,cAAb,CAA4B,KAAK5R,IAAjC,EAAuCxb,EAAvC;AACD,OAFD,MAEO;AACL,cAAM,IAAIrB,UAAJ,8BAA0CqB,EAA1C,oBAAN;AACD;AACF;;;;EA/B0B+jB,K;;AAkC7B;;;;;;AAIA,SAASC,gBAAT,CAA0Bja,QAA1B,EAAoC3M,OAApC,EAA6C;AAC3C,MAAMkmB,WAAW5mB,OAAO6mB,MAAP,CAAcQ,MAAMP,SAApB,CAAjB;AACA,MAAI,CAACzZ,QAAL,EAAe;AACb,UAAM,IAAIpL,UAAJ,CAAe,mDAAf,CAAN;AACD;AACD2kB,WAASK,SAAT,IAAsB5Z,QAAtB;AACAuZ,WAASM,SAAT,IAAsBlnB,OAAOyrB,MAAP,CAAc,EAAd,CAAtB;AACA7E,WAASlmB,OAAT,GAAmBA,WAAW,EAA9B;AACA,SAAOkmB,QAAP;AACD;;AAEDhR,OAAOC,OAAP,GAAiB,EAAEwR,YAAF,EAASC,kCAAT,EAAjB,C;;;;;;;;;;;;;;;;;;;;eCnQsB/qB,mBAAOA,CAAC,4CAAR,C;IAAd0qB,S,YAAAA,S;;IAEFE,I;AACJ,gBAAawJ,IAAb,EAAmB;AAAA;;AACjB,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAMpH,QAAQoH,KAAKC,KAAL,CAAW,EAAX,EAAenuB,GAAf,CAAmB;AAAA,eAAU,EAACjB,YAAD,EAAV;AAAA,OAAnB,CAAd;AACA,aAAO4lB,gBAAgB3lB,SAAhB,EAA2B8nB,KAA3B,CAAP;AACD,KAHD,MAGO,IAAI3d,MAAMC,OAAN,CAAc8kB,IAAd,CAAJ,EAAyB;AAC9B,UAAMpH,SAAQoH,KAAKluB,GAAL,CAAS;AAAA,eAAU,EAACjB,YAAD,EAAV;AAAA,OAAT,CAAd;AACA,aAAO4lB,gBAAgB3lB,SAAhB,EAA2B8nB,MAA3B,CAAP;AACD,KAHM,MAGA,IAAIoH,SAASlvB,SAAb,EAAwB;AAC7B,aAAO2lB,gBAAgB3lB,SAAhB,EAA2B,EAA3B,CAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAIqK,SAAJ,0CAAqD6kB,IAArD,CAAN;AACD;AACF;;;;wBAMI1iB,K,EAAO;AACV,aAAO,KAAKsb,KAAL,CAAWtb,KAAX,EAAkBzM,KAAzB;AACD;;AAED;;;;;;SAICklB,OAAOC,Q;4BAAa;AACnB,UAAI4C,QAAQ,KAAKA,KAAjB;AAAA,UAAwBtb,QAAQ,CAAC,CAAjC;AACA,aAAO;AACL8V,YADK,kBACG;AACN9V,mBAAS,CAAT;AACA,cAAIA,QAAQsb,MAAMlmB,MAAlB,EAA0B;AACxB,mBAAO,EAACmF,MAAM,KAAP,EAAchH,OAAO+nB,MAAMtb,KAAN,EAAazM,KAAlC,EAAP;AACD,WAFD,MAEO;AACL,mBAAO,EAACgH,MAAM,IAAP,EAAP;AACD;AACF;AARI,OAAP;AAUD;;AAED;;;;;;;+BAIW;AACT;AACA;AACA;AACA,UAAIqoB,MAAM,EAAV;AAJS;AAAA;AAAA;;AAAA;AAKT,6BAAmB,KAAKtH,KAAxB,8HAA+B;AAAA,cAApBuH,IAAoB;;AAC7B,cAAI,OAAOA,KAAKtvB,KAAZ,KAAsB,QAA1B,EAAoCqvB,OAAOC,KAAKtvB,KAAZ;AACrC;AAPQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQT,aAAOqvB,GAAP;AACD;;AAED;;;;;;;;;;8BAOU;AACR,UAAIE,QAAQ,EAAZ;AACA,UAAIC,QAAQ,EAAZ;AAFQ;AAAA;AAAA;;AAAA;AAGR,8BAAmB,KAAKzH,KAAxB,mIAA+B;AAAA,cAApBuH,IAAoB;;AAC7B,cAAI,OAAOA,KAAKtvB,KAAZ,KAAsB,QAA1B,EAAoC;AAClCwvB,qBAASF,KAAKtvB,KAAd;AACD,WAFD,MAEO;AACL,gBAAIwvB,MAAM3tB,MAAN,GAAe,CAAnB,EAAsB;AACpB0tB,oBAAMhuB,IAAN,CAAWiuB,KAAX;AACAA,sBAAQ,EAAR;AACD;AACDD,kBAAMhuB,IAAN,CAAW+tB,KAAKtvB,KAAhB;AACD;AACF;AAbO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcR,UAAIwvB,MAAM3tB,MAAN,GAAe,CAAnB,EAAsB;AACpB0tB,cAAMhuB,IAAN,CAAWiuB,KAAX;AACD;AACD,aAAOD,KAAP;AACD;;AAED;;;;;;;6BAIS;AACP,aAAO,KAAK7oB,QAAL,EAAP;AACD;;AAED;;;;;;;;iCAKa0jB,O,EAAS9M,I,EAAM;AAC1B,UAAI,CAAC,KAAKmI,SAAL,CAAL,EAAsB;AACpB,cAAM,IAAIhlB,UAAJ,CAAe,gDAAf,CAAN;AACD;;AAED,UAAM2kB,WAAWQ,gBAAgB,KAAKH,SAAL,CAAhB,EAAiC,KAAKsC,KAAtC,CAAjB;AACA3C,eAASgF,OAAT,GAAmBA,OAAnB;AACAhF,eAAS9H,IAAT,GAAgBA,IAAhB;AACA,aAAO8H,QAAP;AACD;;AAED;;;;;;wBAGK3Y,K,EAAOzM,K,EAAO;AACjB,UAAI,KAAKoqB,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAaoC,YAAb,CAA0B,KAAKlP,IAA/B,EAAqC7Q,KAArC,EAA4CzM,KAA5C;AACD,OAFD,MAEO,IAAI,CAAC,KAAKylB,SAAL,CAAL,EAAsB;AAC3B,aAAKsC,KAAL,CAAWtb,KAAX,EAAkBzM,KAAlB,GAA0BA,KAA1B;AACD,OAFM,MAEA;AACL,cAAM,IAAIsK,SAAJ,CAAc,oEAAd,CAAN;AACD;AACD,aAAO,IAAP;AACD;;AAED;;;;;;6BAGSmC,K,EAAkB;AAAA,wCAARrF,MAAQ;AAARA,cAAQ;AAAA;;AACzB,UAAI,KAAKgjB,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAa7W,MAAb,CAAoB,KAAK+J,IAAzB,EAA+B7Q,KAA/B,EAAsC,CAAtC,EAAyCrF,MAAzC;AACD,OAFD,MAEO,IAAI,CAAC,KAAKqe,SAAL,CAAL,EAAsB;AAAA;;AAC3B,wBAAKsC,KAAL,EAAWxU,MAAX,iBAAkB9G,KAAlB,EAAyB,CAAzB,4BAA+BrF,OAAOnG,GAAP,CAAW;AAAA,iBAAU,EAACjB,YAAD,EAAV;AAAA,SAAX,CAA/B;AACD,OAFM,MAEA;AACL,cAAM,IAAIsK,SAAJ,CAAc,oEAAd,CAAN;AACD;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;6BAISmC,K,EAAsB;AAAA,UAAf6f,SAAe,uEAAH,CAAG;;AAC7B,UAAI,KAAKlC,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAa7W,MAAb,CAAoB,KAAK+J,IAAzB,EAA+B7Q,KAA/B,EAAsC6f,SAAtC,EAAiD,EAAjD;AACD,OAFD,MAEO,IAAI,CAAC,KAAK7G,SAAL,CAAL,EAAsB;AAC3B,aAAKsC,KAAL,CAAWxU,MAAX,CAAkB9G,KAAlB,EAAyB6f,SAAzB;AACD,OAFM,MAEA;AACL,cAAM,IAAIhiB,SAAJ,CAAc,oEAAd,CAAN;AACD;AACD,aAAO,IAAP;AACD;;;wBArIa;AACZ,aAAO,KAAKyd,KAAL,CAAWlmB,MAAlB;AACD;;;;;;AAsIH;;;2BACSirB,M;AAGPnH,OAAKL,SAAL,CAAewH,MAAf,IAAyB,YAAmB;AAAA;;AAC1C,QAAM2C,qCAAY,IAAZ,EAAN;;AAD0C,uCAAN1C,IAAM;AAANA,UAAM;AAAA;;AAE1C,WAAO,uBAAMD,MAAN,GAAcG,IAAd,uBAAmBwC,KAAnB,SAA6B1C,IAA7B,EAAP;AACD,GAHD;;;WAHiB,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,EAA8B,MAA9B,EAAsC,WAAtC,EAAmD,SAAnD,EAA8D,UAA9D,EACC,SADD,EACY,MADZ,EACoB,aADpB,EACmC,KADnC,EAC0C,QAD1C,EACoD,aADpD,EAEC,OAFD,EAEU,MAFV,EAEkB,gBAFlB,C;AAAnB,yCAEwD;AAFnD,MAAID,iBAAJ;AAEmD,QAF/CA,MAE+C;AAKvD;;AAED,SAASlH,eAAT,CAAyB/Z,QAAzB,EAAmCkc,KAAnC,EAA0C;AACxC,MAAM3C,WAAW5mB,OAAO6mB,MAAP,CAAcM,KAAKL,SAAnB,CAAjB;AACAF,WAASK,SAAT,IAAsB5Z,QAAtB;AACAuZ,WAAS2C,KAAT,GAAiBA,KAAjB;AACA,SAAO3C,QAAP;AACD;;AAEDhR,OAAOC,OAAP,GAAiB,EAAEsR,UAAF,EAAQC,gCAAR,EAAjB,C;;;;;;;;;;;;AC1KY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAA0B;AAClC;AACA,KAAK,UAAU,IAA0C;AACzD,QAAQ,mCAAO,YAAY,eAAe,EAAE;AAAA,oGAAC,C;AAC7C,KAAK,MAAM,EAEN;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,8BAA8B;AAC9B,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,0BAA0B,iBAAiB;AAC3C,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC1aD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,KAA4D;AAC9D,EAAE,SAC8B;AAChC,CAAC,oBAAoB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA,iFAAiF,yCAAyC;AAC1H;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D;AAC3D;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA,2CAA2C;;AAE3C,6CAA6C;;AAE7C,yCAAyC;;;AAGzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,SAAS;AACT;;AAEA,yBAAyB;AACzB;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D,SAAS;AACnE;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,eAAe;AAChE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;;AAEA,mDAAmD;AACnD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,MAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,qDAAqD,wCAAwC;AAC7F,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,0BAA0B,4CAA4C;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA,gDAAgD,mCAAmC;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D;AAC/D,gDAAgD,wBAAwB;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,0DAA0D;AAC1D,2CAA2C;AAC3C;AACA;AACA,uCAAuC;AACvC,4CAA4C;AAC5C;AACA,6DAA6D;AAC7D,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,4BAA4B,8DAA8D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,kDAAkD;AAClD;AACA,yDAAyD;AACzD,iDAAiD,wBAAwB;AACzE;AACA;AACA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA,sCAAsC,oCAAoC;AAC1E;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;;;AAGA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK,uBAAuB,oBAAoB;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;;AAGA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,SAAS;AACT,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,kCAAkC,6CAA6C;AAC/E;AACA,uBAAuB,uBAAuB,EAAE;AAChD,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE,iCAAiC,kDAAkD;AACnF;AACA,KAAK;AACL,8CAA8C,4CAA4C;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,OAAO;AACP;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,KAAK;AACxD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D;AAC3D,qEAAqE,qBAAqB;AAC1F;;AAEA,wDAAwD;AACxD,qEAAqE,qBAAqB;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sCAAsC;AACtC,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,2DAA2D,sBAAsB;AACjF;AACA,OAAO;AACP;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD,kDAAkD,wBAAwB;AAC1E;;AAEA;AACA,4CAA4C,SAAS;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;;AAEL;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC,eAAe,EAAE;AACvD;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA,wBAAwB;AACxB;AACA,KAAK;;AAEL;AACA,yCAAyC,8BAA8B;AACvE,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,iFAAiF,YAAY;AAC7F,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,0CAA0C,0BAA0B;AACpE,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,0CAA0C,4BAA4B;AACtE,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA,4CAA4C,8BAA8B;AAC1E,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL,2CAA2C;AAC3C;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;;AAEL,wCAAwC;AACxC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA,6DAA6D;;;;AAI7D;;AAEA;;AAEA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAA8C,EAAE;AAC3E,2BAA2B,yCAAyC,EAAE;AACtE;AACA,wBAAwB,0BAA0B,EAAE;AACpD,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC,G;;;;;;;;;;;ACh3JD,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,oDAAW;AAChC,cAAc,mBAAO,CAAC,gDAAS;AAC/B,cAAc,mBAAO,CAAC,gDAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5vDA;AACA,aAAa,mBAAO,CAAC,6EAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,wDAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;ACvSA,cAAc,mBAAO,CAAC,wDAAY;AAClC,gBAAgB,mBAAO,CAAC,6DAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,uBAAuB,kBAAkB,EAAE;AAC3C;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,6DAA6D;AAC7D,2CAA2C;;;;;;;;;;;;AC/S3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yDAAyD,sCAAsC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB,IAAI;AACrD,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAsE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,iBAAiB;AAChD;AACA,qDAAqD,eAAe;AACpE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc,KAAK;AAChE,mBAAmB,UAAU;AAC7B;AACA;AACA,eAAe,UAAU;AACzB,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY,eAAe,aAAa,YAAY,YAAY,cAAc;AAClI;AACA;AACA,CAAC;AACD;AACA;AACA,GAAG;AACH;AACA,yFAAyF,QAAQ;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD,mFAAmF;AACnF,CAAC;AACD,+JAA+J,wCAAwC,aAAa,YAAY,eAAe,EAAE;AACjP,CAAC;AACD;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD,iFAAiF;AACjF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,kCAAkC;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,UAAU,eAAe,iBAAiB,GAAG,gBAAgB;AAC/F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,IAAI;AACvC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,+BAA+B;AAC/B,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iDAAiD;AACjD;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM,IAAI;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAsD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,GAAG;AACH;AACA;AACA,kDAAkD,aAAa,QAAQ,cAAc,8BAA8B,WAAW,qCAAqC,2CAA2C,qBAAqB,iBAAiB,cAAc,EAAE,EAAE,QAAQ,YAAY,aAAa,WAAW,eAAe;AACjU,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,0BAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,OAAO;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oCAAoC,oCAAoC,wCAAwC,+CAA+C,sCAAsC,mFAAmF;AACrU,GAAG;AACH;AACA;AACA;AACA,sEAAsE;AACtE,oEAAoE;AACpE,oEAAoE;AACpE,wEAAwE;AACxE,+EAA+E;AAC/E,yEAAyE;AACzE,2GAA2G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,YAAY,YAAY,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC,QAAQ;AACjD;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,iBAAiB;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,aAAa,cAAc;AAC3B;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,8CAA8C;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAuE;AACzF,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,cAAc;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,4BAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,+IAA+I,oCAAoC;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qCAAqC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,0IAA0I;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6KAA6K,uBAAuB;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,OAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB,cAAc;AACtD;AACA;AACA;AACA,KAAK;AACL,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yLAAyL,uBAAuB;AAChN;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qFAAqF;AACxG;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,uBAAuB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;AACP,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,4GAA4G,cAAc;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,oDAAoD;;;;;;;;;;;;;;ACtxHpD;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjCA,UAAU,mBAAO,CAAC,yDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;;AAEA;A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","file":"automerge.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Automerge\"] = factory();\n\telse\n\t\troot[\"Automerge\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/automerge.js\");\n","const { ROOT_ID, copyObject, parseOpId, equalBytes } = require('../src/common')\nconst {\n  hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n} = require('./encoding')\n\n// Maybe we should be using the platform's built-in hash implementation?\n// Node has the crypto module: https://nodejs.org/api/crypto.html and browsers have\n// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n// However, the WebCrypto API is asynchronous (returns promises), which would\n// force all our APIs to become asynchronous as well, which would be annoying.\n//\n// I think on balance, it's safe enough to use a random library off npm:\n// - We only need one hash function (not a full suite of crypto algorithms);\n// - SHA256 is quite simple and has fairly few opportunities for subtle bugs\n//   (compared to asymmetric cryptography anyway);\n// - It does not need a secure source of random bits and does not need to be\n//   constant-time;\n// - I have reviewed the source code and it seems pretty reasonable.\nconst { Hash } = require('fast-sha256')\n\n// These bytes don't mean anything, they were generated randomly\nconst MAGIC_BYTES = Uint8Array.of(0x85, 0x6f, 0x4a, 0x83)\n\nconst COLUMN_TYPE = {\n  GROUP_CARD: 0, ACTOR_ID: 1, INT_RLE: 2, INT_DELTA: 3, BOOLEAN: 4,\n  STRING_RLE: 5, VALUE_LEN: 6, VALUE_RAW: 7\n}\n\nconst VALUE_TYPE = {\n  NULL: 0, FALSE: 1, TRUE: 2, LEB128_UINT: 3, LEB128_INT: 4, IEEE754: 5,\n  UTF8: 6, BYTES: 7, COUNTER: 8, TIMESTAMP: 9, MIN_UNKNOWN: 10, MAX_UNKNOWN: 15\n}\n\n// make* actions must be at even-numbered indexes in this list\nconst ACTIONS = ['makeMap', 'set', 'makeList', 'del', 'makeText', 'inc', 'makeTable', 'link']\n\nconst COMMON_COLUMNS = {\n  objActor:  0 << 3 | COLUMN_TYPE.ACTOR_ID,\n  objCtr:    0 << 3 | COLUMN_TYPE.INT_RLE,\n  keyActor:  1 << 3 | COLUMN_TYPE.ACTOR_ID,\n  keyCtr:    1 << 3 | COLUMN_TYPE.INT_DELTA,\n  keyStr:    1 << 3 | COLUMN_TYPE.STRING_RLE,\n  idActor:   2 << 3 | COLUMN_TYPE.ACTOR_ID,\n  idCtr:     2 << 3 | COLUMN_TYPE.INT_DELTA,\n  insert:    3 << 3 | COLUMN_TYPE.BOOLEAN,\n  action:    4 << 3 | COLUMN_TYPE.INT_RLE,\n  valLen:    5 << 3 | COLUMN_TYPE.VALUE_LEN,\n  valRaw:    5 << 3 | COLUMN_TYPE.VALUE_RAW,\n  chldActor: 6 << 3 | COLUMN_TYPE.ACTOR_ID,\n  chldCtr:   6 << 3 | COLUMN_TYPE.INT_DELTA\n}\n\nconst CHANGE_COLUMNS = Object.assign({\n  predNum:   7 << 3 | COLUMN_TYPE.GROUP_CARD,\n  predActor: 7 << 3 | COLUMN_TYPE.ACTOR_ID,\n  predCtr:   7 << 3 | COLUMN_TYPE.INT_DELTA\n}, COMMON_COLUMNS)\n\nconst DOC_OPS_COLUMNS = Object.assign({\n  succNum:   8 << 3 | COLUMN_TYPE.GROUP_CARD,\n  succActor: 8 << 3 | COLUMN_TYPE.ACTOR_ID,\n  succCtr:   8 << 3 | COLUMN_TYPE.INT_DELTA\n}, COMMON_COLUMNS)\n\nconst DOC_OPS_COLUMNS_REV = Object.entries(DOC_OPS_COLUMNS)\n  .reduce((acc, [k, v]) => {acc[v] = k; return acc}, [])\n\nconst DOCUMENT_COLUMNS = {\n  actor:     0 << 3 | COLUMN_TYPE.ACTOR_ID,\n  seq:       0 << 3 | COLUMN_TYPE.INT_DELTA,\n  maxOp:     1 << 3 | COLUMN_TYPE.INT_DELTA,\n  time:      2 << 3 | COLUMN_TYPE.INT_DELTA,\n  message:   3 << 3 | COLUMN_TYPE.STRING_RLE,\n  depsNum:   4 << 3 | COLUMN_TYPE.GROUP_CARD,\n  depsIndex: 4 << 3 | COLUMN_TYPE.INT_DELTA\n}\n\n/**\n * Parses a string of the form '12345@someActorId' into an object of the form\n * {counter: 12345, actorId: 'someActorId'}, and any other string into an object\n * of the form {value: 'originalString'}.\n */\nfunction maybeParseOpId(value) {\n  if (value === undefined) return {}\n  // FIXME when parsing the \"key\" of an operation, need to correctly handle\n  // map property names that happen to contain an @ sign\n  return (value.indexOf('@') >= 0) ? parseOpId(value) : {value}\n}\n\n/**\n * Maps an opId of the form {counter: 12345, actorId: 'someActorId'} to the form\n * {counter: 12345, actorNum: 123, actorId: 'someActorId'}, where the actorNum\n * is the index into the `actorIds` array.\n */\nfunction actorIdToActorNum(opId, actorIds) {\n  if (!opId.actorId) return opId\n  const counter = opId.counter\n  const actorNum = actorIds.indexOf(opId.actorId)\n  if (actorNum < 0) throw new RangeError('missing actorId') // should not happen\n  return {counter, actorNum, actorId: opId.actorId}\n}\n\n/**\n * Takes `changes`, an array of changes (represented as JS objects). Returns an\n * object `{changes, actorIds}`, where `changes` is a copy of the argument in\n * which all string opIds have been replaced with `{counter, actorNum}` objects,\n * and where `actorIds` is a lexicographically sorted array of actor IDs occurring\n * in any of the operations. `actorNum` is an index into that array of actorIds.\n * If `single` is true, the actorId of the author of the change is moved to the\n * beginning of the array of actorIds, so that `actorNum` is zero when referencing\n * the author of the change itself. This special-casing is omitted if `single` is\n * false.\n */\nfunction parseAllOpIds(changes, single) {\n  const actors = {}, newChanges = []\n  for (let change of changes) {\n    change = copyObject(change)\n    actors[change.actor] = true\n    change.ops = change.ops.map(op => {\n      op = copyObject(op)\n      op.obj = maybeParseOpId(op.obj)\n      op.key = maybeParseOpId(op.key)\n      op.child = maybeParseOpId(op.child)\n      if (op.pred) op.pred = op.pred.map(parseOpId)\n      if (op.obj.actorId) actors[op.obj.actorId] = true\n      if (op.key.actorId) actors[op.key.actorId] = true\n      if (op.child.actorId) actors[op.child.actorId] = true\n      for (let pred of op.pred) actors[pred.actorId] = true\n      return op\n    })\n    newChanges.push(change)\n  }\n\n  let actorIds = Object.keys(actors).sort()\n  if (single) {\n    actorIds = [changes[0].actor].concat(actorIds.filter(actor => actor !== changes[0].actor))\n  }\n  for (let change of newChanges) {\n    change.actorNum = actorIds.indexOf(change.actor)\n    for (let i = 0; i < change.ops.length; i++) {\n      let op = change.ops[i]\n      op.id = {counter: change.startOp + i, actorNum: change.actorNum, actorId: change.actor}\n      op.obj = actorIdToActorNum(op.obj, actorIds)\n      op.key = actorIdToActorNum(op.key, actorIds)\n      op.child = actorIdToActorNum(op.child, actorIds)\n      op.pred = op.pred.map(pred => actorIdToActorNum(pred, actorIds))\n    }\n  }\n  return {changes: newChanges, actorIds}\n}\n\n/**\n * Encodes the `obj` property of operation `op` into the two columns\n * `objActor` and `objCtr`.\n */\nfunction encodeObjectId(op, columns) {\n  if (op.obj.value === ROOT_ID) {\n    columns.objActor.appendValue(null)\n    columns.objCtr.appendValue(null)\n  } else if (op.obj.actorNum >= 0 && op.obj.counter > 0) {\n    columns.objActor.appendValue(op.obj.actorNum)\n    columns.objCtr.appendValue(op.obj.counter)\n  } else {\n    throw new RangeError(`Unexpected objectId reference: ${JSON.stringify(op.obj)}`)\n  }\n}\n\n/**\n * Encodes the `key` property of operation `op` into the three columns\n * `keyActor`, `keyCtr`, and `keyStr`.\n */\nfunction encodeOperationKey(op, columns) {\n  if (op.key.value === '_head' && op.insert) {\n    columns.keyActor.appendValue(0)\n    columns.keyCtr.appendValue(0)\n    columns.keyStr.appendValue(null)\n  } else if (op.key.value) {\n    columns.keyActor.appendValue(null)\n    columns.keyCtr.appendValue(null)\n    columns.keyStr.appendValue(op.key.value)\n  } else if (op.key.actorNum >= 0 && op.key.counter > 0) {\n    columns.keyActor.appendValue(op.key.actorNum)\n    columns.keyCtr.appendValue(op.key.counter)\n    columns.keyStr.appendValue(null)\n  } else {\n    throw new RangeError(`Unexpected operation key: ${JSON.stringify(op.key)}`)\n  }\n}\n\n/**\n * Encodes the `action` property of operation `op` into the `action` column.\n */\nfunction encodeOperationAction(op, columns) {\n  const actionCode = ACTIONS.indexOf(op.action)\n  if (actionCode >= 0) {\n    columns.action.appendValue(actionCode)\n  } else if (typeof op.action === 'number') {\n    columns.action.appendValue(op.action)\n  } else {\n    throw new RangeError(`Unexpected operation action: ${op.action}`)\n  }\n}\n\n/**\n * Encodes the integer `value` into the two columns `valLen` and `valRaw`,\n * with the datatype tag set to `typeTag`. If `typeTag` is zero, it is set\n * automatically to signed or unsigned depending on the sign of the value.\n * Values with non-zero type tags are always encoded as signed integers.\n */\nfunction encodeInteger(value, typeTag, columns) {\n  let numBytes\n  if (value < 0 || typeTag > 0) {\n    numBytes = columns.valRaw.appendInt53(value)\n    if (!typeTag) typeTag = VALUE_TYPE.LEB128_INT\n  } else {\n    numBytes = columns.valRaw.appendUint53(value)\n    typeTag = VALUE_TYPE.LEB128_UINT\n  }\n  columns.valLen.appendValue(numBytes << 4 | typeTag)\n}\n\n/**\n * Encodes the `value` property of operation `op` into the two columns\n * `valLen` and `valRaw`.\n */\nfunction encodeValue(op, columns) {\n  if ((op.action !== 'set' && op.action !== 'inc') || op.value === null) {\n    columns.valLen.appendValue(VALUE_TYPE.NULL)\n  } else if (op.value === false) {\n    columns.valLen.appendValue(VALUE_TYPE.FALSE)\n  } else if (op.value === true) {\n    columns.valLen.appendValue(VALUE_TYPE.TRUE)\n  } else if (typeof op.value === 'string') {\n    const numBytes = columns.valRaw.appendRawString(op.value)\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.UTF8)\n  } else if (ArrayBuffer.isView(op.value)) {\n    const numBytes = columns.valRaw.appendRawBytes(new Uint8Array(op.value.buffer))\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.BYTES)\n  } else if (op.datatype === 'counter' && typeof op.value === 'number') {\n    encodeInteger(op.value, VALUE_TYPE.COUNTER, columns)\n  } else if (op.datatype === 'timestamp' && typeof op.value === 'number') {\n    encodeInteger(op.value, VALUE_TYPE.TIMESTAMP, columns)\n  } else if (typeof op.datatype === 'number' && op.datatype >= VALUE_TYPE.MIN_UNKNOWN &&\n             op.datatype <= VALUE_TYPE.MAX_UNKNOWN && op.value instanceof Uint8Array) {\n    const numBytes = columns.valRaw.appendRawBytes(op.value)\n    columns.valLen.appendValue(numBytes << 4 | op.datatype)\n  } else if (op.datatype) {\n      throw new RangeError(`Unknown datatype ${op.datatype} for value ${op.value}`)\n  } else if (typeof op.value === 'number') {\n    if (Number.isInteger(op.value) && op.value <= Number.MAX_SAFE_INTEGER && op.value >= Number.MIN_SAFE_INTEGER) {\n      encodeInteger(op.value, 0, columns)\n    } else {\n      // Encode number in 32-bit float if this can be done without loss of precision\n      const buf32 = new ArrayBuffer(4), view32 = new DataView(buf32)\n      view32.setFloat32(0, op.value, true) // true means little-endian\n      if (view32.getFloat32(0, true) === op.value) {\n        columns.valRaw.appendRawBytes(new Uint8Array(buf32))\n        columns.valLen.appendValue(4 << 4 | VALUE_TYPE.IEEE754)\n      } else {\n        const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64)\n        view64.setFloat64(0, op.value, true) // true means little-endian\n        columns.valRaw.appendRawBytes(new Uint8Array(buf64))\n        columns.valLen.appendValue(8 << 4 | VALUE_TYPE.IEEE754)\n      }\n    }\n  } else {\n    throw new RangeError(`Unsupported value in operation: ${op.value}`)\n  }\n}\n\n/**\n * Given decoders for two columns with type tags VALUE_LEN and VALUE_RAW respectively,\n * reads one value from those columns. Returns an object of the form\n * `{value: value, datatype: datatypeTag}`.\n */\nfunction decodeValue(lenColumn, rawColumn) {\n  const sizeTag = lenColumn.readValue()\n  if (sizeTag === VALUE_TYPE.NULL) {\n    return {value: null}\n  } else if (sizeTag === VALUE_TYPE.FALSE) {\n    return {value: false}\n  } else if (sizeTag === VALUE_TYPE.TRUE) {\n    return {value: true}\n  } else if (sizeTag % 16 === VALUE_TYPE.UTF8) {\n    return {value: rawColumn.readRawString(sizeTag >> 4)}\n  } else {\n    const bytes = rawColumn.readRawBytes(sizeTag >> 4), valDecoder = new Decoder(bytes)\n    if (sizeTag % 16 === VALUE_TYPE.LEB128_UINT) {\n      return {value: valDecoder.readUint53()}\n    } else if (sizeTag % 16 === VALUE_TYPE.LEB128_INT) {\n      return {value: valDecoder.readInt53()}\n    } else if (sizeTag % 16 === VALUE_TYPE.IEEE754) {\n      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n      if (bytes.byteLength === 4) {\n        return {value: view.getFloat32(0, true)} // true means little-endian\n      } else if (bytes.byteLength === 8) {\n        return {value: view.getFloat64(0, true)}\n      } else {\n        throw new RangeError(`Invalid length for floating point number: ${bytes.byteLength}`)\n      }\n    } else if (sizeTag % 16 === VALUE_TYPE.COUNTER) {\n      return {value: valDecoder.readInt53(), datatype: 'counter'}\n    } else if (sizeTag % 16 === VALUE_TYPE.TIMESTAMP) {\n      return {value: valDecoder.readInt53(), datatype: 'timestamp'}\n    } else {\n      return {value: bytes, datatype: sizeTag % 16}\n    }\n  }\n}\n\n/**\n * Reads one value from the column `columns[colIndex]` and interprets it based\n * on the column type. `actorIds` is a list of actors that appear in the change;\n * `actorIds[0]` is the actorId of the change's author. Mutates the `result`\n * object with the value, and returns the number of columns processed (this is 2\n * in the case of a pair of VALUE_LEN and VALUE_RAW columns, which are processed\n * in one go).\n */\nfunction decodeValueColumns(columns, colIndex, actorIds, result) {\n  const { columnId, columnName, decoder } = columns[colIndex]\n  if (columnId % 8 === COLUMN_TYPE.VALUE_LEN && colIndex + 1 < columns.length &&\n      columns[colIndex + 1].columnId === columnId + 1) {\n    const { value, datatype } = decodeValue(decoder, columns[colIndex + 1].decoder)\n    result[columnName] = value\n    if (datatype) result[columnName + '_datatype'] = datatype\n    return 2\n  } else if (columnId % 8 === COLUMN_TYPE.ACTOR_ID) {\n    const actorNum = decoder.readValue()\n    if (actorNum === null) {\n      result[columnName] = null\n    } else {\n      if (!actorIds[actorNum]) throw new RangeError(`No actor index ${actorNum}`)\n      result[columnName] = actorIds[actorNum]\n    }\n  } else {\n    result[columnName] = decoder.readValue()\n  }\n  return 1\n}\n\n/**\n * Encodes an array of operations in a set of columns. The operations need to\n * be parsed with `parseAllOpIds()` beforehand. If `forDocument` is true, we use\n * the column structure of a whole document, otherwise we use the column\n * structure for an individual change. Returns an array of `{id, name, encoder}`\n * objects.\n */\nfunction encodeOps(ops, forDocument) {\n  const columns = {\n    objActor  : new RLEEncoder('uint'),\n    objCtr    : new RLEEncoder('uint'),\n    keyActor  : new RLEEncoder('uint'),\n    keyCtr    : new DeltaEncoder(),\n    keyStr    : new RLEEncoder('utf8'),\n    insert    : new BooleanEncoder(),\n    action    : new RLEEncoder('uint'),\n    valLen    : new RLEEncoder('uint'),\n    valRaw    : new Encoder(),\n    chldActor : new RLEEncoder('uint'),\n    chldCtr   : new DeltaEncoder()\n  }\n\n  if (forDocument) {\n    columns.idActor   = new RLEEncoder('uint')\n    columns.idCtr     = new DeltaEncoder()\n    columns.succNum   = new RLEEncoder('uint')\n    columns.succActor = new RLEEncoder('uint')\n    columns.succCtr   = new DeltaEncoder()\n  } else {\n    columns.predNum   = new RLEEncoder('uint')\n    columns.predCtr   = new DeltaEncoder()\n    columns.predActor = new RLEEncoder('uint')\n  }\n\n  for (let op of ops) {\n    encodeObjectId(op, columns)\n    encodeOperationKey(op, columns)\n    columns.insert.appendValue(!!op.insert)\n    encodeOperationAction(op, columns)\n    encodeValue(op, columns)\n\n    if (op.child.counter) {\n      columns.chldActor.appendValue(op.child.actorNum)\n      columns.chldCtr.appendValue(op.child.counter)\n    } else {\n      columns.chldActor.appendValue(null)\n      columns.chldCtr.appendValue(null)\n    }\n\n    if (forDocument) {\n      columns.idActor.appendValue(op.id.actorNum)\n      columns.idCtr.appendValue(op.id.counter)\n      columns.succNum.appendValue(op.succ.length)\n      for (let i = 0; i < op.succ.length; i++) {\n        columns.succActor.appendValue(op.succ[i].actorNum)\n        columns.succCtr.appendValue(op.succ[i].counter)\n      }\n    } else {\n      columns.predNum.appendValue(op.pred.length)\n      for (let i = 0; i < op.pred.length; i++) {\n        columns.predActor.appendValue(op.pred[i].actorNum)\n        columns.predCtr.appendValue(op.pred[i].counter)\n      }\n    }\n  }\n\n  let columnList = []\n  for (let [name, id] of Object.entries(forDocument ? DOC_OPS_COLUMNS : CHANGE_COLUMNS)) {\n    if (columns[name]) columnList.push({id, name, encoder: columns[name]})\n  }\n  return columnList.sort((a, b) => a.id - b.id)\n}\n\n/**\n * Takes a change as decoded by `decodeColumns`, and changes it into the form\n * expected by the rest of the backend. If `forDocument` is true, we use the op\n * structure of a whole document, otherwise we use the op structure for an\n * individual change.\n */\nfunction decodeOps(ops, forDocument) {\n  const newOps = []\n  for (let op of ops) {\n    const newOp = {\n      obj: op.objCtr === null ? ROOT_ID : `${op.objCtr}@${op.objActor}`,\n      key: op.keyCtr === 0 ? '_head' : (op.keyStr || `${op.keyCtr}@${op.keyActor}`),\n      action: ACTIONS[op.action] || op.action\n    }\n    newOp.insert = !!op.insert\n    if (ACTIONS[op.action] === 'set' || ACTIONS[op.action] === 'inc') {\n      newOp.value = op.valLen\n      if (op.valLen_datatype) newOp.datatype = op.valLen_datatype\n    }\n    if (!!op.chldCtr !== !!op.chldActor) {\n      throw new RangeError(`Mismatched child columns: ${op.chldCtr} and ${op.chldActor}`)\n    }\n    if (op.chldCtr !== null) newOp.child = `${op.chldCtr}@${op.chldActor}`\n    if (forDocument) {\n      newOp.id = `${op.idCtr}@${op.idActor}`\n      newOp.succ = op.succNum.map(succ => `${succ.succCtr}@${succ.succActor}`)\n    } else {\n      newOp.pred = op.predNum.map(pred => `${pred.predCtr}@${pred.predActor}`)\n    }\n    newOps.push(newOp)\n  }\n  return newOps\n}\n\nfunction encoderByColumnId(columnId) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEEncoder('utf8')\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Encoder()\n  } else {\n    return new RLEEncoder('uint')\n  }\n}\n\nfunction decoderByColumnId(columnId, buffer) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEDecoder('utf8', buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Decoder(buffer)\n  } else {\n    return new RLEDecoder('uint', buffer)\n  }\n}\n\nfunction makeDecoders(columns, columnSpec) {\n  // By default, every column decodes an empty byte array\n  const emptyBuf = Uint8Array.of(), decoders = {}\n  for (let [columnName, columnId] of Object.entries(columnSpec)) {\n    decoders[columnId] = decoderByColumnId(columnId, emptyBuf)\n  }\n  for (let column of columns) {\n    decoders[column.columnId] = decoderByColumnId(column.columnId, column.buffer)\n  }\n\n  let result = []\n  for (let columnId of Object.keys(decoders).map(id => parseInt(id)).sort((a, b) => a - b)) {\n    let [columnName, _] = Object.entries(columnSpec).find(([name, id]) => id === columnId)\n    if (!columnName) columnName = columnId.toString()\n    result.push({columnId, columnName, decoder: decoders[columnId]})\n  }\n  return result\n}\n\nfunction decodeColumns(columns, actorIds, columnSpec) {\n  columns = makeDecoders(columns, columnSpec)\n  let parsedRows = []\n  while (columns.some(col => !col.decoder.done)) {\n    let row = {}, col = 0\n    while (col < columns.length) {\n      const columnId = columns[col].columnId\n      let groupId = columnId >> 3, groupCols = 1\n      while (col + groupCols < columns.length && columns[col + groupCols].columnId >> 3 === groupId) {\n        groupCols++\n      }\n\n      if (columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        const values = [], count = columns[col].decoder.readValue()\n        for (let i = 0; i < count; i++) {\n          let value = {}\n          for (let colOffset = 1; colOffset < groupCols; colOffset++) {\n            decodeValueColumns(columns, col + colOffset, actorIds, value)\n          }\n          values.push(value)\n        }\n        row[columns[col].columnName] = values\n        col += groupCols\n      } else {\n        col += decodeValueColumns(columns, col, actorIds, row)\n      }\n    }\n    parsedRows.push(row)\n  }\n  return parsedRows\n}\n\nfunction readColumns(decoder, numColumns = Number.MAX_SAFE_INTEGER) {\n  let lastColumnId = -1, columns = []\n  while (!decoder.done && columns.length < numColumns) {\n    const columnId = decoder.readUint32()\n    const columnBuf = decoder.readPrefixedBytes()\n    if (columnId <= lastColumnId) throw new RangeError('Columns must be in ascending order')\n    lastColumnId = columnId\n    columns.push({columnId, buffer: columnBuf})\n  }\n  return columns\n}\n\nfunction decodeChangeHeader(decoder) {\n  let change = {\n    actor:   decoder.readHexString(),\n    seq:     decoder.readUint53(),\n    startOp: decoder.readUint53(),\n    time:    decoder.readInt53(),\n    message: decoder.readPrefixedString(),\n    deps: []\n  }\n  const actorIds = [change.actor], numActorIds = decoder.readUint53()\n  for (let i = 0; i < numActorIds; i++) actorIds.push(decoder.readHexString())\n  const numDeps = decoder.readUint53()\n  for (let i = 0; i < numDeps; i++) {\n    change.deps.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n  change.actorIds = actorIds\n  return change\n}\n\n/**\n * Assembles a chunk of encoded data containing a checksum, headers, and a\n * series of encoded columns. Calls `encodeHeaderCallback` with an encoder that\n * should be used to add the headers. The columns should be given as `columns`.\n */\nfunction encodeContainer(chunkType, columns, encodeHeaderCallback) {\n  const CHECKSUM_SIZE = 4 // checksum is first 4 bytes of SHA-256 hash of the rest of the data\n  const HEADER_SPACE = MAGIC_BYTES.byteLength + CHECKSUM_SIZE + 1 + 5 // 1 byte type + 5 bytes length\n  const body = new Encoder()\n  // Make space for the header at the beginning of the body buffer. We will\n  // copy the header in here later. This is cheaper than copying the body since\n  // the body is likely to be much larger than the header.\n  body.appendRawBytes(new Uint8Array(HEADER_SPACE))\n  encodeHeaderCallback(body)\n\n  for (let column of columns) {\n    const buffer = column.encoder.buffer\n    if (buffer.byteLength > 0) {\n      //if (chunkType === 'document') console.log(`${column.name} column: ${buffer.byteLength} bytes`)\n      body.appendUint53(column.id)\n      body.appendPrefixedBytes(buffer)\n    }\n  }\n\n  const bodyBuf = body.buffer\n  const header = new Encoder()\n  if (chunkType === 'document') {\n    header.appendByte(0)\n  } else if (chunkType === 'change') {\n    header.appendByte(1)\n  } else {\n    throw new RangeError(`Unsupported chunk type: ${chunkType}`)\n  }\n  header.appendUint53(bodyBuf.byteLength - HEADER_SPACE)\n\n  // Compute the hash over chunkType, length, and body\n  const headerBuf = header.buffer\n  const sha256 = new Hash()\n  sha256.update(headerBuf)\n  sha256.update(bodyBuf.subarray(HEADER_SPACE))\n  const hash = sha256.digest(), checksum = hash.subarray(0, CHECKSUM_SIZE)\n\n  // Copy header into the body buffer so that they are contiguous\n  bodyBuf.set(MAGIC_BYTES, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)\n  bodyBuf.set(checksum,    HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE)\n  bodyBuf.set(headerBuf,   HEADER_SPACE - headerBuf.byteLength)\n  //console.log('checksum: ', [...checksum].map(x => `0x${('0' + x.toString(16)).slice(-2)}`).join(', '))\n  return {hash, bytes: bodyBuf.subarray( HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)}\n}\n\nfunction decodeContainerHeader(decoder, computeHash) {\n  if (!equalBytes(decoder.readRawBytes(MAGIC_BYTES.byteLength), MAGIC_BYTES)) {\n    throw new RangeError('Data does not begin with magic bytes 85 6f 4a 83')\n  }\n  const expectedHash = decoder.readRawBytes(4)\n  const hashStartOffset = decoder.offset\n  const chunkType = decoder.readByte()\n  const chunkLength = decoder.readUint53()\n  const header = {chunkType, chunkLength, chunkData: decoder.readRawBytes(chunkLength)}\n\n  if (computeHash) {\n    const sha256 = new Hash()\n    sha256.update(decoder.buf.subarray(hashStartOffset, decoder.offset))\n    const binaryHash = sha256.digest()\n    if (!equalBytes(binaryHash.subarray(0, 4), expectedHash)) {\n      throw new RangeError('checksum does not match data')\n    }\n    header.hash = bytesToHexString(binaryHash)\n  }\n  return header\n}\n\nfunction encodeChange(changeObj) {\n  const { changes, actorIds } = parseAllOpIds([changeObj], true)\n  const change = changes[0]\n\n  const { hash, bytes } = encodeContainer('change', encodeOps(change.ops, false), encoder => {\n    encoder.appendHexString(change.actor)\n    encoder.appendUint53(change.seq)\n    encoder.appendUint53(change.startOp)\n    encoder.appendInt53(change.time)\n    encoder.appendPrefixedString(change.message || '')\n    encoder.appendUint53(actorIds.length - 1)\n    for (let actor of actorIds.slice(1)) encoder.appendHexString(actor)\n    if (!Array.isArray(change.deps)) throw new TypeError('deps is not an array')\n    encoder.appendUint53(change.deps.length)\n    for (let hash of change.deps.slice().sort()) {\n      encoder.appendRawBytes(hexStringToBytes(hash))\n    }\n  })\n\n  const hexHash = bytesToHexString(hash)\n  if (changeObj.hash && changeObj.hash !== hexHash) {\n    throw new RangeError(`Change hash does not match encoding: ${changeObj.hash} != ${hexHash}`)\n  }\n  return bytes\n}\n\nfunction decodeChangeColumns(buffer) {\n  const decoder = new Decoder(buffer)\n  const header = decodeContainerHeader(decoder, true)\n  const chunkDecoder = new Decoder(header.chunkData)\n  if (!decoder.done) throw new RangeError('Encoded change has trailing data')\n  if (header.chunkType !== 1) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const change = decodeChangeHeader(chunkDecoder)\n  change.hash = header.hash\n  change.columns = readColumns(chunkDecoder)\n  return change\n}\n\n/**\n * Decodes one change in binary format into its JS object representation.\n */\nfunction decodeChange(buffer) {\n  const change = decodeChangeColumns(buffer)\n  change.ops = decodeOps(decodeColumns(change.columns, change.actorIds, CHANGE_COLUMNS), false)\n  delete change.actorIds\n  delete change.columns\n  return change\n}\n\n/**\n * Decodes the header fields of a change in binary format, but does not decode\n * the operations. Saves work when we only need to inspect the headers. Only\n * computes the hash of the change if `computeHash` is true.\n */\nfunction decodeChangeMeta(buffer, computeHash) {\n  const header = decodeContainerHeader(new Decoder(buffer), computeHash)\n  if (header.chunkType !== 1) {\n    throw new RangeError('Buffer chunk type is not a change')\n  }\n  const meta = decodeChangeHeader(new Decoder(header.chunkData))\n  if (computeHash) meta.hash = header.hash\n  return meta\n}\n\n/**\n * Takes an Uint8Array that may contain multiple concatenated changes, and\n * returns an array of subarrays, each subarray containing one change.\n */\nfunction splitContainers(buffer) {\n  let decoder = new Decoder(buffer), chunks = [], startOffset = 0\n  while (!decoder.done) {\n    decodeContainerHeader(decoder, false)\n    chunks.push(buffer.subarray(startOffset, decoder.offset))\n    startOffset = decoder.offset\n  }\n  return chunks\n}\n\n/**\n * Decodes a list of changes from the binary format into JS objects.\n * `binaryChanges` is an array of `Uint8Array` objects.\n */\nfunction decodeChanges(binaryChanges) {\n  let decoded = []\n  for (let binaryChange of binaryChanges) {\n    for (let chunk of splitContainers(binaryChange)) {\n      if (chunk[8] === 0) {\n        decoded = decoded.concat(decodeDocument(chunk))\n      } else if (chunk[8] === 1) {\n        decoded.push(decodeChange(chunk))\n      } else {\n        // ignoring chunk of unknown type\n      }\n    }\n  }\n  return decoded\n}\n\nfunction sortOpIds(a, b) {\n  if (a === b) return 0\n  if (a === ROOT_ID) return -1\n  if (b === ROOT_ID) return +1\n  const a_ = parseOpId(a), b_ = parseOpId(b)\n  if (a_.counter < b_.counter) return -1\n  if (a_.counter > b_.counter) return +1\n  if (a_.actorId < b_.actorId) return -1\n  if (a_.actorId > b_.actorId) return +1\n  return 0\n}\n\nfunction groupDocumentOps(changes) {\n  let byObjectId = {}, byReference = {}, objectType = {}\n  for (let change of changes) {\n    for (let i = 0; i < change.ops.length; i++) {\n      const op = change.ops[i], opId = `${op.id.counter}@${op.id.actorId}`\n      const objectId = (op.obj.value === ROOT_ID) ? ROOT_ID : `${op.obj.counter}@${op.obj.actorId}`\n      if (op.action.startsWith('make')) {\n        objectType[opId] = op.action\n        if (op.action === 'makeList' || op.action === 'makeText') {\n          byReference[opId] = {'_head': []}\n        }\n      }\n\n      let key\n      if (objectId === ROOT_ID || objectType[objectId] === 'makeMap' || objectType[objectId] === 'makeTable') {\n        key = op.key.value\n      } else if (objectType[objectId] === 'makeList' || objectType[objectId] === 'makeText') {\n        if (op.insert) {\n          key = opId\n          const ref = (op.key.value === '_head') ? '_head' : `${op.key.counter}@${op.key.actorId}`\n          byReference[objectId][ref].push(opId)\n          byReference[objectId][opId] = []\n        } else {\n          key = `${op.key.counter}@${op.key.actorId}`\n        }\n      } else {\n        throw new RangeError(`Unknown object type for object ${objectId}`)\n      }\n\n      if (!byObjectId[objectId]) byObjectId[objectId] = {}\n      if (!byObjectId[objectId][key]) byObjectId[objectId][key] = {}\n      byObjectId[objectId][key][opId] = op\n      op.succ = []\n\n      for (let pred of op.pred) {\n        const predId = `${pred.counter}@${pred.actorId}`\n        if (!byObjectId[objectId][key][predId]) {\n          throw new RangeError(`No predecessor operation ${predId}`)\n        }\n        byObjectId[objectId][key][predId].succ.push(op.id)\n      }\n    }\n  }\n\n  let ops = []\n  for (let objectId of Object.keys(byObjectId).sort(sortOpIds)) {\n    let keys = []\n    if (objectType[objectId] === 'makeList' || objectType[objectId] === 'makeText') {\n      let stack = ['_head']\n      while (stack.length > 0) {\n        const key = stack.pop()\n        if (key !== '_head') keys.push(key)\n        for (let opId of byReference[objectId][key].sort(sortOpIds)) stack.push(opId)\n      }\n    } else {\n      // FIXME JavaScript sorts based on UTF-16 encoding. We should change this to use the UTF-8\n      // encoding instead (the sort order will be different beyond the basic multilingual plane)\n      keys = Object.keys(byObjectId[objectId]).sort()\n    }\n\n    for (let key of keys) {\n      for (let opId of Object.keys(byObjectId[objectId][key]).sort(sortOpIds)) {\n        const op = byObjectId[objectId][key][opId]\n        if (op.action !== 'del') ops.push(op)\n      }\n    }\n  }\n  return ops\n}\n\n/**\n * Takes a set of operations `ops` loaded from an encoded document, and\n * reconstructs the changes that they originally came from.\n * Does not return anything, only mutates `changes`.\n */\nfunction groupChangeOps(changes, ops) {\n  let changesByActor = {} // map from actorId to array of changes by that actor\n  for (let change of changes) {\n    change.ops = []\n    if (!changesByActor[change.actor]) changesByActor[change.actor] = []\n    if (change.seq !== changesByActor[change.actor].length + 1) {\n      throw new RangeError(`Expected seq = ${changesByActor[change.actor].length + 1}, got ${change.seq}`)\n    }\n    if (change.seq > 1 && changesByActor[change.actor][change.seq - 2].maxOp > change.maxOp) {\n      throw new RangeError('maxOp must increase monotonically per actor')\n    }\n    changesByActor[change.actor].push(change)\n  }\n\n  let opsById = {}\n  for (let op of ops) {\n    if (op.action === 'del') throw new RangeError('document should not contain del operations')\n    op.pred = opsById[op.id] ? opsById[op.id].pred : []\n    opsById[op.id] = op\n    for (let succ of op.succ) {\n      if (!opsById[succ]) {\n        const key = op.insert ? op.id : op.key\n        opsById[succ] = {id: succ, action: 'del', obj: op.obj, key, pred: []}\n      }\n      opsById[succ].pred.push(op.id)\n    }\n    delete op.succ\n  }\n  for (let op of Object.values(opsById)) {\n    if (op.action === 'del') ops.push(op)\n  }\n\n  for (let op of ops) {\n    const { counter, actorId } = parseOpId(op.id)\n    const actorChanges = changesByActor[actorId]\n    // Binary search to find the change that should contain this operation\n    let left = 0, right = actorChanges.length\n    while (left < right) {\n      const index = Math.floor((left + right) / 2)\n      if (actorChanges[index].maxOp < counter) {\n        left = index + 1\n      } else {\n        right = index\n      }\n    }\n    if (left >= actorChanges.length) {\n      throw new RangeError(`Operation ID ${op.id} outside of allowed range`)\n    }\n    actorChanges[left].ops.push(op)\n  }\n\n  for (let change of changes) {\n    change.ops.sort((op1, op2) => sortOpIds(op1.id, op2.id))\n    change.startOp = change.maxOp - change.ops.length + 1\n    delete change.maxOp\n    for (let i = 0; i < change.ops.length; i++) {\n      const op = change.ops[i], expectedId = `${change.startOp + i}@${change.actor}`\n      if (op.id !== expectedId) {\n        throw new RangeError(`Expected opId ${expectedId}, got ${op.id}`)\n      }\n      delete op.id\n    }\n  }\n}\n\nfunction encodeDocumentChanges(changes) {\n  const columns = { // see DOCUMENT_COLUMNS\n    actor     : new RLEEncoder('uint'),\n    seq       : new DeltaEncoder(),\n    maxOp     : new DeltaEncoder(),\n    time      : new DeltaEncoder(),\n    message   : new RLEEncoder('utf8'),\n    depsNum   : new RLEEncoder('uint'),\n    depsIndex : new DeltaEncoder()\n  }\n  let indexByHash = {} // map from change hash to its index in the changes array\n  let heads = {} // change hashes that are not a dependency of any other change\n\n  for (let i = 0; i < changes.length; i++) {\n    const change = changes[i]\n    indexByHash[change.hash] = i\n    heads[change.hash] = true\n\n    columns.actor.appendValue(change.actorNum)\n    columns.seq.appendValue(change.seq)\n    columns.maxOp.appendValue(change.startOp + change.ops.length - 1)\n    columns.time.appendValue(change.time)\n    columns.message.appendValue(change.message)\n    columns.depsNum.appendValue(change.deps.length)\n\n    for (let dep of change.deps) {\n      if (typeof indexByHash[dep] !== 'number') {\n        throw new RangeError(`Unknown dependency hash: ${dep}`)\n      }\n      columns.depsIndex.appendValue(indexByHash[dep])\n      if (heads[dep]) delete heads[dep]\n    }\n  }\n\n  let changesColumns = []\n  for (let [name, id] of Object.entries(DOCUMENT_COLUMNS)) {\n    changesColumns.push({id, name, encoder: columns[name]})\n  }\n  changesColumns.sort((a, b) => a.id - b.id)\n  return { changesColumns, heads: Object.keys(heads).sort() }\n}\n\nfunction decodeDocumentChanges(changes, expectedHeads) {\n  let heads = {} // change hashes that are not a dependency of any other change\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i]\n    change.deps = []\n    for (let index of change.depsNum.map(d => d.depsIndex)) {\n      if (!changes[index] || !changes[index].hash) {\n        throw new RangeError(`No hash for index ${index} while processing index ${i}`)\n      }\n      const hash = changes[index].hash\n      change.deps.push(hash)\n      if (heads[hash]) delete heads[hash]\n    }\n    change.deps.sort()\n    delete change.depsNum\n\n    // Encoding and decoding again to compute the hash of the change\n    changes[i] = decodeChange(encodeChange(change))\n    heads[changes[i].hash] = true\n  }\n\n  const actualHeads = Object.keys(heads).sort()\n  let headsEqual = (actualHeads.length === expectedHeads.length), i = 0\n  while (headsEqual && i < actualHeads.length) {\n    headsEqual = (actualHeads[i] === expectedHeads[i])\n    i++\n  }\n  if (!headsEqual) {\n    throw new RangeError(`Mismatched heads hashes: expected ${expectedHeads.join(', ')}, got ${actualHeads.join(', ')}`)\n  }\n}\n\n/**\n * Transforms a list of changes into a binary representation of the document state.\n */\nfunction encodeDocument(binaryChanges) {\n  const { changes, actorIds } = parseAllOpIds(decodeChanges(binaryChanges), false)\n  const { changesColumns, heads } = encodeDocumentChanges(changes)\n  const opsColumns = encodeOps(groupDocumentOps(changes), true)\n\n  let numChangesColumns = 0\n  for (let column of changesColumns) {\n    if (column.encoder.buffer.byteLength > 0) numChangesColumns++\n  }\n\n  return encodeContainer('document', changesColumns.concat(opsColumns), encoder => {\n    encoder.appendUint53(actorIds.length)\n    for (let actor of actorIds) {\n      encoder.appendHexString(actor)\n    }\n    encoder.appendUint53(heads.length)\n    for (let head of heads.sort()) {\n      encoder.appendRawBytes(hexStringToBytes(head))\n    }\n    encoder.appendUint53(numChangesColumns)\n  }).bytes\n}\n\nfunction decodeDocumentHeader(buffer) {\n  const documentDecoder = new Decoder(buffer)\n  const header = decodeContainerHeader(documentDecoder, true)\n  const decoder = new Decoder(header.chunkData)\n  if (!documentDecoder.done) throw new RangeError('Encoded document has trailing data')\n  if (header.chunkType !== 0) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const actorIds = [], numActors = decoder.readUint53()\n  for (let i = 0; i < numActors; i++) {\n    actorIds.push(decoder.readHexString())\n  }\n  const heads = [], numHeads = decoder.readUint53()\n  for (let i = 0; i < numHeads; i++) {\n    heads.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n\n  const changesColumns = readColumns(decoder, decoder.readUint53())\n  const opsColumns = readColumns(decoder)\n  return { changesColumns, opsColumns, actorIds, heads }\n}\n\nfunction decodeDocument(buffer) {\n  const { changesColumns, opsColumns, actorIds, heads } = decodeDocumentHeader(buffer)\n  const changes = decodeColumns(changesColumns, actorIds, DOCUMENT_COLUMNS)\n  const ops = decodeOps(decodeColumns(opsColumns, actorIds, DOC_OPS_COLUMNS), true)\n  groupChangeOps(changes, ops)\n  decodeDocumentChanges(changes, heads)\n  return changes\n}\n\n/**\n * Takes all the operations for the same property (i.e. the same key in a map, or the same list\n * element) and mutates the object patch to reflect the current value(s) of that property. There\n * might be multiple values in the case of a conflict. `objects` is a map from objectId to the\n * patch for that object. `property` contains `objId`, `key`, and list of `ops`.\n */\nfunction addPatchProperty(objects, property) {\n  let values = {}, counter = null\n  for (let op of property.ops) {\n    // Apply counters and their increments regardless of the number of successor operations\n    if (op.actionName === 'set' && op.value.datatype === 'counter') {\n      if (!counter) counter = {opId: op.opId, value: 0, succ: {}}\n      counter.value += op.value.value\n      for (let succId of op.succ) counter.succ[succId] = true\n    } else if (op.actionName === 'inc') {\n      if (!counter) throw new RangeError(`inc operation ${op.opId} without a counter`)\n      counter.value += op.value.value\n      delete counter.succ[op.opId]\n      for (let succId of op.succ) counter.succ[succId] = true\n\n    } else if (op.succ.length === 0) { // Ignore any ops that have been overwritten\n      if (op.actionName.startsWith('make')) {\n        values[op.opId] = objects[op.opId]\n      } else if (op.actionName === 'set') {\n        values[op.opId] = op.value\n      } else if (op.actionName === 'link') {\n        // NB. This assumes that the ID of the child object is greater than the ID of the current\n        // object. This is true as long as link operations are only used to redo undone make*\n        // operations, but it will cease to be true once subtree moves are allowed.\n        if (!op.childId) throw new RangeError(`link operation ${op.opId} without a childId`)\n        values[op.opId] = objects[op.childId]\n      } else {\n        throw new RangeError(`Unexpected action type: ${op.actionName}`)\n      }\n    }\n  }\n\n  // If the counter had any successor operation that was not an increment, that means the counter\n  // must have been deleted, so we omit it from the patch.\n  if (counter && Object.keys(counter.succ).length === 0) {\n    values[counter.opId] = {value: counter.value, datatype: 'counter'}\n  }\n\n  if (Object.keys(values).length > 0) {\n    let obj = objects[property.objId]\n    if (!obj.props) obj.props = {}\n    if (obj.type === 'map' || obj.type === 'table') {\n      obj.props[property.key] = values\n    } else if (obj.type === 'list' || obj.type === 'text') {\n      if (!obj.edits) obj.edits = []\n      obj.props[obj.edits.length] = values\n      obj.edits.push({action: 'insert', index: obj.edits.length})\n    }\n  }\n}\n\n/**\n * Parses the document (in compressed binary format) given as `documentBuffer`\n * and returns a patch that can be sent to the frontend to instantiate the\n * current state of that document.\n */\nfunction constructPatch(documentBuffer) {\n  const { opsColumns, actorIds } = decodeDocumentHeader(documentBuffer)\n  const col = makeDecoders(opsColumns, DOC_OPS_COLUMNS).reduce(\n    (acc, col) => Object.assign(acc, {[col.columnName]: col.decoder}), {})\n\n  const objType = {makeMap: 'map', makeList: 'list', makeText: 'text', makeTable: 'table'}\n  let objects = {[ROOT_ID]: {objectId: ROOT_ID, type: 'map'}}\n  let property = null\n\n  while (!col.idActor.done) {\n    const opId = `${col.idCtr.readValue()}@${actorIds[col.idActor.readValue()]}`\n    const action = col.action.readValue(), actionName = ACTIONS[action]\n    if (action % 2 === 0) { // even-numbered actions are object creation\n      objects[opId] = {objectId: opId, type: objType[actionName] || 'unknown'}\n    }\n\n    const objActor = col.objActor.readValue(), objCtr = col.objCtr.readValue()\n    const objId = objActor === null ? ROOT_ID : `${objCtr}@${actorIds[objActor]}`\n    let obj = objects[objId]\n    if (!obj) throw new RangeError(`Operation for nonexistent object: ${objId}`)\n\n    const keyActor = col.keyActor.readValue(), keyCtr = col.keyCtr.readValue()\n    const keyStr = col.keyStr.readValue(), insert = !!col.insert.readValue()\n    const chldActor = col.chldActor.readValue(), chldCtr = col.chldCtr.readValue()\n    const childId = chldActor === null ? null : `${chldCtr}@${actorIds[chldActor]}`\n    const value = decodeValue(col.valLen, col.valRaw), succNum = col.succNum.readValue()\n    let succ = []\n    for (let i = 0; i < succNum; i++) {\n      succ.push(`${col.succCtr.readValue()}@${actorIds[col.succActor.readValue()]}`)\n    }\n\n    if (!actionName || obj.type === 'unknown') continue\n\n    let key\n    if (obj.type === 'list' || obj.type === 'text') {\n      if (keyActor === null || keyCtr === null || (keyCtr === 0 && !insert)) {\n        throw new RangeError(`Operation ${opId} on ${obj.type} object has no key`)\n      }\n      key = insert ? opId : `${keyCtr}@${actorIds[keyActor]}`\n    } else {\n      if (keyStr === null) {\n        throw new RangeError(`Operation ${opId} on ${obj.type} object has no key`)\n      }\n      key = keyStr\n    }\n\n    if (!property || property.objId !== objId || property.key !== key) {\n      if (property) addPatchProperty(objects, property)\n      property = {objId, key, ops: []}\n    }\n    property.ops.push({opId, actionName, value, childId, succ})\n  }\n\n  if (property) addPatchProperty(objects, property)\n  return objects[ROOT_ID]\n}\n\n/**\n * Scans a chunk of document operations, encoded as columns `docCols`, to find the position at which\n * an operation (or sequence of operations) `ops` should be inserted. Returns the number of\n * operations, counted from the start of the chunk, after which the insertion should be made.\n */\nfunction seekToOp(ops, docCols, actorIds) {\n  const { objActor, objCtr, keyActor, keyCtr, keyStr, idActor, idCtr, insert, action, consecutiveOps } = ops\n  const [objActorD, objCtrD, keyActorD, keyCtrD, keyStrD, idActorD, idCtrD, insertD, actionD]\n    = docCols.map(col => col.decoder)\n  let skipCount = 0, nextObjActor = null, nextObjCtr = null\n  let nextIdActor = null, nextIdCtr = null, nextKeyStr = null\n\n  // Seek to the beginning of the object being updated\n  if (objCtr !== null) {\n    while (!objCtrD.done || !objActorD.done || !keyStrD.done) {\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      keyStrD.skipValues(1)\n      if (nextObjCtr === null || !nextObjActor || nextObjCtr < objCtr ||\n          (nextObjCtr === objCtr && nextObjActor < objActor)) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n  }\n\n  // Seek to the appropriate key (if string key is used)\n  if (keyStr !== null && nextObjCtr === objCtr && nextObjActor === objActor) {\n    keyStrD.skipValues(skipCount)\n    while (!keyStrD.done) {\n      nextKeyStr = keyStrD.readValue()\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      if (nextKeyStr !== null && nextKeyStr < keyStr &&\n          nextObjCtr === objCtr && nextObjActor === objActor) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n  }\n\n  // Seek to the appropriate list element (if opId key is used)\n  if (keyCtr !== null && keyActor !== null && keyCtr > 0 && nextObjCtr === objCtr && nextObjActor === objActor) {\n    idCtrD.skipValues(skipCount)\n    idActorD.skipValues(skipCount)\n    while (!idCtrD.done && !idActorD.done && (nextIdCtr !== keyCtr || nextIdActor !== keyActor)) {\n      nextIdCtr = idCtrD.readValue()\n      nextIdActor = actorIds[idActorD.readValue()]\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      if (nextObjCtr === objCtr && nextObjActor === objActor) skipCount += 1; else break\n    }\n    if (nextIdCtr !== keyCtr || nextIdActor !== keyActor) {\n      throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`)\n    }\n\n    // Skip over any list elements with greater ID than the new one\n    while (!idCtrD.done && !idActorD.done) {\n      nextIdCtr = idCtrD.readValue()\n      nextIdActor = actorIds[idActorD.readValue()]\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      if ((nextIdCtr > idCtr || (nextIdCtr === idCtr && nextIdActor > idActor)) &&\n          nextObjCtr === objCtr && nextObjActor === objActor) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n  }\n  return skipCount\n}\n\n/**\n * Copies `count` rows from the set of input columns `inCols` to the set of output columns\n * `outCols`. The input columns are given as an array of `{columnId, decoder}` objects, and the\n * output columns are given as an array of `{columnId, encoder}` objects. Both are sorted in\n * increasing order of columnId. If there is no matching input column for a given output column, it\n * is filled in with `count` blank values (according to the column type).\n *\n * If `actorTable` is provided, then for any columns of type ACTOR_ID, every value `v` is mapped to\n * `actorTable[v]`. If `ops` is provided, then the `idCtr` and `idActor` columns are filled in based\n * on `ops.idCtr` and `ops.idActor`.\n */\nfunction copyColumns(outCols, inCols, count, actorTable, ops) {\n  if (count === 0) return\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n    let inCol = null\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId &&\n        inCols[inIndex].decoder.buf.byteLength > 0) {\n      inCol = inCols[inIndex].decoder\n    }\n    const colCount = (outCol.columnId >> 3 === lastGroup) ? lastCardinality : count\n\n    if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 3\n      if (inCol) {\n        lastCardinality = outCol.encoder.copyFrom(inCol, {count, sumValues: true})\n      } else {\n        outCol.encoder.appendValue(0, count)\n        lastCardinality = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n      if (inCol) {\n        if (inIndex + 1 === inCols.length || inCols[inIndex + 1].columnId !== outCol.columnId + 1) {\n          throw new RangeError('VALUE_LEN column without accompanying VALUE_RAW column')\n        }\n        valueColumn = outCol.columnId + 1\n        valueBytes = outCol.encoder.copyFrom(inCol, {count: colCount, sumValues: true, sumShift: 4})\n      } else {\n        outCol.encoder.appendValue(null, colCount)\n        valueColumn = outCol.columnId + 1\n        valueBytes = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (outCol.columnId !== valueColumn) {\n        throw new RangeError('VALUE_RAW column without accompanying VALUE_LEN column')\n      }\n      if (valueBytes > 0) {\n        outCol.encoder.appendRawBytes(inCol.readRawBytes(valueBytes))\n      }\n    } else if (ops && !inCol && outCol.columnId === DOC_OPS_COLUMNS.idActor) {\n      outCol.encoder.appendValue(ops.idActorIndex, colCount)\n    } else if (ops && !inCol && outCol.columnId === DOC_OPS_COLUMNS.idCtr) {\n      for (let i = 0; i < colCount; i++) outCol.encoder.appendValue(ops.idCtr + i)\n    } else { // ACTOR_ID, INT_RLE, INT_DELTA, BOOLEAN, or STRING_RLE\n      if (inCol) {\n        const options = {count: colCount, lookupTable: null}\n        if (outCol.columnId % 8 === COLUMN_TYPE.ACTOR_ID) options.lookupTable = actorTable\n        outCol.encoder.copyFrom(inCol, options)\n      } else {\n        const blankValue = (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) ? false : null\n        outCol.encoder.appendValue(blankValue, colCount)\n      }\n    }\n  }\n}\n\n/**\n * Parses one operation from a set of columns. The argument `columns` contains a list of objects\n * with `columnId` and `decoder` properties. Returns an array in which the i'th element is the\n * value read from the i'th column in `columns`. Does not interpret datatypes; the only\n * interpretation of values is that if `actorTable` is given, a value `v` in a column of type\n * ACTOR_ID is replaced with `actorTable[v]`.\n */\nfunction readOperation(columns, actorTable) {\n  let operation = [], colValue, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let col of columns) {\n    if (col.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (col.columnId !== valueColumn) throw new RangeError('unexpected VALUE_RAW column')\n      colValue = col.decoder.readRawBytes(valueBytes)\n    } else if (col.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = col.columnId >> 3\n      lastCardinality = col.decoder.readValue() || 0\n      colValue = lastCardinality\n    } else if (col.columnId >> 3 === lastGroup) {\n      colValue = []\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = 0\n      }\n      for (let i = 0; i < lastCardinality; i++) {\n        let value = col.decoder.readValue()\n        if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof value === 'number') {\n          value = actorTable[value]\n        }\n        if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n          valueBytes += colValue >>> 4\n        }\n        colValue.push(value)\n      }\n    } else {\n      colValue = col.decoder.readValue()\n      if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof colValue === 'number') {\n        colValue = actorTable[colValue]\n      }\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = colValue >>> 4\n      }\n    }\n\n    operation.push(colValue)\n  }\n  return operation\n}\n\n/**\n * Appends `operation`, in the form returned by `readOperation()`, to the columns in `outCols`. The\n * argument `inCols` provides metadata about the types of columns in `operation`; the value\n * `operation[i]` comes from the column `inCols[i]`.\n */\nfunction appendOperation(outCols, inCols, operation) {\n  console.log('appending:', operation.map((value, idx) => {return {columnName: inCols[idx].columnName, value} }))\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId) {\n      const colValue = operation[inIndex]\n      if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        lastGroup = outCol.columnId >> 3\n        lastCardinality = colValue\n        outCol.encoder.appendValue(colValue)\n      } else if (outCol.columnId >> 3 === lastGroup) {\n        if (!Array.isArray(colValue) || colValue.length !== lastCardinality) {\n          throw new RangeError('bad group value')\n        }\n        for (let v of colValue) outCol.encoder.appendValue(v)\n      } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n        outCol.encoder.appendRawBytes(colValue)\n      } else {\n        outCol.encoder.appendValue(colValue)\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 3\n      lastCardinality = 0\n      outCol.encoder.appendValue(0)\n    } else if (outCol.columnId % 8 !== COLUMN_TYPE.VALUE_RAW) {\n      const count = (outCol.columnId >> 3 === lastGroup) ? lastCardinality : 1\n      let blankValue = null\n      if (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) blankValue = false\n      if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) blankValue = 0\n      outCol.encoder.appendValue(blankValue, count)\n    }\n  }\n}\n\n/**\n * Given a change parsed by `decodeChangeColumns()` and its column decoders as instantiated by\n * `makeDecoders()`, reads the operations in the change and groups together any related operations\n * that can be applied at the same time. Returns an array of operation groups, where each group is\n * an object with a `consecutiveOps` property indicating how many operations are in that group.\n *\n * In order for a set of operations to be related, they have to satisfy the following properties:\n *   1. They must all be for the same object. (Even when several objects are created in the same\n *      change, we don't group together operations from different objects, since those ops may not\n *      be consecutive in the document, since objectIds from different actors can be interleaved.)\n *   2. Operations with string keys must appear in lexicographic order. For operations with opId\n *      keys (i.e. list/text operations), this function does not know whether the order of\n *      operations in the change matches the document order. We optimistically group together any\n *      such operations for the same object, on the basis that the ops are likely to be consecutive\n *      in practice (e.g. deleting a consecutive sequence of characters from text is likely to be\n *      represented by a sequence of deletion operations in document order).\n *\n * A group of operations has the `directCopy` property set to true if the operations are guaranteed\n * to be consecutive in the encoded document, and the operations don't need to update the `succ`\n * property of any existing operations. This is the case when at least one of the following is true:\n *   1. The operations set properties of an object that has been created in the current change, so\n *      these operations are sure to be the first time that those properties have been set.\n *   2. The operations insert a consecutive sequence of list elements/text characters, where each\n *      insertion operation references the immediate predecessor operation as its reference element.\n */\nfunction groupRelatedOps(change, changeCols) {\n  const currentActor = change.actorIds[0]\n  const [objActorD, objCtrD, keyActorD, keyCtrD, keyStrD, idActorD, idCtrD, insertD, actionD]\n    = changeCols.map(col => col.decoder)\n  let objIdSeen = {}, firstOp = null, lastOp = null, opSequences = [], opIdCtr = change.startOp\n\n  while (!actionD.done) {\n    const objActor = objActorD.readValue(), keyActor = keyActorD.readValue()\n    const thisOp = {\n      objActor : objActor === null ? null : change.actorIds[objActor],\n      objCtr   : objCtrD.readValue(),\n      keyActor : keyActor === null ? null : change.actorIds[keyActor],\n      keyCtr   : keyCtrD.readValue(),\n      keyStr   : keyStrD.readValue(),\n      idActor  : currentActor,\n      idCtr    : opIdCtr,\n      insert   : insertD.readValue(),\n      action   : actionD.readValue(),\n      idActorIndex  : -1, // the index of currentActor in the document's actor list, filled in later\n      consecutiveOps: 1,\n      directCopy    : false\n    }\n    if ((thisOp.objCtr === null && thisOp.objActor !== null) ||\n        (thisOp.objCtr !== null && typeof thisOp.objActor !== 'string')) {\n      throw new RangeError(`Mismatched object reference: (${thisOp.objCtr}, ${thisOp.objActor})`)\n    }\n    if ((thisOp.keyCtr === null && thisOp.keyActor !== null) ||\n        (thisOp.keyCtr !== null && typeof thisOp.keyActor !== 'string')) {\n      throw new RangeError(`Mismatched operation key: (${thisOp.keyCtr}, ${thisOp.keyActor})`)\n    }\n    if (thisOp.objActor === currentActor && thisOp.objCtr >= change.startOp &&\n        !objIdSeen[`${thisOp.objCtr}@${thisOp.objActor}`] || thisOp.insert) {\n      thisOp.directCopy = true\n    }\n\n    if (!firstOp) {\n      firstOp = thisOp\n      lastOp = thisOp\n    } else if (thisOp.objActor === lastOp.objActor && thisOp.objCtr === lastOp.objCtr && (\n        (thisOp.keyStr !== null && lastOp.keyStr !== null && lastOp.keyStr <= thisOp.keyStr) ||\n        (thisOp.keyStr === null && lastOp.keyStr === null && !lastOp.insert && !thisOp.insert) ||\n        (thisOp.keyStr === null && lastOp.keyStr === null && lastOp.insert && thisOp.insert &&\n         thisOp.keyActor === lastOp.idActor && thisOp.keyCtr === lastOp.idCtr))) {\n      firstOp.consecutiveOps += 1\n      lastOp = thisOp\n    } else {\n      objIdSeen[`${firstOp.objCtr}@${firstOp.objActor}`] = true\n      opSequences.push(firstOp)\n      firstOp = thisOp\n      lastOp = thisOp\n    }\n\n    opIdCtr += 1\n  }\n\n  if (firstOp) opSequences.push(firstOp)\n  return opSequences\n}\n\nclass BackendDoc {\n  constructor(buffer) {\n    const doc = decodeDocumentHeader(buffer)\n    this.changesColumns = doc.changesColumns\n    this.actorIds = doc.actorIds\n    this.heads = doc.heads\n    this.docColumns = makeDecoders(doc.opsColumns, DOC_OPS_COLUMNS)\n    this.numOps = 0 // TODO count actual number of ops in the document\n  }\n\n  /**\n   * Applies a sequence of change operations to the document. `changeCols` contains the columns of\n   * the change. Assumes that the decoders of both sets of columns are at the position where we want\n   * to start merging.\n   */\n  mergeDocChangeOps(outCols, changeCols, ops, actorTable) {\n    // Check the first couple of columns are in the positions where we expect them to be\n    const objActor = 0, objCtr = 1, keyActor = 2, keyCtr = 3, keyStr = 4, idActor = 5, idCtr = 6, insert = 7,\n      action = 8, predNum = 13, predActor = 14, predCtr = 15, succNum = 13, succActor = 14, succCtr = 15\n    if (this.docColumns[objActor ].columnId !== DOC_OPS_COLUMNS.objActor  || changeCols[objActor ].columnId !== CHANGE_COLUMNS.objActor  ||\n        this.docColumns[objCtr   ].columnId !== DOC_OPS_COLUMNS.objCtr    || changeCols[objCtr   ].columnId !== CHANGE_COLUMNS.objCtr    ||\n        this.docColumns[keyActor ].columnId !== DOC_OPS_COLUMNS.keyActor  || changeCols[keyActor ].columnId !== CHANGE_COLUMNS.keyActor  ||\n        this.docColumns[keyCtr   ].columnId !== DOC_OPS_COLUMNS.keyCtr    || changeCols[keyCtr   ].columnId !== CHANGE_COLUMNS.keyCtr    ||\n        this.docColumns[keyStr   ].columnId !== DOC_OPS_COLUMNS.keyStr    || changeCols[keyStr   ].columnId !== CHANGE_COLUMNS.keyStr    ||\n        this.docColumns[idActor  ].columnId !== DOC_OPS_COLUMNS.idActor   || changeCols[idActor  ].columnId !== CHANGE_COLUMNS.idActor   ||\n        this.docColumns[idCtr    ].columnId !== DOC_OPS_COLUMNS.idCtr     || changeCols[idCtr    ].columnId !== CHANGE_COLUMNS.idCtr     ||\n        this.docColumns[insert   ].columnId !== DOC_OPS_COLUMNS.insert    || changeCols[insert   ].columnId !== CHANGE_COLUMNS.insert    ||\n        this.docColumns[action   ].columnId !== DOC_OPS_COLUMNS.action    || changeCols[action   ].columnId !== CHANGE_COLUMNS.action    ||\n        this.docColumns[succNum  ].columnId !== DOC_OPS_COLUMNS.succNum   || changeCols[predNum  ].columnId !== CHANGE_COLUMNS.predNum   ||\n        this.docColumns[succActor].columnId !== DOC_OPS_COLUMNS.succActor || changeCols[predActor].columnId !== CHANGE_COLUMNS.predActor ||\n        this.docColumns[succCtr  ].columnId !== DOC_OPS_COLUMNS.succCtr   || changeCols[predCtr  ].columnId !== CHANGE_COLUMNS.predCtr) {\n      throw new RangeError('unexpected columnId')\n    }\n\n    let opCount = ops.consecutiveOps, opsAppended = 0, opIdCtr = ops.idCtr\n    let docOp = this.docColumns[action].decoder.done ? null : readOperation(this.docColumns)\n    let docOpsConsumed = (docOp === null ? 0 : 1)\n    let changeOp = readOperation(changeCols, actorTable)\n    changeOp[idActor] = ops.idActorIndex\n    changeOp[idCtr] = opIdCtr\n\n    // Merge the two inputs: the sequence of ops in the doc, and the sequence of ops in the change.\n    // At each iteration, we either take one op from the doc, or one op from the change, or one from\n    // both (in which case the document operation is updated with information from the change op).\n    while (opCount > 0) {\n      let takeDocOp = false, takeChangeOp = false, dropChangeOp = false\n      // Insertion operations are copied directly and don't reach this code path\n      if (changeOp[insert]) throw new RangeError('unexpected insert operation')\n\n      // The change operation comes first if there is no document operation, if the next document\n      // operation is for a different object, or if the change op's string key is lexicographically\n      // first (TODO check ordering of keys beyond the basic multilingual plane). The document\n      // operation comes first if its string key is lexicographically first, or if we're using opId\n      // keys and the keys don't match (i.e. we scan the document until we find a matching key).\n      if (!docOp || docOp[objActor] !== changeOp[objActor] || docOp[objCtr] !== changeOp[objCtr] ||\n          (docOp[keyStr] === null && changeOp[keyStr] !== null) ||\n          (docOp[keyStr] !== null && changeOp[keyStr] !== null && changeOp[keyStr] < docOp[keyStr])) {\n        // Take the operation from the change\n        takeChangeOp = true\n        if (changeOp[keyStr] === null && !changeOp[insert]) {\n          // TODO note that the optimistic grouping of operations may mean that we don't find the\n          // element to update, so we have to restart the search from the beginning of the object\n          throw new RangeError(`could not find the list element we're looking for: ${changeOp[keyCtr]}@${this.actorIds[changeOp[keyActor]]}`)\n        }\n\n      } else if ((docOp[keyStr] !== null && changeOp[keyStr] === null) ||\n                 (docOp[keyStr] !== null && changeOp[keyStr] !== null && docOp[keyStr] < changeOp[keyStr]) ||\n                 (docOp[keyStr] === null && changeOp[keyStr] === null && !docOp[insert] &&\n                  (docOp[keyActor] !== changeOp[keyActor] || docOp[keyCtr] !== changeOp[keyCtr]) ||\n                 (docOp[keyStr] === null && changeOp[keyStr] === null && docOp[insert] &&\n                  (docOp[idActor] !== changeOp[keyActor] || docOp[idCtr] !== changeOp[keyCtr])))) {\n        // Take the operation from the document\n        takeDocOp = true\n\n      } else {\n        // The two operations (from the doc and from the change) are for the same key in the same\n        // object, so we merge them. First, if the change operation's `pred` matches the opId of the\n        // document operation, we update the document operation's `succ` accordingly.\n        for (let i = 0; i < changeOp[predNum]; i++) {\n          if (changeOp[predActor][i] === docOp[idActor] && changeOp[predCtr][i] === docOp[idCtr]) {\n            // Insert into the doc op's succ list such that the lists remains sorted\n            let j = 0\n            while (j < docOp[succNum] && (docOp[succCtr][j] < opIdCtr ||\n                   docOp[succCtr][j] === opIdCtr && this.actorIds[docOp[succActor][j]] < ops.idActor)) j++\n            docOp[succCtr].splice(j, 0, opIdCtr)\n            docOp[succActor].splice(j, 0, ops.idActorIndex)\n            docOp[succNum]++\n            changeOp[predCtr].splice(i, 1)\n            changeOp[predActor].splice(i, 1)\n            changeOp[predNum]--\n            break\n          }\n        }\n\n        // When we have several operations for the same object and the same key, we want to keep\n        // them sorted by opId.\n        if (docOp[idCtr] < opIdCtr || (docOp[idCtr] === opIdCtr && this.actorIds[docOp[idActor]] < ops.idActor)) {\n          // The document op has the lower opId, so we output it first.\n          takeDocOp = true\n\n          // A deletion op in the change is represented in the document only by its entries in the\n          // succ list of the operations it overwrites; it has no separate row in the set of ops.\n          if (changeOp[action] === ACTIONS.indexOf('del') && changeOp[predNum] === 0) dropChangeOp = true\n\n        } else if (docOp[idCtr] === opIdCtr && this.actorIds[docOp[idActor]] === ops.idActor) {\n          throw new RangeError(`duplicate operation ID: ${opIdCtr}@${ops.idActor}`)\n        } else {\n          // The change op has the lower opId, so we output it first. Check that we've seen all ops\n          // mentioned in `pred` (they must all have lower opIds, so we must have seen them already)\n          if (changeOp[predNum] > 0) {\n            throw new RangeError(`no matching operation for pred: ${changeOp[predCtr][0]}@${this.actorIds[changeOp[predActor][0]]}`)\n          }\n          takeChangeOp = true\n        }\n      }\n\n      if (takeDocOp) {\n        appendOperation(outCols, this.docColumns, docOp)\n        opsAppended++\n        docOp = this.docColumns[action].decoder.done ? null : readOperation(this.docColumns)\n        if (docOp !== null) docOpsConsumed++\n      }\n      if (takeChangeOp) {\n        appendOperation(outCols, changeCols, changeOp)\n        opsAppended++\n      }\n      if (takeChangeOp || dropChangeOp) {\n        opCount--\n        opIdCtr++\n        if (opCount > 0) {\n          changeOp = readOperation(changeCols, actorTable)\n          changeOp[idActor] = ops.idActorIndex\n          changeOp[idCtr] = opIdCtr\n        }\n      }\n    }\n\n    if (docOp) {\n      appendOperation(outCols, docCols, docOp)\n      opsAppended++\n    }\n    return {opsAppended, docOpsConsumed}\n  }\n\n  applyOps(ops, beforeCount, allCols, changeCols, actorTable) {\n    let newOpsCount = 0, outCols = allCols.map(columnId => {\n      return {columnId, encoder: encoderByColumnId(columnId)}\n    })\n    let remainingOps = this.numOps - beforeCount\n    copyColumns(outCols, this.docColumns, beforeCount)\n    if (ops.directCopy) {\n      copyColumns(outCols, changeCols, ops.consecutiveOps, actorTable, ops)\n      newOpsCount = ops.consecutiveOps\n    } else {\n      const {opsAppended, docOpsConsumed} = this.mergeDocChangeOps(outCols, changeCols, ops, actorTable)\n      remainingOps -= docOpsConsumed\n      newOpsCount = opsAppended - docOpsConsumed\n    }\n    // TODO use metadata on block size to set the number of ops to copy here (needed to correctly\n    // fill in nulls for missing columns). Then perform safety check: after copying, all of the\n    // docColumns decoders should be done.\n    copyColumns(outCols, this.docColumns, remainingOps)\n    for (let col of this.docColumns) {\n      if (!col.decoder.done) throw new RangeError(`excess ops in ${col.columnName} column`)\n    }\n\n    this.docColumns = outCols.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n      return {columnId: col.columnId, columnName: DOC_OPS_COLUMNS_REV[col.columnId], decoder}\n    })\n    this.numOps += newOpsCount\n    console.log('updated columns:', this.docColumns.map(col => { return {columnName: col.columnName, buffer: col.decoder.buf}}))\n  }\n\n  /**\n   * Takes `changeCols`, a list of `{columnId, columnName, decoder}` objects for a change, and\n   * checks that it has the expected structure. Returns an array of column IDs (integers) of the\n   * columns that occur either in the document or in the change.\n   */\n  getAllColumns(changeCols) {\n    const expectedCols = [\n      'objActor', 'objCtr', 'keyActor', 'keyCtr', 'keyStr', 'idActor', 'idCtr', 'insert',\n      'action', 'valLen', 'valRaw', 'chldActor', 'chldCtr', 'predNum', 'predActor', 'predCtr'\n    ]\n    let allCols = {}\n    for (let i = 0; i < expectedCols.length; i++) {\n      if (changeCols[i].columnName !== expectedCols[i]) {\n        throw new RangeError(`Expected column ${expectedCols[i]} at index ${i}, got ${changeCols[i].columnName}`)\n      }\n    }\n    for (let col of changeCols) allCols[col.columnId] = true\n    for (let [columnName, columnId] of Object.entries(DOC_OPS_COLUMNS)) allCols[columnId] = true\n\n    // Final document should contain any columns in either the document or the change, except for\n    // pred, since the document encoding uses succ instead of pred\n    delete allCols[CHANGE_COLUMNS.predNum]\n    delete allCols[CHANGE_COLUMNS.predActor]\n    delete allCols[CHANGE_COLUMNS.predCtr]\n    return Object.keys(allCols).map(id => parseInt(id)).sort((a, b) => a - b)\n  }\n\n  /**\n   * Takes a decoded change header, including an array of actorIds. Returns an array for translating\n   * the change's actor indexes into the document's actor indexes.\n   */\n  getActorTable(change) {\n    // TODO check if change is causally ready, enqueue it if not (cf. OpSet.applyQueuedOps)\n    if (this.actorIds.indexOf(change.actorIds[0]) < 0) {\n      if (change.seq !== 1) {\n        throw new RangeError(`Seq ${change.seq} is the first change for actor ${change.actorIds[0]}`)\n      }\n      this.actorIds.push(change.actorIds[0])\n    }\n    const actorTable = [] // translate from change's actor index to doc's actor index\n    for (let actorId of change.actorIds) {\n      const index = this.actorIds.indexOf(actorId)\n      if (index < 0) {\n        throw new RangeError(`actorId ${actorId} is not known to document`)\n      }\n      actorTable.push(index)\n    }\n    return actorTable\n  }\n\n  /**\n   * Parses the change given as a Uint8Array in `changeBuffer`, and applies it to the current\n   * document. TODO this should return a patch.\n   */\n  applyChange(changeBuffer) {\n    const change = decodeChangeColumns(changeBuffer) // { actor, seq, startOp, time, message, deps, actorIds, hash, columns }\n    const changeCols = makeDecoders(change.columns, CHANGE_COLUMNS)\n    const allCols = this.getAllColumns(changeCols)\n    const actorTable = this.getActorTable(change)\n    const opSequences = groupRelatedOps(change, changeCols)\n    const actorIndex = this.actorIds.indexOf(change.actorIds[0])\n\n    for (let col of changeCols) col.decoder.reset()\n    for (let op of opSequences) {\n      op.idActorIndex = actorIndex\n      for (let col of this.docColumns) col.decoder.reset()\n      const skipCount = seekToOp(op, this.docColumns, this.actorIds)\n      for (let col of this.docColumns) col.decoder.reset()\n      this.applyOps(op, skipCount, allCols, changeCols, actorTable)\n    }\n  }\n}\n\nmodule.exports = {\n  COLUMN_TYPE, VALUE_TYPE, ACTIONS, DOC_OPS_COLUMNS, CHANGE_COLUMNS, DOCUMENT_COLUMNS,\n  splitContainers, encodeChange, decodeChange, decodeChangeMeta, decodeChanges, encodeDocument, decodeDocument,\n  constructPatch, BackendDoc\n}\n","/**\n * UTF-8 decoding and encoding\n */\nlet stringToUtf8, utf8ToString\n\nif (typeof TextEncoder === 'function' && typeof TextDecoder === 'function') {\n  // Modern web browsers:\n  // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode\n  // https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode\n  const utf8encoder = new TextEncoder(), utf8decoder = new TextDecoder('utf-8')\n  stringToUtf8 = (string) => utf8encoder.encode(string)\n  utf8ToString = (buffer) => utf8decoder.decode(buffer)\n\n} else if (typeof Buffer === 'function') {\n  // Node.js:\n  // https://nodejs.org/api/buffer.html\n  // https://nodejs.org/api/string_decoder.html\n  const { StringDecoder } = require('string_decoder')\n  const utf8decoder = new StringDecoder('utf8')\n  stringToUtf8 = (string) => Buffer.from(string, 'utf8')\n  // In Node >= 10 we can simply do \"utf8decoder.end(buffer)\". However, in Node 8 there\n  // is a bug that causes an Uint8Array to be incorrectly decoded when passed directly to\n  // StringDecoder.end(). Wrapping in an additional \"Buffer.from()\" works around this bug.\n  utf8ToString = (buffer) => utf8decoder.end(Buffer.from(buffer))\n\n} else {\n  // Could use a polyfill? e.g. https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n  throw new Error('Platform does not provide UTF-8 encoding/decoding feature')\n}\n\n\n/**\n * Converts a string consisting of hexadecimal digits into an Uint8Array.\n */\nfunction hexStringToBytes(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('value is not a string')\n  }\n  if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {\n    throw new RangeError('value is not hexadecimal')\n  }\n  if (value === '') {\n    return new Uint8Array(0)\n  } else {\n    return new Uint8Array(value.match(/../g).map(b => parseInt(b, 16)))\n  }\n}\n\n/**\n * Converts a Uint8Array into the equivalent hexadecimal string.\n */\nfunction bytesToHexString(bytes) {\n  const hex = []\n  for (let b of bytes) {\n    if (b < 0 || b > 255) throw new RangeError(`value does not fit in one byte: ${b}`)\n    hex.push(('0' + b.toString(16)).slice(-2))\n  }\n  return hex.join('')\n}\n\n/**\n * Wrapper around an Uint8Array that allows values to be appended to the buffer,\n * and that automatically grows the buffer when space runs out.\n */\nclass Encoder {\n  constructor() {\n    this.buf = new Uint8Array(16)\n    this.offset = 0\n  }\n\n  /**\n   * Returns the byte array containing the encoded data.\n   */\n  get buffer() {\n    this.finish()\n    return this.buf.subarray(0, this.offset)\n  }\n\n  /**\n   * Reallocates the encoder's buffer to be bigger.\n   */\n  grow(minSize = 0) {\n    let newSize = this.buf.byteLength * 4\n    while (newSize < minSize) newSize *= 2\n    const newBuf = new Uint8Array(newSize)\n    newBuf.set(this.buf, 0)\n    this.buf = newBuf\n    return this\n  }\n\n  /**\n   * Appends one byte (0 to 255) to the buffer.\n   */\n  appendByte(value) {\n    if (this.offset >= this.buf.byteLength) this.grow()\n    this.buf[this.offset] = value\n    this.offset += 1\n  }\n\n  /**\n   * Encodes a 32-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and\n   * appends it to the buffer. Returns the number of bytes written.\n   */\n  appendUint32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > 0xffffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7))\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>>= 7 // zero-filling right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 32-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends\n   * it to the buffer. Returns the number of bytes written.\n   */\n  appendInt32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < -0x80000000 || value > 0x7fffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>= 7 // sign-propagating right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a nonnegative integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendUint53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendUint64(high32, low32)\n  }\n\n  /**\n   * Encodes a signed integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendInt53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendInt64(high32, low32)\n  }\n\n  /**\n   * Encodes a 64-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme, and appends it to the buffer. The number is\n   * given as two 32-bit halves since JavaScript cannot accurately represent\n   * integers with more than 53 bits in a single variable.\n   */\n  appendUint64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < 0 || high32 > 0xffffffff || low32 < 0 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    if (high32 === 0) return this.appendUint32(low32)\n\n    const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>>= 3\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 64-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme, and appends it to the buffer. The number is given\n   * as two 32-bit halves since JavaScript cannot accurately represent integers\n   * with more than 53 bits in a single variable. The sign of the 64-bit\n   * number is determined by the sign of the `high32` half; the sign of the\n   * `low32` half is ignored.\n   */\n  appendInt64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < -0x80000000 || high32 > 0x7fffffff || low32 < -0x80000000 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    low32 >>>= 0 // interpret as unsigned\n    if (high32 === 0 && low32 <= 0x7fffffff) return this.appendInt32(low32)\n    if (high32 === -1 && low32 >= 0x80000000) return this.appendInt32(low32 - 0x100000000)\n\n    const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>= 3 // sign-propagating right shift\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer. Returns the\n   * number of bytes appended.\n   */\n  appendRawBytes(data) {\n    if (this.offset + data.byteLength > this.buf.byteLength) {\n      this.grow(this.offset + data.byteLength)\n    }\n    this.buf.set(data, this.offset)\n    this.offset += data.byteLength\n    return data.byteLength\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, without any metadata. Returns the\n   * number of bytes appended.\n   */\n  appendRawString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    return this.appendRawBytes(stringToUtf8(value))\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer, prefixed with the\n   * number of bytes in the buffer (as a LEB128-encoded unsigned integer).\n   */\n  appendPrefixedBytes(data) {\n    this.appendUint53(data.byteLength)\n    this.appendRawBytes(data)\n    return this\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, prefixed with its length in bytes\n   * (where the length is encoded as an unsigned LEB128 integer).\n   */\n  appendPrefixedString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    this.appendPrefixedBytes(stringToUtf8(value))\n    return this\n  }\n\n  /**\n   * Takes a value, which must be a string consisting only of hexadecimal\n   * digits, maps it to a byte array, and appends it to the buffer, prefixed\n   * with its length in bytes.\n   */\n  appendHexString(value) {\n    this.appendPrefixedBytes(hexStringToBytes(value))\n    return this\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n  }\n}\n\n/**\n * Counterpart to Encoder. Wraps a Uint8Array buffer with a cursor indicating\n * the current decoding position, and allows values to be incrementally read by\n * decoding the bytes at the current position.\n */\nclass Decoder {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw new TypeError(`Not a byte array: ${buffer}`)\n    }\n    this.buf = buffer\n    this.offset = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return this.offset === this.buf.byteLength\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n  }\n\n  /**\n   * Moves the current decoding position forward by the specified number of\n   * bytes, without decoding anything.\n   */\n  skip(bytes) {\n    if (this.offset + bytes > this.buf.byteLength) {\n      throw new RangeError('cannot skip beyond end of buffer')\n    }\n    this.offset += bytes\n  }\n\n  /**\n   * Reads one byte (0 to 255) from the buffer.\n   */\n  readByte() {\n    this.offset += 1\n    return this.buf[this.offset - 1]\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit unsigned int.\n   */\n  readUint32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 28 && (nextByte & 0xf0) !== 0) { // more than 5 bytes, or value > 0xffffffff\n        throw new RangeError('number out of range')\n      }\n      result = (result | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return result\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit signed int.\n   */\n  readInt32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if ((shift === 28 && (nextByte & 0x80) !== 0) || // more than 5 bytes\n          (shift === 28 && (nextByte & 0x40) === 0 && (nextByte & 0x38) !== 0) || // positive int > 0x7fffffff\n          (shift === 28 && (nextByte & 0x40) !== 0 && (nextByte & 0x38) !== 0x38)) { // negative int < -0x80000000\n        throw new RangeError('number out of range')\n      }\n      result |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) === 0 || shift > 28) {\n          return result // positive, or negative value that doesn't need sign-extending\n        } else {\n          return result | (-1 << shift) // sign-extend negative integer\n        }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (up to 2^53 - 1), and throws an exception outside of that range.\n   */\n  readUint53() {\n    const { low32, high32 } = this.readUint64()\n    if (high32 < 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.\n   */\n  readInt53() {\n    const { low32, high32 } = this.readInt64()\n    if (high32 < -0x200000 || (high32 === -0x200000 && low32 === 0) || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`.\n   */\n  readUint64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 31 && (nextByte & 0xfe) !== 0) { // more than 10 bytes, or value > 2^64 - 1\n        throw new RangeError('number out of range')\n      }\n      high32 = (high32 | (nextByte & 0x7f) << shift) >>> 0\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit signed\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`. The `low32` half is always non-negative, and the\n   * sign of the `high32` half indicates the sign of the 64-bit number.\n   */\n  readInt64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0) { // sign-extend negative integer\n          if (shift < 32) low32 = (low32 | (-1 << shift)) >>> 0\n          high32 |= -1 << Math.max(shift - 32, 0)\n        }\n        return { high32, low32 }\n      }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      // On the 10th byte there are only two valid values: all 7 value bits zero\n      // (if the value is positive) or all 7 bits one (if the value is negative)\n      if (shift === 31 && nextByte !== 0 && nextByte !== 0x7f) {\n        throw new RangeError('number out of range')\n      }\n      high32 |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0 && shift < 32) { // sign-extend negative integer\n          high32 |= -1 << shift\n        }\n        return { high32, low32 }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Extracts a subarray `length` bytes in size, starting from the current\n   * position in the buffer, and moves the position forward.\n   */\n  readRawBytes(length) {\n    const start = this.offset\n    if (start + length > this.buf.byteLength) {\n      throw new RangeError('subarray exceeds buffer size')\n    }\n    this.offset += length\n    return this.buf.subarray(start, this.offset)\n  }\n\n  /**\n   * Extracts `length` bytes from the buffer, starting from the current position,\n   * and returns the UTF-8 string decoding of those bytes.\n   */\n  readRawString(length) {\n    return utf8ToString(this.readRawBytes(length))\n  }\n\n  /**\n   * Extracts a subarray from the current position in the buffer, prefixed with\n   * its length in bytes (encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedBytes() {\n    return this.readRawBytes(this.readUint53())\n  }\n\n  /**\n   * Reads a UTF-8 string from the current position in the buffer, prefixed with its\n   * length in bytes (where the length is encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedString() {\n    return utf8ToString(this.readPrefixedBytes())\n  }\n\n  /**\n   * Reads a byte array from the current position in the buffer, prefixed with its\n   * length in bytes. Returns that byte array converted to a hexadecimal string.\n   */\n  readHexString() {\n    return bytesToHexString(this.readPrefixedBytes())\n  }\n}\n\n/**\n * An encoder that uses run-length encoding to compress sequences of repeated\n * values. The constructor argument specifies the type of values, which may be\n * either 'int', 'uint', or 'utf8'. Besides valid values of the selected\n * datatype, values may also be null.\n *\n * The encoded buffer starts with a LEB128-encoded signed integer, the\n * repetition count. The interpretation of the following values depends on this\n * repetition count:\n *   - If this number is a positive value n, the next value in the buffer\n *     (encoded as the specified datatype) is repeated n times in the sequence.\n *   - If the repetition count is a negative value -n, then the next n values\n *     (encoded as the specified datatype) in the buffer are treated as a\n *     literal, i.e. they appear in the sequence without any further\n *     interpretation or repetition.\n *   - If the repetition count is zero, then the next value in the buffer is a\n *     LEB128-encoded unsigned integer indicating the number of null values\n *     that appear at the current position in the sequence.\n *\n * After one of these three has completed, the process repeats, starting again\n * with a repetition count, until we reach the end of the buffer.\n */\nclass RLEEncoder extends Encoder {\n  constructor(type) {\n    super()\n    this.type = type\n    this.state = 'empty'\n    this.lastValue = undefined\n    this.count = 0\n    this.literal = []\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    this._appendValue(value, repetitions)\n  }\n\n  /**\n   * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.\n   */\n  _appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (this.state === 'empty') {\n      this.state = (value === null ? 'nulls' : (repetitions === 1 ? 'loneValue' : 'repetition'))\n      this.lastValue = value\n      this.count = repetitions\n    } else if (this.state === 'loneValue') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.state = 'literal'\n        this.literal = [this.lastValue]\n        this.lastValue = value\n      }\n    } else if (this.state === 'repetition') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    } else if (this.state === 'literal') {\n      if (value === null) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.literal.push(this.lastValue)\n        this.lastValue = value\n      }\n    } else if (this.state === 'nulls') {\n      if (value === null) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    }\n  }\n\n  /**\n   * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may\n   * contain the following keys:\n   *  - `count`: The number of values to copy. If not specified, copies all remaining values.\n   *  - `lookupTable`: If specified, every value `v` is translated into value `lookupTable[v]`.\n   *  - `sumValues`: If true, the function computes the sum of all numeric values as they are\n   *    copied (null values are counted as zero), and returns that number.\n   *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.\n   */\n  copyFrom(decoder, options = {}) {\n    const { count, lookupTable, sumValues, sumShift } = options\n    if (!(decoder instanceof RLEDecoder) || (decoder.type !== this.type)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER), sum = 0\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sum\n\n    // Copy a value so that we have a well-defined starting state\n    const firstValue = decoder.readValue()\n    this.appendValue((lookupTable && firstValue !== null) ? lookupTable[firstValue] : firstValue)\n    remaining--\n    if (sumValues) sum += firstValue >>> (sumShift || 0)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sum\n\n    // Copy data at the record level without expanding repetitions\n    let startOffset, endOffset, skipValues = !lookupTable && !sumValues, firstRun = true\n    while (remaining > 0 && !decoder.done) {\n      endOffset = decoder.offset\n      if (firstRun && decoder.count === 0) {\n        firstRun = false\n        startOffset = decoder.offset\n      }\n      if (!firstRun) decoder.readRecord()\n\n      const numValues = Math.min(decoder.count, remaining)\n      decoder.count -= numValues\n\n      if (decoder.state === 'literal') {\n        if (skipValues && !firstRun) {\n          decoder.skipRawValues(numValues)\n        } else {\n          for (let i = 0; i < numValues; i++) {\n            if (decoder.done) throw new RangeError('incomplete literal')\n            const value = decoder.readRawValue()\n            if (value === decoder.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n            decoder.lastValue = value\n            this._appendValue((lookupTable && value !== null) ? lookupTable[value] : value)\n            if (sumValues) sum += value >>> (sumShift || 0)\n          }\n        }\n      } else if (decoder.state === 'repetition') {\n        if (sumValues) sum += (numValues * decoder.lastValue) >>> (sumShift || 0)\n        if (!skipValues || firstRun) {\n          const mappedValue = (lookupTable && decoder.lastValue !== null) ? lookupTable[decoder.lastValue] : decoder.lastValue\n          this._appendValue(mappedValue)\n          if (numValues > 1) {\n            this._appendValue(mappedValue)\n            if (this.state !== 'repetition') throw new RangeError(`Unexpected state ${this.state}`)\n            this.count += numValues - 2\n          }\n        }\n      } else if (decoder.state === 'nulls') {\n        if (!skipValues || firstRun) {\n          this._appendValue(null)\n          if (this.state !== 'nulls') throw new RangeError(`Unexpected state ${this.state}`)\n          this.count += numValues - 1\n        }\n      }\n\n      if (firstRun) {\n        firstRun = false\n        startOffset = decoder.offset\n        remaining -= numValues\n      } else if ((decoder.done || remaining === numValues) && skipValues) {\n        // If that was the last record, and we skipped over its values, we have to go back and re-read\n        // it. However, we can directly copy the previous records at the byte level.\n        skipValues = false\n        decoder.offset = endOffset\n        decoder.state = undefined\n        if (this.state === 'literal') this.literal.push(this.lastValue)\n        this.flush()\n        if (startOffset < endOffset) {\n          this.appendRawBytes(decoder.buf.subarray(startOffset, endOffset))\n        }\n      } else {\n        remaining -= numValues\n      }\n    }\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (sumValues) return sum\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  flush() {\n    if (this.state === 'loneValue') {\n      this.appendInt32(-1)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'repetition') {\n      this.appendInt53(this.count)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'literal') {\n      this.appendInt53(-this.literal.length)\n      for (let v of this.literal) this.appendRawValue(v)\n    } else if (this.state === 'nulls') {\n      this.appendInt32(0)\n      this.appendUint53(this.count)\n    }\n    this.state = 'empty'\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  appendRawValue(value) {\n    if (this.type === 'int') {\n      this.appendInt53(value)\n    } else if (this.type === 'uint') {\n      this.appendUint53(value)\n    } else if (this.type === 'utf8') {\n      this.appendPrefixedString(value)\n    } else {\n      throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.state === 'literal') this.literal.push(this.lastValue)\n    // Don't write anything if the only values we have seen are nulls\n    if (this.state !== 'nulls' || this.offset > 0) this.flush()\n  }\n}\n\n/**\n * Counterpart to RLEEncoder: reads values from an RLE-compressed sequence,\n * returning nulls and repeated values as required.\n */\nclass RLEDecoder extends Decoder {\n  constructor(type, buffer) {\n    super(buffer)\n    this.type = type\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns the next value (or null) in the sequence.\n   */\n  readValue() {\n    if (this.done) return null\n    if (this.count === 0) this.readRecord()\n    this.count -= 1\n    if (this.state === 'literal') {\n      const value = this.readRawValue()\n      if (value === this.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n      this.lastValue = value\n      return value\n    } else {\n      return this.lastValue\n    }\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readInt53()\n        if (this.count > 0) {\n          this.lastValue = (this.count <= numSkip) ? this.skipRawValues(1) : this.readRawValue()\n          this.state = 'repetition'\n        } else if (this.count < 0) {\n          this.count = -this.count\n          this.state = 'literal'\n        } else { // this.count == 0\n          this.count = this.readUint53()\n          this.lastValue = null\n          this.state = 'nulls'\n        }\n      }\n\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') this.skipRawValues(consume)\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads a repetition count from the buffer and sets up the state appropriately.\n   */\n  readRecord() {\n    this.count = this.readInt53()\n    if (this.count > 1) {\n      const value = this.readRawValue()\n      if ((this.state === 'repetition' || this.state === 'literal') && this.lastValue === value) {\n        throw new RangeError('Successive repetitions with the same value are not allowed')\n      }\n      this.state = 'repetition'\n      this.lastValue = value\n    } else if (this.count === 1) {\n      throw new RangeError('Repetition count of 1 is not allowed, use a literal instead')\n    } else if (this.count < 0) {\n      this.count = -this.count\n      if (this.state === 'literal') throw new RangeError('Successive literals are not allowed')\n      this.state = 'literal'\n    } else { // this.count == 0\n      if (this.state === 'nulls') throw new RangeError('Successive null runs are not allowed')\n      this.count = this.readUint53()\n      if (this.count === 0) throw new RangeError('Zero-length null runs are not allowed')\n      this.lastValue = null\n      this.state = 'nulls'\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads one value of the datatype configured on construction.\n   */\n  readRawValue() {\n    if (this.type === 'int') {\n      return this.readInt53()\n    } else if (this.type === 'uint') {\n      return this.readUint53()\n    } else if (this.type === 'utf8') {\n      return this.readPrefixedString()\n    } else {\n      throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Skips over `num` values of the datatype configured on construction.\n   */\n  skipRawValues(num) {\n    if (this.type === 'utf8') {\n      for (let i = 0; i < num; i++) this.skip(this.readUint53())\n    } else {\n      while (num > 0 && this.offset < this.buf.byteLength) {\n        if ((this.buf[this.offset] & 0x80) === 0) num--\n        this.offset++\n      }\n      if (num > 0) throw new RangeError('cannot skip beyond end of buffer')\n    }\n  }\n}\n\n/**\n * A variant of RLEEncoder: rather than storing the actual values passed to\n * appendValue(), this version stores only the first value, and for all\n * subsequent values it stores the difference to the previous value. This\n * encoding is good when values tend to come in sequentially incrementing runs,\n * because the delta between successive values is 1, and repeated values of 1\n * are easily compressed with run-length encoding.\n *\n * Null values are also allowed, as with RLEEncoder.\n */\nclass DeltaEncoder extends RLEEncoder {\n  constructor() {\n    super('int')\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (typeof value === 'number') {\n      super.appendValue(value - this.absoluteValue, 1)\n      this.absoluteValue = value\n      if (repetitions > 1) super.appendValue(0, repetitions - 1)\n    } else {\n      super.appendValue(value, repetitions)\n    }\n  }\n\n  /**\n   * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (options.lookupTable || options.sumValues) {\n      throw new RangeError('unsupported options for DeltaEncoder.copyFrom()')\n    }\n    if (!(decoder instanceof DeltaDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    if (options.count > 0 && decoder.done) throw new RangeError(`cannot copy ${options.count} values`)\n    if (options.count === 0 || decoder.done) return\n\n    // Copy any null values, and the first non-null value, so that appendValue() computes the\n    // difference between the encoder's last value and the decoder's first (absolute) value.\n    let value = decoder.readValue(), nulls = 0\n    this.appendValue(value)\n    if (value === null) {\n      nulls = decoder.count + 1\n      if (options.count && options.count < nulls) nulls = options.count\n      decoder.count -= nulls - 1\n      this.count += nulls - 1\n      if (options.count > nulls && decoder.done) throw new RangeError(`cannot copy ${options.count} values`)\n      if (options.count === nulls || decoder.done) return\n\n      // The next value read is certain to be non-null because we're not at the end of the decoder,\n      // and a run of nulls must be followed by a run of non-nulls.\n      if (decoder.count === 0) this.appendValue(decoder.readValue())\n    }\n\n    // Once we have the first value, the subsequent relative values can be\n    // copied verbatim without any further processing.\n    if (options.count) options.count -= nulls + 1\n    super.copyFrom(decoder, options)\n  }\n}\n\n/**\n * Counterpart to DeltaEncoder: reads values from a delta-compressed sequence of\n * numbers (may include null values).\n */\nclass DeltaDecoder extends RLEDecoder {\n  constructor(buffer) {\n    super('int', buffer)\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Returns the next integer (or null) value in the sequence.\n   */\n  readValue() {\n    const value = super.readValue()\n    if (value === null) return null\n    this.absoluteValue += value\n    return this.absoluteValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) this.readRecord()\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') {\n        for (let i = 0; i < consume; i++) {\n          this.lastValue = this.readRawValue()\n          this.absoluteValue += this.lastValue\n        }\n      } else if (this.state === 'repetition') {\n        this.absoluteValue += consume * this.lastValue\n      }\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n}\n\n/**\n * Encodes a sequence of boolean values by mapping it to a sequence of integers:\n * the number of false values, followed by the number of true values, followed\n * by the number of false values, and so on. Each number is encoded as a LEB128\n * unsigned integer. This encoding is a bit like RLEEncoder, except that we\n * only encode the repetition count but not the actual value, since the values\n * just alternate between false and true (starting with false).\n */\nclass BooleanEncoder extends Encoder {\n  constructor() {\n    super()\n    this.lastValue = false\n    this.count = 0\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (value !== false && value !== true) {\n      throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`)\n    }\n    if (repetitions <= 0) return\n    if (this.lastValue === value) {\n      this.count += repetitions\n    } else {\n      this.appendUint53(this.count)\n      this.lastValue = value\n      this.count = repetitions\n    }\n  }\n\n  /**\n   * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (!(decoder instanceof BooleanDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    const { count } = options\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return\n\n    // Copy one value to bring decoder and encoder state into sync, then finish that value's repetitions\n    this.appendValue(decoder.readValue())\n    remaining--\n    const firstCopy = Math.min(decoder.count, remaining)\n    this.count += firstCopy\n    decoder.count -= firstCopy\n    remaining -= firstCopy\n\n    while (remaining > 0 && !decoder.done) {\n      decoder.count = decoder.readUint53()\n      if (decoder.count === 0) throw new RangeError('Zero-length runs are not allowed')\n      decoder.lastValue = !decoder.lastValue\n      this.appendUint53(this.count)\n\n      const numCopied = Math.min(decoder.count, remaining)\n      this.count = numCopied\n      this.lastValue = decoder.lastValue\n      decoder.count -= numCopied\n      remaining -= numCopied\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.count > 0) {\n      this.appendUint53(this.count)\n      this.count = 0\n    }\n  }\n}\n\n/**\n * Counterpart to BooleanEncoder: reads boolean values from a runlength-encoded\n * sequence.\n */\nclass BooleanDecoder extends Decoder {\n  constructor(buffer) {\n    super(buffer)\n    this.lastValue = true // is negated the first time we read a count\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = true\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns the next value in the sequence.\n   */\n  readValue() {\n    if (this.done) return false\n    while (this.count === 0) {\n      this.count = this.readUint53()\n      this.lastValue = !this.lastValue\n      if (this.count === 0 && !this.firstRun) {\n        throw new RangeError('Zero-length runs are not allowed')\n      }\n      this.firstRun = false\n    }\n    this.count -= 1\n    return this.lastValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readUint53()\n        this.lastValue = !this.lastValue\n        if (this.count === 0) throw new RangeError('Zero-length runs are not allowed')\n      }\n      if (this.count < numSkip) {\n        numSkip -= this.count\n        this.count = 0\n      } else {\n        this.count -= numSkip\n        numSkip = 0\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n}\n","const { Map, List } = require('immutable')\nconst { copyObject } = require('../src/common')\nconst OpSet = require('./op_set')\nconst { SkipList } = require('./skip_list')\nconst { splitContainers, encodeChange, decodeChanges, encodeDocument, constructPatch } = require('./columnar')\n\nfunction backendState(backend) {\n  if (backend.frozen) {\n    throw new Error(\n      'Attempting to use an outdated Automerge document that has already been updated. ' +\n      'Please use the latest document state, or call Automerge.clone() if you really ' +\n      'need to use this old document state.'\n    )\n  }\n  return backend.state\n}\n\n/**\n * Mutates the operations in `change` to include the opIds of prior value\n * operations on the appropriate properties in `opSet`.\n */\nfunction fillInPred(opSet, change) {\n  let myOps = {} // maps objectId => key => opId\n  change.ops.forEach((op, index) => {\n    const opId = `${change.startOp + index}@${change.actor}`\n    const key = op.insert ? opId : op.key\n\n    if (myOps[op.obj] && myOps[op.obj][key]) {\n      op.pred = [myOps[op.obj][key]]\n    } else {\n      const fieldOps = OpSet.getFieldOps(opSet, op.obj, key)\n      op.pred = fieldOps.map(fieldOp => fieldOp.get('opId')).toJS()\n    }\n\n    if (!myOps[op.obj]) myOps[op.obj] = {}\n    if (!myOps[op.obj][key]) myOps[op.obj][key] = opId\n  })\n}\n\n/**\n * Processes a change request `request` that is incoming from the frontend. Translates index-based\n * addressing of lists into identifier-based addressing used by the CRDT, translates temporary\n * objectIds into operationId-based identifiers, and removes duplicate assignments to the same\n * object and key. `opSet` corresponds to the version of the document on top of which the frontend\n * made its change (which may lag behind the backend, because there might be remote changes that\n * the backend has already applied, but that the frontend has not yet seen).\n */\nfunction processChangeRequest(state, opSet, request, startOp) {\n  const { actor, seq, deps, time, message } = request\n  const change = { actor, seq, startOp, deps, time, message, ops: [] }\n\n  let objectIds = state.get('objectIds'), objectTypes = {}, elemIds = {}, assignments = {}\n  for (let op of request.ops) {\n    const opId = `${startOp + change.ops.length}@${actor}`\n    op = copyObject(op)\n\n    if (objectIds.has(op.obj)) {\n      op.obj = objectIds.get(op.obj)\n    }\n    if (op.action === 'link' && objectIds.has(op.child)) {\n      op.child = objectIds.get(op.child)\n    }\n\n    const objType = objectTypes[op.obj] || opSet.getIn(['byObject', op.obj, '_init', 'action'])\n\n    // The objectId generated by the frontend is temporary, and we map it into an operation ID.\n    if (op.action.startsWith('make')) {\n      objectIds = objectIds.set(op.child, opId)\n      delete op.child\n      objectTypes[opId] = op.action\n    }\n\n    if (objType === 'makeList' || objType === 'makeText') {\n      if (!elemIds[op.obj]) {\n        elemIds[op.obj] = opSet.getIn(['byObject', op.obj, '_elemIds']) || new SkipList()\n      }\n      if (typeof op.key !== 'number') {\n        throw new TypeError(`Unexpected operation key: ${op.key}`)\n      }\n\n      if (op.insert) {\n        if (op.key === 0) {\n          op.key = '_head'\n          elemIds[op.obj] = elemIds[op.obj].insertAfter(null, opId)\n        } else {\n          op.key = elemIds[op.obj].keyOf(op.key - 1)\n          elemIds[op.obj] = elemIds[op.obj].insertAfter(op.key, opId)\n        }\n      } else {\n        op.key = elemIds[op.obj].keyOf(op.key)\n        if (op.action === 'del') {\n          elemIds[op.obj] = elemIds[op.obj].removeKey(op.key)\n        }\n      }\n    }\n\n    // Detect duplicate assignments to the same object and key\n    if (['set', 'del', 'link', 'inc'].includes(op.action) && !op.insert) {\n      if (!assignments[op.obj]) {\n        assignments[op.obj] = {[op.key]: op}\n      } else if (!assignments[op.obj][op.key]) {\n        assignments[op.obj][op.key] = op\n      } else if (op.action === 'inc') {\n        assignments[op.obj][op.key].value += op.value\n        continue\n      } else {\n        assignments[op.obj][op.key].action = op.action\n        assignments[op.obj][op.key].value = op.value\n        continue\n      }\n    }\n\n    change.ops.push(op)\n  }\n\n  return [state.set('objectIds', objectIds), change]\n}\n\n/**\n * Returns an empty node state.\n */\nfunction init() {\n  const opSet = OpSet.init(), versionObj = Map({version: 0, localOnly: true, opSet})\n  const state = Map({opSet, versions: List.of(versionObj), objectIds: Map()})\n  return {state}\n}\n\nfunction clone(backend) {\n  return {state: backendState(backend)}\n}\n\nfunction free(backend) {\n  backend.state = null\n  backend.frozen = true\n}\n\n/**\n * Constructs a patch object from the current node state `state` and the\n * object modifications `diffs`.\n */\nfunction makePatch(state, diffs, request, isIncremental) {\n  const version = state.get('versions').last().get('version')\n  const clock   = state.getIn(['opSet', 'states']).map(seqs => seqs.size).toJSON()\n  const deps    = state.getIn(['opSet', 'deps']).toJSON().sort()\n  const canUndo = state.getIn(['opSet', 'undoPos']) > 0\n  const canRedo = !state.getIn(['opSet', 'redoStack']).isEmpty()\n  const patch = {version, clock, deps, canUndo, canRedo, diffs}\n\n  if (isIncremental && request) {\n    patch.actor = request.actor\n    patch.seq   = request.seq\n  }\n  return patch\n}\n\n/**\n * The implementation behind `applyChanges()`, `applyLocalChange()`, and\n * `loadChanges()`.\n */\nfunction apply(state, changes, request, isUndoable, isIncremental) {\n  let diffs = isIncremental ? {} : null\n  let opSet = state.get('opSet')\n  for (let change of changes) {\n    for (let chunk of splitContainers(change)) {\n      if (request) {\n        opSet = OpSet.addLocalChange(opSet, change, isUndoable, diffs)\n      } else {\n        opSet = OpSet.addChange(opSet, change, diffs)\n      }\n    }\n  }\n\n  OpSet.finalizePatch(opSet, diffs)\n  state = state.set('opSet', opSet)\n\n  if (isIncremental) {\n    const version = state.get('versions').last().get('version') + 1\n    const versionObj = Map({version, localOnly: true, opSet})\n    state = state.update('versions', versions => versions.push(versionObj))\n  } else {\n    const versionObj = Map({version: 0, localOnly: true, opSet})\n    state = state.set('versions', List.of(versionObj))\n  }\n\n  return [state, isIncremental ? makePatch(state, diffs, request, true) : null]\n}\n\n/**\n * Applies a list of `changes` from remote nodes to the node state `backend`.\n * Returns a two-element array `[state, patch]` where `state` is the updated\n * node state, and `patch` describes the modifications that need to be made\n * to the document objects to reflect these changes.\n */\nfunction applyChanges(backend, changes) {\n  let state = backendState(backend), patch\n\n  // The localOnly flag on a version object is set to true if all changes since that version have\n  // been local changes. Since we are applying a remote change here, we have to set that flag to\n  // false on all existing version objects.\n  state = state.update('versions', versions => versions.map(v => v.set('localOnly', false)))\n  ;[state, patch] = apply(state, changes, null, false, true)\n  backend.frozen = true\n  return [{state}, patch]\n}\n\n/**\n * Takes a single change request `request` made by the local user, and applies\n * it to the node state `backend`. The difference to `applyChanges()` is that this\n * function adds the change to the undo history, so it can be undone (whereas\n * remote changes are not normally added to the undo history). Returns a\n * two-element array `[backend, patch]` where `backend` is the updated node state,\n * and `patch` confirms the modifications to the document objects.\n */\nfunction applyLocalChange(backend, request) {\n  let state = backendState(backend)\n  if (typeof request.actor !== 'string' || typeof request.seq !== 'number') {\n    throw new TypeError('Change request requries `actor` and `seq` properties')\n  }\n  if (typeof request.time !== 'number') {\n    throw new TypeError('Change request requires `time` property')\n  }\n  // Throw error if we have already applied this change request\n  if (request.seq <= state.getIn(['opSet', 'states', request.actor], List()).size) {\n    throw new RangeError('Change request has already been applied')\n  }\n\n  const versionObj = state.get('versions').find(v => v.get('version') === request.version)\n  if (!versionObj) {\n    throw new RangeError(`Unknown base document version ${request.version}`)\n  }\n  request.deps = versionObj.getIn(['opSet', 'deps']).toJSON()\n\n  let change, startOp = versionObj.getIn(['opSet', 'maxOp'], 0) + 1\n  if (request.requestType === 'change') {\n    ;[state, change] = processChangeRequest(state, versionObj.get('opSet'), request, startOp)\n  } else if (request.requestType === 'undo') {\n    ;[state, change] = undo(state, request, startOp)\n  } else if (request.requestType === 'redo') {\n    ;[state, change] = redo(state, request, startOp)\n  } else {\n    throw new RangeError(`Unknown requestType: ${request.requestType}`)\n  }\n\n  fillInPred(versionObj.get('opSet'), change)\n  const binaryChange = encodeChange(change)\n  let patch, isUndoable = (request.requestType === 'change' && request.undoable !== false)\n  ;[state, patch] = apply(state, [binaryChange], request, isUndoable, true)\n\n  state = state.update('versions', versions => {\n    // Remove any versions before the one referenced by the current request, since future requests\n    // will always reference a version number that is greater than or equal to the current\n    return versions.filter(v => v.get('version') >= request.version)\n      // Update the list of past versions so that if a future change request from the frontend\n      // refers to one of these versions, we know exactly what state the frontend was in when it\n      // made the change. If there have only been local updates since a given version, then the\n      // frontend is in sync with the backend (since the frontend has applied the same change\n      // locally). However, if there have also been remote updates, then we construct a special\n      // opSet that contains only the local changes but excludes the remote ones. This opSet should\n      // match the state of the frontend (which has not yet seen the remote update).\n      .map(v => {\n        if (v.get('localOnly')) {\n          return v.set('opSet', state.get('opSet'))\n        } else {\n          return v.set('opSet', OpSet.addLocalChange(v.get('opSet'), binaryChange, false, null))\n        }\n      })\n  })\n  backend.frozen = true\n  return [{state}, patch]\n}\n\n/**\n * Returns the state of the document serialised to an Uint8Array.\n */\nfunction save(backend) {\n  return encodeDocument(getChanges(backend, []))\n}\n\n/**\n * Loads the document and/or changes contained in an Uint8Array, and returns a\n * backend initialised with this state.\n */\nfunction load(data) {\n  // Reconstruct the original change history that created the document.\n  // It's a bit silly to convert to and from the binary encoding several times...!\n  const binaryChanges = decodeChanges([data]).map(encodeChange)\n  return loadChanges(init(), binaryChanges)\n}\n\n/**\n * Applies a list of `changes` to the node state `backend`, and returns the updated\n * state with those changes incorporated. Unlike `applyChanges()`, this function\n * does not produce a patch describing the incremental modifications, making it\n * a little faster when loading a document from disk. When all the changes have\n * been loaded, you can use `getPatch()` to construct the latest document state.\n */\nfunction loadChanges(backend, changes) {\n  const state = backendState(backend)\n  const [newState, _] = apply(state, changes, null, false, false)\n  backend.frozen = true\n  return {state: newState}\n}\n\n/**\n * Returns a patch that, when applied to an empty document, constructs the\n * document tree in the state described by the node state `backend`.\n */\nfunction getPatch(backend) {\n  const state = backendState(backend)\n  const diffs = constructPatch(save(backend))\n  return makePatch(state, diffs, null, false)\n}\n\nfunction getChangesForActor(backend, actorId) {\n  const state = backendState(backend)\n  return OpSet.getChangesForActor(state.get('opSet'), actorId)\n}\n\nfunction getChanges(backend, haveDeps) {\n  if (!Array.isArray(haveDeps)) {\n    throw new TypeError('Pass an array of hashes to Backend.getChanges()')\n  }\n  const state = backendState(backend)\n  return OpSet.getMissingChanges(state.get('opSet'), List(haveDeps))\n}\n\nfunction getMissingDeps(backend) {\n  const state = backendState(backend)\n  return OpSet.getMissingDeps(state.get('opSet'))\n}\n\n/**\n * Undoes the last change by the local user in the node state `state`. The\n * `request` object contains all parts of the change except the operations;\n * this function fetches the operations from the undo stack, pushes a record\n * onto the redo stack, and returns a two-element list `[state, change]`\n * where `change` is the change to be applied.\n */\nfunction undo(state, request, startOp) {\n  const undoPos = state.getIn(['opSet', 'undoPos'])\n  const undoOps = state.getIn(['opSet', 'undoStack', undoPos - 1])\n  if (undoPos < 1 || !undoOps) {\n    throw new RangeError('Cannot undo: there is nothing to be undone')\n  }\n  const { actor, seq, deps, time, message } = request\n  const change = {actor, seq, startOp, deps, time, message, ops: undoOps.toJS()}\n\n  let opSet = state.get('opSet')\n  let redoOps = List().withMutations(redoOps => {\n    for (let op of undoOps) {\n      if (!['set', 'del', 'link', 'inc'].includes(op.get('action'))) {\n        throw new RangeError(`Unexpected operation type in undo history: ${op}`)\n      }\n      // TODO this duplicates OpSet.recordUndoHistory\n      const key = OpSet.getOperationKey(op)\n      const fieldOps = OpSet.getFieldOps(opSet, op.get('obj'), key)\n      if (op.get('action') === 'inc') {\n        redoOps.push(Map({action: 'inc', obj: op.get('obj'), key, insert: false, value: -op.get('value')}))\n      } else if (fieldOps.isEmpty()) {\n        redoOps.push(Map({action: 'del', obj: op.get('obj'), key, insert: false}))\n      } else {\n        for (let fieldOp of fieldOps) {\n          if (fieldOp.get('insert')) {\n            fieldOp = fieldOp.remove('insert').set('key', key)\n          }\n          if (fieldOp.get('action').startsWith('make')) {\n            const childId = fieldOp.get('child', fieldOp.get('opId'))\n            fieldOp = fieldOp.set('action', 'link').set('child', childId)\n          }\n          fieldOp = fieldOp.remove('opId').remove('pred').set('insert', false)\n          redoOps.push(fieldOp)\n        }\n      }\n    }\n  })\n\n  opSet = opSet\n    .set('undoPos', undoPos - 1)\n    .update('redoStack', stack => stack.push(redoOps))\n  return [state.set('opSet', opSet), change]\n}\n\n/**\n * Redoes the last `undo()` in the node state `state`. The `request` object\n * contains all parts of the change except the operations; this function\n * fetches the operations from the redo stack, and returns two-element list\n * `[state, change]` where `change` is the change to be applied.\n */\nfunction redo(state, request, startOp) {\n  const redoOps = state.getIn(['opSet', 'redoStack']).last()\n  if (!redoOps) {\n    throw new RangeError('Cannot redo: the last change was not an undo')\n  }\n  const { actor, seq, deps, time, message } = request\n  const change = {actor, seq, startOp, deps, time, message, ops: redoOps.toJS()}\n\n  let opSet = state.get('opSet')\n    .update('undoPos', undoPos => undoPos + 1)\n    .update('redoStack', stack => stack.pop())\n  return [state.set('opSet', opSet), change]\n}\n\nfunction getUndoStack(backend) {\n  return backendState(backend).getIn(['opSet', 'undoStack']).toJS()\n}\n\nfunction getRedoStack(backend) {\n  return backendState(backend).getIn(['opSet', 'redoStack']).toJS()\n}\n\nmodule.exports = {\n  init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch,\n  getChangesForActor, getChanges, getMissingDeps, getUndoStack, getRedoStack\n}\n","const { Map, List, Set, fromJS } = require('immutable')\nconst { SkipList } = require('./skip_list')\nconst { decodeChange, decodeChangeMeta } = require('./columnar')\nconst { ROOT_ID, parseOpId } = require('../src/common')\n\n// Returns true if all changes that causally precede the given change\n// have already been applied in `opSet`.\nfunction causallyReady(opSet, change) {\n  for (let hash of change.deps) {\n    if (!opSet.hasIn(['hashes', hash])) return false\n  }\n  return true\n}\n\n/**\n * Returns the path from the root object to the given objectId, as an array of\n * operations describing the objects and keys traversed. If there are several\n * paths to the same object, returns one of the paths arbitrarily.\n */\nfunction getPath(opSet, objectId) {\n  let path = []\n  while (objectId !== ROOT_ID) {\n    const ref = opSet.getIn(['byObject', objectId, '_inbound'], Set()).first()\n    if (!ref) throw new RangeError(`No path found to object ${objectId}`)\n    path.unshift(ref)\n    objectId = ref.get('obj')\n  }\n  return path\n}\n\n/**\n * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n * the type of the object with ID `objectId`.\n */\nfunction getObjectType(opSet, objectId) {\n  if (objectId === ROOT_ID) return 'map'\n  const objInit = opSet.getIn(['byObject', objectId, '_init', 'action'])\n  const type = {makeMap: 'map', makeTable: 'table', makeList: 'list', makeText: 'text'}[objInit]\n  if (!type) throw new RangeError(`Unknown object type ${objInit} for ${objectId}`)\n  return type\n}\n\n// Processes a 'makeMap', 'makeList', 'makeTable', or 'makeText' operation\nfunction applyMake(opSet, op, patch) {\n  const objectId = getChildId(op), action = op.get('action')\n  if (opSet.hasIn(['byObject', objectId, '_keys'])) throw new Error(`Duplicate creation of object ${objectId}`)\n\n  let object = Map({_init: op, _inbound: Set(), _keys: Map()})\n  if (action === 'makeList' || action === 'makeText') {\n    object = object.set('_elemIds', new SkipList())\n  }\n  opSet = opSet.setIn(['byObject', objectId], object)\n\n  if (patch) {\n    patch.objectId = objectId\n    patch.type = getObjectType(opSet, objectId)\n  }\n  return opSet\n}\n\n// Processes an insertion operation. Does not modify any patch because the new list element\n// only becomes visible through the assignment of a value to the new list element.\nfunction applyInsert(opSet, op) {\n  const objectId = op.get('obj'), opId = op.get('opId')\n  if (!opSet.get('byObject').has(objectId)) throw new Error(`Modification of unknown object ${objectId}`)\n  if (opSet.hasIn(['byObject', objectId, '_insertion', opId])) throw new Error(`Duplicate list element ID ${opId}`)\n\n  return opSet\n    .updateIn(['byObject', objectId, '_following', op.get('key')], List(), list => list.push(op))\n    .setIn(['byObject', objectId, '_insertion', opId], op)\n}\n\nfunction updateListElement(opSet, objectId, elemId, patch) {\n  const ops = getFieldOps(opSet, objectId, elemId)\n  let elemIds = opSet.getIn(['byObject', objectId, '_elemIds'])\n  let index = elemIds.indexOf(elemId)\n\n  if (patch && patch.edits === undefined) {\n    patch.edits = []\n  }\n\n  if (index >= 0) {\n    if (ops.isEmpty()) {\n      elemIds = elemIds.removeIndex(index)\n      if (patch) patch.edits.push({action: 'remove', index})\n    } else {\n      elemIds = elemIds.setValue(elemId, ops.first().get('value'))\n    }\n\n  } else {\n    if (ops.isEmpty()) return opSet // deleting a non-existent element = no-op\n\n    // find the index of the closest preceding list element\n    let prevId = elemId\n    while (true) {\n      index = -1\n      prevId = getPrevious(opSet, objectId, prevId)\n      if (!prevId) break\n      index = elemIds.indexOf(prevId)\n      if (index >= 0) break\n    }\n\n    index += 1\n    elemIds = elemIds.insertIndex(index, elemId, ops.first().get('value'))\n    if (patch) patch.edits.push({action: 'insert', index})\n  }\n  return opSet.setIn(['byObject', objectId, '_elemIds'], elemIds)\n}\n\n/**\n * Computes the inverse of operation `op` and adds it to the list of undo operations\n * (`undoLocal`) in `opSet`. The inverse is the operation that restores the modified\n * field to its previous value. Returns the updated `opSet`.\n */\nfunction recordUndoHistory(opSet, op) {\n  if (!opSet.has('undoLocal')) return opSet\n  const objectId = op.get('obj'), key = getOperationKey(op), value = op.get('value')\n\n  let undoOps\n  if (op.get('action') === 'inc') {\n    undoOps = List.of(Map({action: 'inc', obj: objectId, key, insert: false, value: -value}))\n  } else {\n    undoOps = getFieldOps(opSet, objectId, key).map(ref => {\n      if (ref.get('insert')) {\n        ref = ref.set('key', key)\n      }\n      if (ref.get('action').startsWith('make')) {\n        ref = ref.set('action', 'link').set('child', getChildId(ref))\n      }\n      ref = ref.filter((v, k) => ['action', 'obj', 'key', 'value', 'datatype', 'child'].includes(k))\n      ref = ref.set('insert', false)\n      return ref\n    })\n  }\n  if (undoOps.isEmpty()) {\n    undoOps = List.of(Map({action: 'del', obj: objectId, key, insert: false}))\n  }\n  return opSet.update('undoLocal', undoLocal => undoLocal.concat(undoOps))\n}\n\n/**\n * Returns true if the operation `op` introduces a child object.\n */\nfunction isChildOp(op) {\n  const action = op.get('action')\n  return action.startsWith('make') || action === 'link'\n}\n\n/**\n * Returns the object ID of the child introduced by `op`.\n */\nfunction getChildId(op) {\n  return op.get('child', op.get('opId'))\n}\n\n/**\n * Returns the key that is updated by the given operation. In the case of lists and text,\n * the key is the element ID; in the case of maps, it is the property name.\n */\nfunction getOperationKey(op) {\n  return op.get('insert') ? op.get('opId') : op.get('key')\n}\n\n/**\n * Processes a 'set', 'del', 'make*', 'link', or 'inc' operation. Mutates `patch`\n * to describe the change and returns an updated `opSet`.\n */\nfunction applyAssign(opSet, op, patch) {\n  const objectId = op.get('obj'), action = op.get('action'), key = getOperationKey(op)\n  if (!opSet.get('byObject').has(objectId)) throw new RangeError(`Modification of unknown object ${objectId}`)\n  const type = getObjectType(opSet, objectId)\n\n  if (patch) {\n    patch.objectId = patch.objectId || objectId\n    if (patch.objectId !== objectId) {\n      throw new RangeError(`objectId mismatch in patch: ${patch.objectId} != ${objectId}`)\n    }\n    if (patch.props === undefined) {\n      patch.props = {}\n    }\n    if (patch.props[key] === undefined) {\n      patch.props[key] = {}\n    }\n\n    patch.type = patch.type || type\n    if (patch.type !== type) {\n      throw new RangeError(`object type mismatch in patch: ${patch.type} != ${type}`)\n    }\n  }\n\n  if (action.startsWith('make')) {\n    if (patch) {\n      patch.props[key][op.get('opId')] = {}\n      opSet = applyMake(opSet, op, patch.props[key][op.get('opId')])\n    } else {\n      opSet = applyMake(opSet, op)\n    }\n  }\n  if (action === 'link' && patch) {\n    patch.props[key][op.get('opId')] = constructObject(opSet, getChildId(op))\n  }\n\n  const ops = getFieldOps(opSet, objectId, key)\n  let overwritten, remaining\n\n  if (action === 'inc') {\n    overwritten = List()\n    remaining = ops.map(other => {\n      if (other.get('action') === 'set' && typeof other.get('value') === 'number' &&\n          other.get('datatype') === 'counter' && op.get('pred').includes(other.get('opId'))) {\n        return other.set('value', other.get('value') + op.get('value'))\n      } else {\n        return other\n      }\n    })\n  } else {\n    const priorOpsOverwritten = ops.groupBy(other => op.get('pred').includes(other.get('opId')))\n    overwritten = priorOpsOverwritten.get(true,  List())\n    remaining   = priorOpsOverwritten.get(false, List())\n  }\n\n  // If any child object references were overwritten, remove them from the index of inbound links\n  for (let old of overwritten.filter(isChildOp)) {\n    opSet = opSet.updateIn(['byObject', getChildId(old), '_inbound'], ops => ops.remove(old))\n  }\n\n  if (isChildOp(op)) {\n    opSet = opSet.updateIn(['byObject', getChildId(op), '_inbound'], Set(), ops => ops.add(op))\n  }\n  if (action === 'set' || isChildOp(op)) { // not 'inc' or 'del'\n    remaining = remaining.push(op)\n  }\n  remaining = remaining.sort(lamportCompare).reverse()\n  opSet = opSet.setIn(['byObject', objectId, '_keys', key], remaining)\n  setPatchProps(opSet, objectId, key, patch)\n\n  if (type === 'list' || type === 'text') {\n    opSet = updateListElement(opSet, objectId, key, patch)\n  }\n  return opSet\n}\n\n/**\n * Updates `patch` with the fields required in a patch. `pathOp` is an operation\n * along the path from the root to the object being modified, as returned by\n * `getPath()`. Returns the sub-object representing the child identified by this\n * operation.\n */\nfunction initializePatch(opSet, pathOp, patch) {\n  const objectId = pathOp.get('obj'), opId = pathOp.get('opId'), key = getOperationKey(pathOp)\n  const type = getObjectType(opSet, objectId)\n  patch.objectId = patch.objectId || objectId\n  patch.type     = patch.type     || type\n\n  if (patch.objectId !== objectId) {\n    throw new RangeError(`objectId mismatch in path: ${patch.objectId} != ${objectId}`)\n  }\n  if (patch.type !== type) {\n    throw new RangeError(`object type mismatch in path: ${patch.type} != ${type}`)\n  }\n  setPatchProps(opSet, objectId, key, patch)\n\n  if (patch.props[key][opId] === undefined) {\n    throw new RangeError(`field ops for ${key} did not contain opId ${opId}`)\n  }\n  return patch.props[key][opId]\n}\n\n/**\n * Updates `patch` to include all the values (including conflicts) for the field\n * `key` of the object with ID `objectId`.\n */\nfunction setPatchProps(opSet, objectId, key, patch) {\n  if (!patch) return\n  if (patch.props === undefined) {\n    patch.props = {}\n  }\n  if (patch.props[key] === undefined) {\n    patch.props[key] = {}\n  }\n\n  const ops = {}\n  for (let op of getFieldOps(opSet, objectId, key)) {\n    const opId = op.get('opId')\n    ops[opId] = true\n\n    if (op.get('action') === 'set') {\n      patch.props[key][opId] = {value: op.get('value')}\n      if (op.get('datatype')) {\n        patch.props[key][opId].datatype = op.get('datatype')\n      }\n    } else if (isChildOp(op)) {\n      if (!patch.props[key][opId]) {\n        const childId = getChildId(op)\n        patch.props[key][opId] = {objectId: childId, type: getObjectType(opSet, childId)}\n      }\n    } else {\n      throw new RangeError(`Unexpected operation in field ops: ${op.get('action')}`)\n    }\n  }\n\n  // Remove any values that appear in the patch, but were not returned by getFieldOps()\n  for (let opId of Object.keys(patch.props[key])) {\n    if (!ops[opId]) {\n      delete patch.props[key][opId]\n    }\n  }\n}\n\n/**\n * Mutates `patch`, changing elemId-based addressing of lists to index-based\n * addressing. (This can only be done once all the changes have been applied,\n * since the indexes are still in flux until that point.)\n */\nfunction finalizePatch(opSet, patch) {\n  if (!patch || !patch.props) return\n\n  if (patch.type === 'list' || patch.type === 'text') {\n    const elemIds = opSet.getIn(['byObject', patch.objectId, '_elemIds'])\n    const newProps = {}\n    for (let elemId of Object.keys(patch.props)) {\n      if (/^[0-9]+$/.test(elemId)) {\n        newProps[elemId] = patch.props[elemId]\n      } else if (Object.keys(patch.props[elemId]).length > 0) {\n        const index = elemIds.indexOf(elemId)\n        if (index < 0) throw new RangeError(`List element has no index: ${elemId}`)\n        newProps[index] = patch.props[elemId]\n      }\n    }\n    patch.props = newProps\n  }\n\n  for (let key of Object.keys(patch.props)) {\n    for (let opId of Object.keys(patch.props[key])) {\n      finalizePatch(opSet, patch.props[key][opId])\n    }\n  }\n}\n\n/**\n * Applies the operations in the `change` to `opSet`. As a side-effect, `patch`\n * is mutated to describe the changes. Returns the updated `opSet`.\n */\nfunction applyOps(opSet, change, patch) {\n  const actor = change.get('actor'), seq = change.get('seq'), startOp = change.get('startOp')\n  let newObjects = Set()\n  change.get('ops').forEach((op, index) => {\n    const action = op.get('action'), obj = op.get('obj'), insert = op.get('insert')\n    if (!['set', 'del', 'inc', 'link', 'makeMap', 'makeList', 'makeText', 'makeTable'].includes(action)) {\n      throw new RangeError(`Unknown operation action: ${action}`)\n    }\n    if (!op.get('pred')) {\n      throw new RangeError(`Missing 'pred' field in operation ${op}`)\n    }\n\n    let localPatch = patch\n    if (patch) {\n      for (let pathOp of getPath(opSet, obj)) {\n        localPatch = initializePatch(opSet, pathOp, localPatch)\n      }\n    }\n\n    const opWithId = op.merge({opId: `${startOp + index}@${actor}`})\n    if (insert) {\n      opSet = applyInsert(opSet, opWithId)\n    }\n    if (action.startsWith('make')) {\n      newObjects = newObjects.add(getChildId(opWithId))\n    }\n    if (!newObjects.contains(obj)) {\n      opSet = recordUndoHistory(opSet, opWithId)\n    }\n    opSet = applyAssign(opSet, opWithId, localPatch)\n  })\n  return opSet\n}\n\n/**\n * Applies the changeset `change` to `opSet` (unless it has already been applied,\n * in which case we do nothing). As a side-effect, `patch` is mutated to describe\n * the changes. Returns the updated `opSet`.\n */\nfunction applyChange(opSet, binaryChange, patch) {\n  const change = fromJS(decodeChange(binaryChange))\n  const actor = change.get('actor'), seq = change.get('seq'), startOp = change.get('startOp'), hash = change.get('hash')\n  if (typeof actor !== 'string' || typeof seq !== 'number' || typeof startOp !== 'number') {\n    throw new TypeError(`Missing change metadata: actor = ${actor}, seq = ${seq}, startOp = ${startOp}`)\n  }\n  if (opSet.hasIn(['hashes', hash])) return opSet // change already applied, return unchanged\n\n  const expectedSeq = opSet.getIn(['states', actor], List()).size + 1\n  if (seq !== expectedSeq) {\n    throw new RangeError(`Expected change ${expectedSeq} by ${actor}, got change ${seq}`)\n  }\n\n  let maxOpId = 0\n  for (let depHash of change.get('deps')) {\n    maxOpId = Math.max(maxOpId, opSet.getIn(['hashes', depHash, 'maxOpId']))\n    opSet = opSet.updateIn(['hashes', depHash, 'depsFuture'], Set(), future => future.add(hash))\n  }\n  if (startOp !== maxOpId + 1) {\n    throw new RangeError(`Expected startOp to be ${maxOpId + 1}, was ${startOp}`)\n  }\n\n  let queue = change.get('deps'), sameActorDep = (seq === 1)\n  while (!sameActorDep && !queue.isEmpty()) {\n    const dep = opSet.getIn(['hashes', queue.first()])\n    queue = queue.shift()\n    if (dep.get('actor') === actor && dep.get('seq') === seq - 1) {\n      sameActorDep = true\n    } else {\n      queue = queue.concat(dep.get('depsPast'))\n    }\n  }\n  if (!sameActorDep) {\n    throw new RangeError('Change lacks dependency on prior sequence number by the same actor')\n  }\n\n  const changeInfo = Map({\n    actor, seq, startOp,\n    change: binaryChange,\n    maxOpId: startOp + change.get('ops').size - 1,\n    depsPast: change.get('deps').toSet(),\n    depsFuture: Set()\n  })\n\n  opSet = applyOps(opSet, change, patch)\n  return opSet\n    .setIn(['hashes', hash], changeInfo)\n    .updateIn(['states', actor], List(), prior => prior.push(hash))\n    .update('deps', deps => deps.subtract(change.get('deps')).add(hash))\n    .update('maxOp', maxOp => Math.max(maxOp, changeInfo.get('maxOpId')))\n    .update('history', history => history.push(hash))\n}\n\nfunction applyQueuedOps(opSet, patch) {\n  let queue = List()\n  while (true) {\n    for (let change of opSet.get('queue')) {\n      if (causallyReady(opSet, decodeChangeMeta(change, false))) {\n        opSet = applyChange(opSet, change, patch)\n      } else {\n        queue = queue.push(change)\n      }\n    }\n\n    if (queue.count() === opSet.get('queue').count()) return opSet\n    opSet = opSet.set('queue', queue)\n    queue = List()\n  }\n}\n\nfunction pushUndoHistory(opSet) {\n  const undoPos = opSet.get('undoPos')\n  return opSet\n    .update('undoStack', stack => {\n      return stack\n        .slice(0, undoPos)\n        .push(opSet.get('undoLocal'))\n    })\n    .set('undoPos', undoPos + 1)\n    .set('redoStack', List())\n    .remove('undoLocal')\n}\n\nfunction init() {\n  return Map()\n    .set('states',   Map())\n    .set('history',  List())\n    .set('byObject', Map().set(ROOT_ID, Map().set('_keys', Map())))\n    .set('hashes',   Map())\n    .set('deps',     Set())\n    .set('maxOp',     0)\n    .set('undoPos',   0)\n    .set('undoStack', List())\n    .set('redoStack', List())\n    .set('queue',    List())\n}\n\n/**\n * Adds `change` to `opSet` without any modification or undo history creation\n * (e.g. because it's a remote change, or we have loaded it from disk). `change`\n * is given as an Immutable.js Map object. `patch` is mutated to describe the\n * change (in the format used by patches).\n */\nfunction addChange(opSet, change, patch) {\n  opSet = opSet.update('queue', queue => queue.push(change))\n  return applyQueuedOps(opSet, patch)\n}\n\n/**\n * Applies a change made by the local user and adds it to `opSet`. The `change`\n * is given as an Immutable.js Map object. If `isUndoable` is true, an undo\n * history entry is created. `patch` is mutated to describe the change (in the\n * format used by patches).\n */\nfunction addLocalChange(opSet, change, isUndoable, patch) {\n  if (isUndoable) {\n    opSet = opSet.set('undoLocal', List()) // setting the undoLocal key enables undo history capture\n    opSet = applyChange(opSet, change, patch)\n    opSet = pushUndoHistory(opSet)\n  } else {\n    opSet = applyChange(opSet, change, patch)\n  }\n  return opSet\n}\n\n/**\n * Returns all the changes in `opSet` that need to be sent to another replica.\n * `haveDeps` is an Immutable.js List object containing the hashes (as hex\n * strings) of the heads that the other replica has. Those changes in `haveDeps`\n * and any of their transitive dependencies will not be returned; any changes\n * later than or concurrent to the hashes in `haveDeps` will be returned.\n * If `haveDeps` is an empty list, all changes are returned.\n *\n * NOTE: This function throws an exception if any of the given hashes are not\n * known to this replica. This means that if the other replica is ahead of us,\n * this function cannot be used directly to find the changes to send.\n * TODO need to fix this.\n */\nfunction getMissingChanges(opSet, haveDeps) {\n  let stack = haveDeps, seenHashes = {}\n  while (!stack.isEmpty()) {\n    const hash = stack.last()\n    const deps = opSet.getIn(['hashes', hash, 'depsPast'])\n    if (!deps) throw new RangeError(`hash not found: ${hash}`)\n    stack = stack.pop().concat(deps)\n    seenHashes[hash] = true\n  }\n\n  return opSet.get('history')\n    .filter(hash => !seenHashes[hash])\n    .map(hash => opSet.getIn(['hashes', hash, 'change']))\n    .toJSON()\n}\n\nfunction getChangesForActor(opSet, forActor, afterSeq) {\n  afterSeq = afterSeq || 0\n\n  return opSet.getIn(['states', forActor], List())\n    .skip(afterSeq)\n    .map(hash => opSet.getIn(['hashes', hash, 'change']))\n    .toJSON()\n}\n\nfunction getMissingDeps(opSet) {\n  let missing = {}, inQueue = {}\n  for (let binaryChange of opSet.get('queue')) {\n    const change = decodeChangeMeta(binaryChange, true)\n    inQueue[change.hash] = true\n    for (let depHash of change.deps) {\n      if (!opSet.hasIn(['hashes', depHash])) missing[depHash] = true\n    }\n  }\n  return Object.keys(missing).filter(hash => !inQueue[hash]).sort()\n}\n\nfunction getFieldOps(opSet, objectId, key) {\n  return opSet.getIn(['byObject', objectId, '_keys', key], List())\n}\n\nfunction getParent(opSet, objectId, key) {\n  if (key === '_head') return\n  const insertion = opSet.getIn(['byObject', objectId, '_insertion', key])\n  if (!insertion) throw new TypeError(`Missing index entry for list element ${key}`)\n  return insertion.get('key')\n}\n\nfunction lamportCompare(op1, op2) {\n  const time1 = parseOpId(op1.get('opId')), time2 = parseOpId(op2.get('opId'))\n  if (time1.counter < time2.counter) return -1\n  if (time1.counter > time2.counter) return  1\n  if (time1.actorId < time2.actorId) return -1\n  if (time1.actorId > time2.actorId) return  1\n  return 0\n}\n\nfunction insertionsAfter(opSet, objectId, parentId, childId) {\n  let childKey = null\n  if (childId) childKey = Map({opId: childId})\n\n  return opSet\n    .getIn(['byObject', objectId, '_following', parentId], List())\n    .filter(op => op.get('insert') && (!childKey || lamportCompare(op, childKey) < 0))\n    .sort(lamportCompare)\n    .reverse() // descending order\n    .map(op => op.get('opId'))\n}\n\nfunction getNext(opSet, objectId, key) {\n  const children = insertionsAfter(opSet, objectId, key)\n  if (!children.isEmpty()) return children.first()\n\n  let ancestor\n  while (true) {\n    ancestor = getParent(opSet, objectId, key)\n    if (!ancestor) return\n    const siblings = insertionsAfter(opSet, objectId, ancestor, key)\n    if (!siblings.isEmpty()) return siblings.first()\n    key = ancestor\n  }\n}\n\n// Given the ID of a list element, returns the ID of the immediate predecessor list element,\n// or null if the given list element is at the head.\nfunction getPrevious(opSet, objectId, key) {\n  const parentId = getParent(opSet, objectId, key)\n  let children = insertionsAfter(opSet, objectId, parentId)\n  if (children.first() === key) {\n    if (parentId === '_head') return null; else return parentId;\n  }\n\n  let prevId\n  for (let child of children) {\n    if (child === key) break\n    prevId = child\n  }\n  while (true) {\n    children = insertionsAfter(opSet, objectId, prevId)\n    if (children.isEmpty()) return prevId\n    prevId = children.last()\n  }\n}\n\nfunction constructField(opSet, op) {\n  if (isChildOp(op)) {\n    return constructObject(opSet, getChildId(op))\n  } else if (op.get('action') === 'set') {\n    const result = {value: op.get('value')}\n    if (op.get('datatype')) result.datatype = op.get('datatype')\n    return result\n  } else {\n    throw new TypeError(`Unexpected operation action: ${op.get('action')}`)\n  }\n}\n\nfunction constructMap(opSet, objectId, type) {\n  const patch = {objectId, type, props: {}}\n  for (let [key, fieldOps] of opSet.getIn(['byObject', objectId, '_keys']).entries()) {\n    if (!fieldOps.isEmpty()) {\n      patch.props[key] = {}\n      for (let op of fieldOps) {\n        patch.props[key][op.get('opId')] = constructField(opSet, op)\n      }\n    }\n  }\n  return patch\n}\n\nfunction constructList(opSet, objectId, type) {\n  const patch = {objectId, type, props: {}, edits: []}\n  let elemId = '_head', index = 0, maxCounter = 0\n\n  while (true) {\n    elemId = getNext(opSet, objectId, elemId)\n    if (!elemId) {\n      return patch\n    }\n    maxCounter = Math.max(maxCounter, parseOpId(elemId).counter)\n\n    const fieldOps = getFieldOps(opSet, objectId, elemId)\n    if (!fieldOps.isEmpty()) {\n      patch.edits.push({action: 'insert', index})\n      patch.props[index] = {}\n      for (let op of fieldOps) {\n        patch.props[index][op.get('opId')] = constructField(opSet, op)\n      }\n      index += 1\n    }\n  }\n}\n\nfunction constructObject(opSet, objectId) {\n  const type = getObjectType(opSet, objectId)\n  if (type === 'map' || type === 'table') {\n    return constructMap(opSet, objectId, type)\n  } else if (type === 'list' || type === 'text') {\n    return constructList(opSet, objectId, type)\n  } else {\n    throw new RangeError(`Unknown object type: ${type}`)\n  }\n}\n\nmodule.exports = {\n  init, addChange, addLocalChange, getMissingChanges, getChangesForActor, getMissingDeps,\n  constructObject, getFieldOps, getOperationKey, finalizePatch, ROOT_ID\n}\n","const { Map } = require('immutable')\n\n// Returns a random number from the geometric distribution with p = 0.75.\n// That is, returns k with probability p * (1 - p)^(k - 1).\n// For example, returns 1 with probability 3/4, returns 2 with probability 3/16,\n// returns 3 with probability 3/64, and so on.\nfunction randomLevel() {\n  // NOTE: this function used to be a generator; it has been converted to a regular\n  // function (that mimics the interface of a generator) to avoid having to include\n  // generator polyfills in the distribution build.\n  return {\n    next() {\n      // Create random number between 0 and 2^32 - 1\n      const rand = Math.floor(Math.random() * 0x100000000)\n      // Count leading zeros in that 32-bit number\n      let level = 1\n      while (rand < 1 << (32 - 2 * level) && level < 16) level += 1\n      return { value: level, done: false }\n    }\n  }\n}\n\nclass Node {\n  constructor (key, value, level, prevKey, nextKey, prevCount, nextCount) {\n    this.key = key\n    this.value = value\n    this.level = level\n    this.prevKey = prevKey\n    this.nextKey = nextKey\n    this.prevCount = prevCount\n    this.nextCount = nextCount\n  }\n\n  setValue (value) {\n    return new Node(this.key, value, this.level, this.prevKey, this.nextKey,\n                    this.prevCount, this.nextCount)\n  }\n\n  insertAfter (newKey, newLevel, fromLevel, distance) {\n    if (newLevel > this.level && this.key !== null) {\n      throw new RangeError('Cannot increase the level of a non-head node')\n    }\n    const maxLevel = Math.max(this.level, newLevel)\n    const nextKey = this.nextKey.slice()\n    const nextCount = this.nextCount.slice()\n\n    for (let level = fromLevel; level < maxLevel; level++) {\n      if (level < newLevel) {\n        nextKey[level] = newKey\n        nextCount[level] = distance\n      } else {\n        nextCount[level] += 1\n      }\n    }\n\n    return new Node(this.key, this.value, maxLevel,\n                    this.prevKey, nextKey, this.prevCount, nextCount)\n  }\n\n  insertBefore (newKey, newLevel, fromLevel, distance) {\n    if (newLevel > this.level) throw new RangeError('Cannot increase node level')\n    const prevKey = this.prevKey.slice()\n    const prevCount = this.prevCount.slice()\n\n    for (let level = fromLevel; level < this.level; level++) {\n      if (level < newLevel) {\n        prevKey[level] = newKey\n        prevCount[level] = distance\n      } else {\n        prevCount[level] += 1\n      }\n    }\n\n    return new Node(this.key, this.value, this.level,\n                    prevKey, this.nextKey, prevCount, this.nextCount)\n  }\n\n  removeAfter (fromLevel, removedLevel, newKeys, distances) {\n    const nextKey = this.nextKey.slice()\n    const nextCount = this.nextCount.slice()\n\n    for (let level = fromLevel; level < this.level; level++) {\n      if (level < removedLevel) {\n        nextKey[level] = newKeys[level]\n        nextCount[level] = distances[level]\n      } else {\n        nextCount[level] -= 1\n      }\n    }\n\n    return new Node(this.key, this.value, this.level,\n                    this.prevKey, nextKey, this.prevCount, nextCount)\n  }\n\n  removeBefore (fromLevel, removedLevel, newKeys, distances) {\n    const prevKey = this.prevKey.slice()\n    const prevCount = this.prevCount.slice()\n\n    for (let level = fromLevel; level < this.level; level++) {\n      if (level < removedLevel) {\n        prevKey[level] = newKeys[level]\n        prevCount[level] = distances[level]\n      } else {\n        prevCount[level] -= 1\n      }\n    }\n\n    return new Node(this.key, this.value, this.level,\n                    prevKey, this.nextKey, prevCount, this.nextCount)\n  }\n}\n\nclass SkipList {\n  constructor (randomSource) {\n    const head = new Node(null, null, 1, [], [null], [], [null])\n    const random = randomSource ? randomSource() : randomLevel()\n    return makeInstance(0, Map().set(null, head), random)\n  }\n\n  get headNode () {\n    return this._nodes.get(null)\n  }\n\n  predecessors (predecessor, maxLevel) {\n    const preKeys = [predecessor], preCounts = [1]\n\n    for (let level = 1; level < maxLevel; level++) {\n      let preKey = preKeys[level - 1]\n      let count = preCounts[level - 1]\n      while (preKey) {\n        let node = this._nodes.get(preKey)\n        if (node.level > level) break\n        if (node.level < level) {\n          throw new RangeError('Node ' + preKey + ' below expected level ' + (level - 1))\n        }\n        count += node.prevCount[level - 1]\n        preKey = node.prevKey[level - 1]\n      }\n      preKeys[level] = preKey\n      preCounts[level] = count\n    }\n\n    return {preKeys, preCounts}\n  }\n\n  successors (successor, maxLevel) {\n    const sucKeys = [successor], sucCounts = [1]\n\n    for (let level = 1; level < maxLevel; level++) {\n      let sucKey = sucKeys[level - 1]\n      let count = sucCounts[level - 1]\n      while (sucKey) {\n        let node = this._nodes.get(sucKey)\n        if (node.level > level) break\n        if (node.level < level) {\n          throw new RangeError('Node ' + sucKey + ' below expected level ' + (level - 1))\n        }\n        count += node.nextCount[level - 1]\n        sucKey = node.nextKey[level - 1]\n      }\n      sucKeys[level] = sucKey\n      sucCounts[level] = count\n    }\n\n    return {sucKeys, sucCounts}\n  }\n\n  // Inserts a new list element immediately after the element with key `predecessor`.\n  // If predecessor === null, inserts at the head of the list.\n  insertAfter (predecessor, key, value) {\n    if (typeof key !== 'string' || key === '') {\n      throw new RangeError('Key must be a nonempty string')\n    }\n    if (!this._nodes.has(predecessor)) {\n      throw new RangeError('The referenced predecessor key does not exist')\n    }\n    if (this._nodes.has(key)) {\n      throw new RangeError('Cannot insert a key that already exists')\n    }\n\n    const newLevel = this._randomSource.next().value\n    const maxLevel = Math.max(newLevel, this.headNode.level)\n    const successor = this._nodes.get(predecessor).nextKey[0] || null\n    const { preKeys, preCounts } = this.predecessors(predecessor, maxLevel)\n    const { sucKeys, sucCounts } = this.successors(successor, maxLevel)\n\n    return makeInstance(this.length + 1, this._nodes.withMutations(nodes => {\n      let preLevel = 0, sucLevel = 0\n      for (let level = 1; level <= maxLevel; level++) {\n        const updateLevel = Math.min(level, newLevel)\n        if (level === maxLevel || preKeys[level] !== preKeys[preLevel]) {\n          nodes.update(preKeys[preLevel],\n                       node => node.insertAfter(key, updateLevel, preLevel, preCounts[preLevel]))\n          preLevel = level\n        }\n        if (sucKeys[sucLevel] && (level === maxLevel || sucKeys[level] !== sucKeys[sucLevel])) {\n          nodes.update(sucKeys[sucLevel],\n                       node => node.insertBefore(key, updateLevel, sucLevel, sucCounts[sucLevel]))\n          sucLevel = level\n        }\n      }\n\n      nodes.set(key, new Node(key, value, newLevel,\n                              preKeys.slice(0, newLevel),\n                              sucKeys.slice(0, newLevel),\n                              preCounts.slice(0, newLevel),\n                              sucCounts.slice(0, newLevel)))\n    }), this._randomSource)\n  }\n\n  insertIndex (index, key, value) {\n    if (typeof index !== 'number' || index < 0) {\n      throw new RangeError('Index must be a non-negative integer')\n    }\n    if (index === 0) {\n      return this.insertAfter(null, key, value)\n    } else {\n      return this.insertAfter(this.keyOf(index - 1), key, value)\n    }\n  }\n\n  removeKey (key) {\n    if (typeof key !== 'string' || !this._nodes.has(key)) {\n      throw new RangeError('The given key cannot be removed because it does not exist')\n    }\n    const removedNode = this._nodes.get(key)\n    const maxLevel = this.headNode.level\n    const { preKeys, preCounts } = this.predecessors(removedNode.prevKey[0], maxLevel)\n    const { sucKeys, sucCounts } = this.successors  (removedNode.nextKey[0], maxLevel)\n    const distances = new Array(maxLevel)\n\n    for (let level = 0; level < maxLevel; level++) {\n      distances[level] = preCounts[level] + sucCounts[level] - 1\n    }\n\n    return makeInstance(this.length - 1, this._nodes.withMutations(nodes => {\n      nodes.remove(key)\n      let preLevel = 0, sucLevel = 0\n\n      for (let level = 1; level <= maxLevel; level++) {\n        const updateLevel = Math.min(level, removedNode.level)\n        if (level === maxLevel || preKeys[level] !== preKeys[preLevel]) {\n          nodes.update(preKeys[preLevel],\n                       node => node.removeAfter(preLevel, updateLevel, sucKeys, distances))\n          preLevel = level\n        }\n        if (sucKeys[sucLevel] && (level === maxLevel || sucKeys[level] !== sucKeys[sucLevel])) {\n          nodes.update(sucKeys[sucLevel],\n                       node => node.removeBefore(sucLevel, updateLevel, preKeys, distances))\n          sucLevel = level\n        }\n      }\n    }), this._randomSource)\n  }\n\n  removeIndex (index) {\n    return this.removeKey(this.keyOf(index))\n  }\n\n  indexOf (key) {\n    if (typeof key !== 'string' || key === '' || !this._nodes.has(key)) return -1\n    let node = this._nodes.get(key), count = 0\n    while (node && node.key) {\n      count += node.prevCount[node.level - 1]\n      node = this._nodes.get(node.prevKey[node.level - 1])\n    }\n    return count - 1\n  }\n\n  keyOf (index) {\n    if (typeof index !== 'number') return null\n    if (index < 0) index = index + this.length\n    if (index < 0 || index >= this.length) return null\n\n    let node = this._nodes.get(null), level = node.level - 1, count = 0\n    while (true) {\n      if (count === index + 1) {\n        return node.key\n      } else if (count + node.nextCount[level] > index + 1) {\n        level -= 1\n      } else {\n        count += node.nextCount[level]\n        node = this._nodes.get(node.nextKey[level])\n      }\n    }\n  }\n\n  getValue (key) {\n    if (typeof key !== 'string' || key === '') {\n      throw new RangeError('Key must be a nonempty string')\n    }\n    const node = this._nodes.get(key)\n    return node && node.value\n  }\n\n  setValue (key, value) {\n    if (typeof key !== 'string' || key === '') {\n      throw new RangeError('Key must be a nonempty string')\n    }\n    let node = this._nodes.get(key)\n    if (!node) throw new RangeError('The referenced key does not exist')\n\n    node = node.setValue(value)\n    return makeInstance(this.length, this._nodes.set(key, node), this._randomSource)\n  }\n\n  iterator (mode) {\n    // NOTE: this method used to be a generator; it has been converted to a regular\n    // method (that mimics the interface of a generator) to avoid having to include\n    // generator polyfills in the distribution build.\n    const nodes = this._nodes\n    let key = nodes.get(null).nextKey[0]\n    return {\n      next () {\n        if (!key) return { value: undefined, done: true }\n        const node = nodes.get(key)\n        let rval = undefined\n        switch (mode) {\n          case 'keys':    rval = {value: key,               done: false}; break\n          case 'values':  rval = {value: node.value,        done: false}; break\n          case 'entries': rval = {value: [key, node.value], done: false}; break\n        }\n        key = node.nextKey[0]\n        return rval\n      },\n      [Symbol.iterator]: () => this.iterator(mode),\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this.iterator('values')\n  }\n}\n\nfunction makeInstance(length, nodes, randomSource) {\n  const instance = Object.create(SkipList.prototype)\n  instance.length = length\n  instance._nodes = nodes\n  instance._randomSource = randomSource\n  return instance\n}\n\nmodule.exports = {SkipList}\n","const { ROOT_ID, isObject, copyObject, parseOpId } = require('../src/common')\nconst { OPTIONS, OBJECT_ID, CONFLICTS } = require('./constants')\nconst { Text, instantiateText } = require('./text')\nconst { Table, instantiateTable } = require('./table')\nconst { Counter } = require('./counter')\n\n/**\n * Reconstructs the value from the patch object `patch`.\n */\nfunction getValue(patch, object, updated) {\n  if (patch.objectId) {\n    // If the objectId of the existing object does not match the objectId in the patch,\n    // that means the patch is replacing the object with a new one made from scratch\n    if (object && object[OBJECT_ID] !== patch.objectId) {\n      object = undefined\n    }\n    return interpretPatch(patch, object, updated)\n  } else if (patch.datatype === 'timestamp') {\n    // Timestamp: value is milliseconds since 1970 epoch\n    return new Date(patch.value)\n  } else if (patch.datatype === 'counter') {\n    return new Counter(patch.value)\n  } else if (patch.datatype !== undefined) {\n    throw new TypeError(`Unknown datatype: ${patch.datatype}`)\n  } else {\n    // Primitive value (number, string, boolean, or null)\n    return patch.value\n  }\n}\n\n/**\n * Compares two strings, interpreted as Lamport timestamps of the form\n * 'counter@actorId'. Returns 1 if ts1 is greater, or -1 if ts2 is greater.\n */\nfunction lamportCompare(ts1, ts2) {\n  const regex = /^(\\d+)@(.*)$/\n  const time1 = regex.test(ts1) ? parseOpId(ts1) : {counter: 0, actorId: ts1}\n  const time2 = regex.test(ts2) ? parseOpId(ts2) : {counter: 0, actorId: ts2}\n  if (time1.counter < time2.counter) return -1\n  if (time1.counter > time2.counter) return  1\n  if (time1.actorId < time2.actorId) return -1\n  if (time1.actorId > time2.actorId) return  1\n  return 0\n}\n\n/**\n * `props` is an object of the form:\n * `{key1: {opId1: {...}, opId2: {...}}, key2: {opId3: {...}}}`\n * where the outer object is a mapping from property names to inner objects,\n * and the inner objects are a mapping from operation ID to sub-patch.\n * This function interprets that structure and updates the objects `object` and\n * `conflicts` to reflect it. For each key, the greatest opId (by Lamport TS\n * order) is chosen as the default resolution; that op's value is assigned\n * to `object[key]`. Moreover, all the opIds and values are packed into a\n * conflicts object of the form `{opId1: value1, opId2: value2}` and assigned\n * to `conflicts[key]`. If there is no conflict, the conflicts object contains\n * just a single opId-value mapping.\n */\nfunction applyProperties(props, object, conflicts, updated) {\n  if (!props) return\n\n  for (let key of Object.keys(props)) {\n    const values = {}, opIds = Object.keys(props[key]).sort(lamportCompare).reverse()\n    for (let opId of opIds) {\n      const subpatch = props[key][opId]\n      if (conflicts[key] && conflicts[key][opId]) {\n        values[opId] = getValue(subpatch, conflicts[key][opId], updated)\n      } else {\n        values[opId] = getValue(subpatch, undefined, updated)\n      }\n    }\n\n    if (opIds.length === 0) {\n      delete object[key]\n      delete conflicts[key]\n    } else {\n      object[key] = values[opIds[0]]\n      conflicts[key] = values\n    }\n  }\n}\n\n/**\n * `edits` is an array of edits to a list data structure, each of which is an object of the form\n * either `{action: 'insert', index}` or `{action: 'remove', index}`. This merges adjacent edits\n * and calls `insertCallback(index, count)` or `removeCallback(index, count)`, as appropriate,\n * for each sequence of insertions or removals.\n */\nfunction iterateEdits(edits, insertCallback, removeCallback) {\n  if (!edits) return\n  let splicePos = -1, deletions, insertions\n\n  for (let i = 0; i < edits.length; i++) {\n    const edit = edits[i], action = edit.action, index = edit.index\n\n    if (action === 'insert') {\n      if (splicePos < 0) {\n        splicePos = index\n        deletions = 0\n        insertions = 0\n      }\n      insertions += 1\n\n      // If there are multiple consecutive insertions at successive indexes,\n      // accumulate them and then process them in a single insertCallback\n      if (i === edits.length - 1 ||\n          edits[i + 1].action !== 'insert' ||\n          edits[i + 1].index  !== index + 1) {\n        insertCallback(splicePos, insertions)\n        splicePos = -1\n      }\n\n    } else if (action === 'remove') {\n      if (splicePos < 0) {\n        splicePos = index\n        deletions = 0\n        insertions = 0\n      }\n      deletions += 1\n\n      // If there are multiple consecutive removals of the same index,\n      // accumulate them and then process them in a single removeCallback\n      if (i === edits.length - 1 ||\n          edits[i + 1].action !== 'remove' ||\n          edits[i + 1].index  !== index) {\n        removeCallback(splicePos, deletions)\n        splicePos = -1\n      }\n    } else {\n      throw new RangeError(`Unknown list edit action: ${action}`)\n    }\n  }\n}\n\n/**\n * Creates a writable copy of an immutable map object. If `originalObject`\n * is undefined, creates an empty object with ID `objectId`.\n */\nfunction cloneMapObject(originalObject, objectId) {\n  const object    = copyObject(originalObject)\n  const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : undefined)\n  Object.defineProperty(object, OBJECT_ID, {value: objectId})\n  Object.defineProperty(object, CONFLICTS, {value: conflicts})\n  return object\n}\n\n/**\n * Updates the map object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateMapObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneMapObject(obj, objectId)\n  }\n\n  const object = updated[objectId]\n  applyProperties(patch.props, object, object[CONFLICTS], updated)\n  return object\n}\n\n/**\n * Updates the table object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTableObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = obj ? obj._clone() : instantiateTable(objectId)\n  }\n\n  const object = updated[objectId]\n\n  for (let key of Object.keys(patch.props || {})) {\n    const values = {}, opIds = Object.keys(patch.props[key])\n\n    if (opIds.length === 0) {\n      object.remove(key)\n    } else if (opIds.length === 1) {\n      const subpatch = patch.props[key][opIds[0]]\n      object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0])\n    } else {\n      throw new RangeError('Conflicts are not supported on properties of a table')\n    }\n  }\n  return object\n}\n\n/**\n * Creates a writable copy of an immutable list object. If `originalList` is\n * undefined, creates an empty list with ID `objectId`.\n */\nfunction cloneListObject(originalList, objectId) {\n  const list = originalList ? originalList.slice() : [] // slice() makes a shallow clone\n  const conflicts = (originalList && originalList[CONFLICTS]) ? originalList[CONFLICTS].slice() : []\n  Object.defineProperty(list, OBJECT_ID, {value: objectId})\n  Object.defineProperty(list, CONFLICTS, {value: conflicts})\n  return list\n}\n\n/**\n * Updates the list object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateListObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneListObject(obj, objectId)\n  }\n\n  const list = updated[objectId], conflicts = list[CONFLICTS]\n\n  iterateEdits(patch.edits,\n    (index, insertions) => { // insertion\n      const blanks = new Array(insertions)\n      list     .splice(index, 0, ...blanks)\n      conflicts.splice(index, 0, ...blanks)\n    },\n    (index, count) => { // deletion\n      list     .splice(index, count)\n      conflicts.splice(index, count)\n    }\n  )\n\n  applyProperties(patch.props, list, conflicts, updated)\n  return list\n}\n\n/**\n * Updates the text object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTextObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  let elems\n  if (updated[objectId]) {\n    elems = updated[objectId].elems\n  } else if (obj) {\n    elems = obj.elems.slice()\n  } else {\n    elems = []\n  }\n\n  iterateEdits(patch.edits,\n    (index, insertions) => { // insertion\n      const blanks = []\n      for (let i = 0; i < insertions; i++) blanks.push({})\n      elems.splice(index, 0, ...blanks)\n    },\n    (index, deletions) => { // deletion\n      elems.splice(index, deletions)\n    }\n  )\n\n  for (let key of Object.keys(patch.props || {})) {\n    const opId = Object.keys(patch.props[key]).sort(lamportCompare).reverse()[0]\n    if (!opId) throw new RangeError(`No default value at index ${key}`)\n\n    // TODO Text object does not support conflicts. Should it?\n    const oldValue = (elems[key].opId === opId) ? elems[key].value : undefined\n    elems[key].value = getValue(patch.props[key][opId], oldValue, updated)\n    elems[key].opId = opId\n  }\n\n  updated[objectId] = instantiateText(objectId, elems)\n  return updated[objectId]\n}\n\n/**\n * Applies the patch object `patch` to the read-only document object `obj`.\n * Clones a writable copy of `obj` and places it in `updated` (indexed by\n * objectId), if that has not already been done. Returns the updated object.\n */\nfunction interpretPatch(patch, obj, updated) {\n  // Return original object if it already exists and isn't being modified\n  if (isObject(obj) && !patch.props && !patch.edits && !updated[patch.objectId]) {\n    return obj\n  }\n\n  if (patch.type === 'map') {\n    return updateMapObject(patch, obj, updated)\n  } else if (patch.type === 'table') {\n    return updateTableObject(patch, obj, updated)\n  } else if (patch.type === 'list') {\n    return updateListObject(patch, obj, updated)\n  } else if (patch.type === 'text') {\n    return updateTextObject(patch, obj, updated)\n  } else {\n    throw new TypeError(`Unknown object type: ${patch.type}`)\n  }\n}\n\n/**\n * Creates a writable copy of the immutable document root object `root`.\n */\nfunction cloneRootObject(root) {\n  if (root[OBJECT_ID] !== ROOT_ID) {\n    throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`)\n  }\n  return cloneMapObject(root, ROOT_ID)\n}\n\nmodule.exports = {\n  interpretPatch, cloneRootObject\n}\n","// Properties of the document root object\nconst OPTIONS   = Symbol('_options')   // object containing options passed to init()\nconst CACHE     = Symbol('_cache')     // map from objectId to immutable object\nconst STATE     = Symbol('_state')     // object containing metadata about current state (e.g. sequence numbers)\n\n// Properties of all Automerge objects\nconst OBJECT_ID = Symbol('_objectId')  // the object ID of the current object (string)\nconst CONFLICTS = Symbol('_conflicts') // map or list (depending on object type) of conflicts\nconst CHANGE    = Symbol('_change')    // the context object on proxy objects used in change callback\n\nmodule.exports = {\n  OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE\n}\n","const { CACHE, OBJECT_ID, CONFLICTS } = require('./constants')\nconst { interpretPatch } = require('./apply_patch')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter, getWriteableCounter } = require('./counter')\nconst { ROOT_ID, isObject, copyObject } = require('../src/common')\nconst uuid = require('../src/uuid')\n\n\n/**\n * An instance of this class is passed to `rootObjectProxy()`. The methods are\n * called by proxy object mutation functions to query the current object state\n * and to apply the requested changes.\n */\nclass Context {\n  constructor (doc, actorId, applyPatch) {\n    this.actorId = actorId\n    this.cache = doc[CACHE]\n    this.updated = {}\n    this.ops = []\n    this.applyPatch = applyPatch ? applyPatch : interpretPatch\n  }\n\n  /**\n   * Adds an operation object to the list of changes made in the current context.\n   */\n  addOp(operation) {\n    this.ops.push(operation)\n  }\n\n  /**\n   * Takes a value and returns an object describing the value (in the format used by patches).\n   */\n  getValueDescription(value) {\n    if (!['object', 'boolean', 'number', 'string'].includes(typeof value)) {\n      throw new TypeError(`Unsupported type of value: ${typeof value}`)\n    }\n\n    if (isObject(value)) {\n      if (value instanceof Date) {\n        // Date object, represented as milliseconds since epoch\n        return {value: value.getTime(), datatype: 'timestamp'}\n\n      } else if (value instanceof Counter) {\n        // Counter object\n        return {value: value.value, datatype: 'counter'}\n\n      } else {\n        // Nested object (map, list, text, or table)\n        const objectId = value[OBJECT_ID]\n        if (!objectId) {\n          throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`)\n        }\n        return {objectId, type: this.getObjectType(objectId)}\n      }\n    } else {\n      // Primitive value (number, string, boolean, or null)\n      return {value}\n    }\n  }\n\n  /**\n   * Builds the values structure describing a single property in a patch. Finds all the values of\n   * property `key` of `object` (there might be multiple values in the case of a conflict), and\n   * returns an object that maps operation IDs to descriptions of values.\n   */\n  getValuesDescriptions(path, object, key) {\n    if (object instanceof Table) {\n      // Table objects don't have conflicts, since rows are identified by their unique objectId\n      const value = object.byId(key)\n      if (value) {\n        return {[key]: this.getValueDescription(value)}\n      } else {\n        return {}\n      }\n    } else {\n      // Map, list, or text objects\n      const conflicts = object[CONFLICTS][key], values = {}\n      if (!conflicts) {\n        throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`)\n      }\n      for (let opId of Object.keys(conflicts)) {\n        values[opId] = this.getValueDescription(conflicts[opId])\n      }\n      return values\n    }\n  }\n\n  /**\n   * Returns the value at property `key` of object `object`. In the case of a conflict, returns\n   * the value whose assignment operation has the ID `opId`.\n   */\n  getPropertyValue(object, key, opId) {\n    if (object instanceof Table) {\n      return object.byId(key)\n    } else {\n      return object[CONFLICTS][key][opId]\n    }\n  }\n\n  /**\n   * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed\n   * by mutating the patch object. Returns the subpatch at the given path.\n   */\n  getSubpatch(patch, path) {\n    let subpatch = patch.diffs, object = this.getObject(ROOT_ID)\n\n    for (let pathElem of path) {\n      if (!subpatch.props) {\n        subpatch.props = {}\n      }\n      if (!subpatch.props[pathElem.key]) {\n        subpatch.props[pathElem.key] = this.getValuesDescriptions(path, object, pathElem.key)\n      }\n\n      let nextOpId = null, values = subpatch.props[pathElem.key]\n      for (let opId of Object.keys(values)) {\n        if (values[opId].objectId === pathElem.objectId) {\n          nextOpId = opId\n        }\n      }\n      if (!nextOpId) {\n        throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`)\n      }\n      subpatch = values[nextOpId]\n      object = this.getPropertyValue(object, pathElem.key, nextOpId)\n    }\n\n    if (!subpatch.props) {\n      subpatch.props = {}\n    }\n    return subpatch\n  }\n\n  /**\n   * Returns an object (not proxied) from the cache or updated set, as appropriate.\n   */\n  getObject(objectId) {\n    const object = this.updated[objectId] || this.cache[objectId]\n    if (!object) throw new RangeError(`Target object does not exist: ${objectId}`)\n    return object\n  }\n\n  /**\n   * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n   * the type of the object with ID `objectId`.\n   */\n  getObjectType(objectId) {\n    if (objectId === ROOT_ID) return 'map'\n    const object = this.getObject(objectId)\n    if (object instanceof Text) return 'text'\n    if (object instanceof Table) return 'table'\n    if (Array.isArray(object)) return 'list'\n    return 'map'\n  }\n\n  /**\n   * Returns the value associated with the property named `key` on the object\n   * at path `path`. If the value is an object, returns a proxy for it.\n   */\n  getObjectField(path, objectId, key) {\n    if (!['string', 'number'].includes(typeof key)) return\n    const object = this.getObject(objectId)\n\n    if (object[key] instanceof Counter) {\n      return getWriteableCounter(object[key].value, this, path, objectId, key)\n\n    } else if (isObject(object[key])) {\n      const childId = object[key][OBJECT_ID]\n      const subpath = path.concat([{key, objectId: childId}])\n      // The instantiateObject function is added to the context object by rootObjectProxy()\n      return this.instantiateObject(subpath, childId)\n\n    } else {\n      return object[key]\n    }\n  }\n\n  /**\n   * Recursively creates Automerge versions of all the objects and nested objects in `value`,\n   * constructing a patch and operations that describe the object tree. The new object is\n   * assigned to the property `key` in the object with ID `obj`. If `insert` is true, a new\n   * list element is created at index `key`, and the new object is assigned to that list\n   * element. If `key` is null, the ID of the new object is used as key (this construction\n   * is used by Automerge.Table).\n   */\n  createNestedObjects(obj, key, value, insert) {\n    if (value[OBJECT_ID]) {\n      throw new RangeError('Cannot create a reference to an existing document object')\n    }\n    const child = uuid()\n    if (key === null) key = child\n\n    if (value instanceof Text) {\n      // Create a new Text object\n      this.addOp({action: 'makeText', obj, key, insert, child})\n      const subpatch = {objectId: child, type: 'text', edits: [], props: {}}\n      this.insertListItems(subpatch, 0, [...value], true)\n      return subpatch\n\n    } else if (value instanceof Table) {\n      // Create a new Table object\n      if (value.count > 0) {\n        throw new RangeError('Assigning a non-empty Table object is not supported')\n      }\n      this.addOp({action: 'makeTable', obj, key, insert, child})\n      return {objectId: child, type: 'table', props: {}}\n\n    } else if (Array.isArray(value)) {\n      // Create a new list object\n      this.addOp({action: 'makeList', obj, key, insert, child})\n      const subpatch = {objectId: child, type: 'list', edits: [], props: {}}\n      this.insertListItems(subpatch, 0, value, true)\n      return subpatch\n\n    } else {\n      // Create a new map object\n      this.addOp({action: 'makeMap', obj, key, insert, child})\n      let props = {}\n      for (let nested of Object.keys(value)) {\n        const valuePatch = this.setValue(child, nested, value[nested], false)\n        props[nested] = {[this.actorId]: valuePatch}\n      }\n      return {objectId: child, type: 'map', props}\n    }\n  }\n\n  /**\n   * Records an assignment to a particular key in a map, or a particular index in a list.\n   * `objectId` is the ID of the object being modified, `key` is the property name or list\n   * index being updated, and `value` is the new value being assigned. If `insert` is true,\n   * a new list element is inserted at index `key`, and `value` is assigned to that new list\n   * element. Returns a patch describing the new value. The return value is of the form\n   * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a\n   * primitive value. For string, number, boolean, or null the datatype is omitted.\n   */\n  setValue(objectId, key, value, insert) {\n    if (!objectId) {\n      throw new RangeError('setValue needs an objectId')\n    }\n    if (key === '') {\n      throw new RangeError('The key of a map entry must not be an empty string')\n    }\n\n    if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter)) {\n      // Nested object (map, list, text, or table)\n      return this.createNestedObjects(objectId, key, value, insert)\n    } else {\n      // Date or counter object, or primitive value (number, string, boolean, or null)\n      const description = this.getValueDescription(value)\n      this.addOp(Object.assign({action: 'set', obj: objectId, key, insert}, description))\n      return description\n    }\n  }\n\n  /**\n   * Constructs a new patch, calls `callback` with the subpatch at the location `path`,\n   * and then immediately applies the patch to the document.\n   */\n  applyAtPath(path, callback) {\n    let patch = {diffs: {objectId: ROOT_ID, type: 'map'}}\n    callback(this.getSubpatch(patch, path))\n    this.applyPatch(patch.diffs, this.cache[ROOT_ID], this.updated)\n  }\n\n  /**\n   * Updates the map object at path `path`, setting the property with name\n   * `key` to `value`.\n   */\n  setMapKey(path, key, value) {\n    if (typeof key !== 'string') {\n      throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`)\n    }\n\n    const objectId = path.length === 0 ? ROOT_ID : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (object[key] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned field value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const valuePatch = this.setValue(objectId, key, value, false)\n        subpatch.props[key] = {[this.actorId]: valuePatch}\n      })\n    }\n  }\n\n  /**\n   * Updates the map object at path `path`, deleting the property `key`.\n   */\n  deleteMapKey(path, key) {\n    const objectId = path.length === 0 ? ROOT_ID : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n\n    if (object[key] !== undefined) {\n      this.addOp({action: 'del', obj: objectId, key, insert: false})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[key] = {}\n      })\n    }\n  }\n\n  /**\n   * Inserts a sequence of new list elements `values` into a list, starting at position `index`.\n   * `newObject` is true if we are creating a new list object, and false if we are updating an\n   * existing one. `subpatch` is the patch for the list object being modified. Mutates\n   * `subpatch` to reflect the sequence of values.\n   */\n  insertListItems(subpatch, index, values, newObject) {\n    const list = newObject ? [] : this.getObject(subpatch.objectId)\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`)\n    }\n\n    for (let offset = 0; offset < values.length; offset++) {\n      const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true)\n      subpatch.edits.push({action: 'insert', index: index + offset})\n      subpatch.props[index + offset] = {[this.actorId]: valuePatch}\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, replacing the current value at\n   * position `index` with the new value `value`.\n   */\n  setListIndex(path, index, value) {\n    const objectId = path.length === 0 ? ROOT_ID : path[path.length - 1].objectId\n    const list = this.getObject(objectId)\n    if (index === list.length) {\n      return this.splice(path, index, 0, [value])\n    }\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`)\n    }\n    if (list[index] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned list element value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const valuePatch = this.setValue(objectId, index, value, false)\n        subpatch.props[index] = {[this.actorId]: valuePatch}\n      })\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, deleting `deletions` list elements starting from\n   * list index `start`, and inserting the list of new elements `insertions` at that position.\n   */\n  splice(path, start, deletions, insertions) {\n    const objectId = path.length === 0 ? ROOT_ID : path[path.length - 1].objectId\n    let list = this.getObject(objectId)\n    if (start < 0 || deletions < 0 || start > list.length - deletions) {\n      throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`)\n    }\n    if (deletions === 0 && insertions.length === 0) return\n\n    let patch = {diffs: {objectId: ROOT_ID, type: 'map'}}\n    let subpatch = this.getSubpatch(patch, path)\n    if (!subpatch.edits) subpatch.edits = []\n\n    if (deletions > 0) {\n      for (let i = 0; i < deletions; i++) {\n        this.addOp({action: 'del', obj: objectId, key: start, insert: false})\n        subpatch.edits.push({action: 'remove', index: start})\n      }\n    }\n\n    if (insertions.length > 0) {\n      this.insertListItems(subpatch, start, insertions, false)\n    }\n    this.applyPatch(patch.diffs, this.cache[ROOT_ID], this.updated)\n  }\n\n  /**\n   * Updates the table object at path `path`, adding a new entry `row`.\n   * Returns the objectId of the new row.\n   */\n  addTableRow(path, row) {\n    if (!isObject(row) || Array.isArray(row)) {\n      throw new TypeError('A table row must be an object')\n    }\n    if (row[OBJECT_ID]) {\n      throw new TypeError('Cannot reuse an existing object as table row')\n    }\n    if (row.id) {\n      throw new TypeError('A table row must not have an \"id\" property; it is generated automatically')\n    }\n\n    const valuePatch = this.setValue(path[path.length - 1].objectId, null, row, false)\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[valuePatch.objectId] = {[valuePatch.objectId]: valuePatch}\n    })\n    return valuePatch.objectId\n  }\n\n  /**\n   * Updates the table object at path `path`, deleting the row with ID `rowId`.\n   */\n  deleteTableRow(path, rowId) {\n    const objectId = path[path.length - 1].objectId, table = this.getObject(objectId)\n\n    if (table.byId(rowId)) {\n      this.addOp({action: 'del', obj: objectId, key: rowId, insert: false})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[rowId] = {}\n      })\n    }\n  }\n\n  /**\n   * Adds the integer `delta` to the value of the counter located at property\n   * `key` in the object at path `path`.\n   */\n  increment(path, key, delta) {\n    const objectId = path.length === 0 ? ROOT_ID : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (!(object[key] instanceof Counter)) {\n      throw new TypeError('Only counter values can be incremented')\n    }\n\n    // TODO what if there is a conflicting value on the same key as the counter?\n    const value = object[key].value + delta\n    this.addOp({action: 'inc', obj: objectId, key, value: delta, insert: false})\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[key] = {[this.actorId]: {value, datatype: 'counter'}}\n    })\n  }\n}\n\nmodule.exports = {\n  Context\n}\n","/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nclass Counter {\n  constructor(value) {\n    this.value = value || 0\n    Object.freeze(this)\n  }\n\n  /**\n   * A peculiar JavaScript language feature from its early days: if the object\n   * `x` has a `valueOf()` method that returns a number, you can use numerical\n   * operators on the object `x` directly, such as `x + 1` or `x < 4`.\n   * This method is also called when coercing a value to a string by\n   * concatenating it with another string, as in `x + ''`.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n   */\n  valueOf() {\n    return this.value\n  }\n\n  /**\n   * Returns the counter value as a decimal string. If `x` is a counter object,\n   * this method is called e.g. when you do `['value: ', x].join('')` or when\n   * you use string interpolation: `value: ${x}`.\n   */\n  toString() {\n    return this.valueOf().toString()\n  }\n\n  /**\n   * Returns the counter value, so that a JSON serialization of an Automerge\n   * document represents the counter simply as an integer.\n   */\n  toJSON() {\n    return this.value\n  }\n}\n\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n  /**\n   * Increases the value of the counter by `delta`. If `delta` is not given,\n   * increases the value of the counter by 1.\n   */\n  increment(delta) {\n    delta = typeof delta === 'number' ? delta : 1\n    this.context.increment(this.path, this.key, delta)\n    this.value += delta\n    return this.value\n  }\n\n  /**\n   * Decreases the value of the counter by `delta`. If `delta` is not given,\n   * decreases the value of the counter by 1.\n   */\n  decrement(delta) {\n    return this.increment(typeof delta === 'number' ? -delta : -1)\n  }\n}\n\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n*/\nfunction getWriteableCounter(value, context, path, objectId, key) {\n  const instance = Object.create(WriteableCounter.prototype)\n  instance.value = value\n  instance.context = context\n  instance.path = path\n  instance.objectId = objectId\n  instance.key = key\n  return instance\n}\n\nmodule.exports = { Counter, getWriteableCounter }\n","const { OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE } = require('./constants')\nconst { ROOT_ID, isObject, copyObject } = require('../src/common')\nconst uuid = require('../src/uuid')\nconst { interpretPatch, cloneRootObject } = require('./apply_patch')\nconst { rootObjectProxy } = require('./proxies')\nconst { Context } = require('./context')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter } = require('./counter')\n\n/**\n * Actor IDs must consist only of hexadecimal digits so that they can be encoded\n * compactly in binary form.\n */\nfunction checkActorId(actorId) {\n  if (typeof actorId !== 'string') {\n    throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`)\n  }\n  if (!/^[0-9a-f]+$/.test(actorId)) {\n    throw new RangeError('actorId must consist only of lowercase hex digits')\n  }\n  if (actorId.length % 2 !== 0) {\n    throw new RangeError('actorId must consist of an even number of digits')\n  }\n}\n\n/**\n * Takes a set of objects that have been updated (in `updated`) and an updated state object\n * `state`, and returns a new immutable document root object based on `doc` that reflects\n * those updates.\n */\nfunction updateRootObject(doc, updated, state) {\n  let newDoc = updated[ROOT_ID]\n  if (!newDoc) {\n    newDoc = cloneRootObject(doc[CACHE][ROOT_ID])\n    updated[ROOT_ID] = newDoc\n  }\n  Object.defineProperty(newDoc, OPTIONS,  {value: doc[OPTIONS]})\n  Object.defineProperty(newDoc, CACHE,    {value: updated})\n  Object.defineProperty(newDoc, STATE,    {value: state})\n\n  if (doc[OPTIONS].freeze) {\n    for (let objectId of Object.keys(updated)) {\n      if (updated[objectId] instanceof Table) {\n        updated[objectId]._freeze()\n      } else if (updated[objectId] instanceof Text) {\n        Object.freeze(updated[objectId].elems)\n        Object.freeze(updated[objectId])\n      } else {\n        Object.freeze(updated[objectId])\n        Object.freeze(updated[objectId][CONFLICTS])\n      }\n    }\n  }\n\n  for (let objectId of Object.keys(doc[CACHE])) {\n    if (!updated[objectId]) {\n      updated[objectId] = doc[CACHE][objectId]\n    }\n  }\n\n  if (doc[OPTIONS].freeze) {\n    Object.freeze(updated)\n  }\n  return newDoc\n}\n\n/**\n * Adds a new change request to the list of pending requests, and returns an\n * updated document root object. `requestType` is a string indicating the type\n * of request, which may be \"change\", \"undo\", or \"redo\". For the \"change\" request\n * type, the details of the change are taken from the context object `context`.\n * `options` contains properties that may affect how the change is processed; in\n * particular, the `message` property of `options` is an optional human-readable\n * string describing the change.\n */\nfunction makeChange(doc, requestType, context, options) {\n  const actor = getActorId(doc)\n  if (!actor) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const state = copyObject(doc[STATE])\n  state.seq += 1\n\n  const request = {\n    requestType, actor, seq: state.seq,\n    time: Math.round(new Date().getTime() / 1000),\n    message: (options && typeof options.message === 'string') ? options.message : '',\n    version: state.version\n  }\n  if (options && options.undoable === false) {\n    request.undoable = false\n  }\n  if (context) {\n    request.ops = context.ops\n  }\n\n  if (doc[OPTIONS].backend) {\n    const [backendState, patch] = doc[OPTIONS].backend.applyLocalChange(state.backendState, request)\n    state.backendState = backendState\n    // NOTE: When performing a local change, the patch is effectively applied twice -- once by the\n    // context invoking interpretPatch as soon as any change is made, and the second time here\n    // (after a round-trip through the backend). This is perhaps more robust, as changes only take\n    // effect in the form processed by the backend, but the downside is a performance cost.\n    // Should we change this?\n    return [applyPatchToDoc(doc, patch, state, true), request]\n\n  } else {\n    if (!context) context = new Context(doc, actor)\n    const queuedRequest = copyObject(request)\n    queuedRequest.before = doc\n    state.requests = state.requests.concat([queuedRequest])\n    return [updateRootObject(doc, context.updated, state), request]\n  }\n}\n\n/**\n * Applies the changes described in `patch` to the document with root object\n * `doc`. The state object `state` is attached to the new root object.\n * `fromBackend` should be set to `true` if the patch came from the backend,\n * and to `false` if the patch is a transient local (optimistically applied)\n * change from the frontend.\n */\nfunction applyPatchToDoc(doc, patch, state, fromBackend) {\n  const actor = getActorId(doc)\n  const updated = {}\n  interpretPatch(patch.diffs, doc, updated)\n\n  if (fromBackend) {\n    if (!patch.clock) throw new RangeError('patch is missing clock field')\n    if (patch.clock[actor] && patch.clock[actor] > state.seq) {\n      state.seq = patch.clock[actor]\n    }\n    state.clock   = patch.clock\n    state.deps    = patch.deps\n    state.version = patch.version\n    state.canUndo = patch.canUndo\n    state.canRedo = patch.canRedo\n  }\n  return updateRootObject(doc, updated, state)\n}\n\n/**\n * Creates an empty document object with no changes.\n */\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported value for init() options: ${options}`)\n  }\n\n  if (!options.deferActorId) {\n    if (options.actorId === undefined) {\n      options.actorId = uuid()\n    }\n    checkActorId(options.actorId)\n  }\n\n  const root = {}, cache = {[ROOT_ID]: root}\n  const state = {seq: 0, requests: [], version: 0, clock: {}, deps: [], canUndo: false, canRedo: false}\n  if (options.backend) {\n    state.backendState = options.backend.init()\n  }\n  Object.defineProperty(root, OBJECT_ID, {value: ROOT_ID})\n  Object.defineProperty(root, OPTIONS,   {value: Object.freeze(options)})\n  Object.defineProperty(root, CONFLICTS, {value: Object.freeze({})})\n  Object.defineProperty(root, CACHE,     {value: Object.freeze(cache)})\n  Object.defineProperty(root, STATE,     {value: Object.freeze(state)})\n  return Object.freeze(root)\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  return change(init(options), 'Initialization', doc => Object.assign(doc, initialState))\n}\n\n\n/**\n * Changes a document `doc` according to actions taken by the local user.\n * `options` is an object that can contain the following properties:\n *  - `message`: an optional descriptive string that is attached to the change.\n *  - `undoable`: false if the change should not affect the undo history.\n * If `options` is a string, it is treated as `message`.\n *\n * The actual change is made within the callback function `callback`, which is\n * given a mutable version of the document as argument. Returns a two-element\n * array `[doc, request]` where `doc` is the updated document, and `request`\n * is the change request to send to the backend. If nothing was actually\n * changed, returns the original `doc` and a `null` change request.\n */\nfunction change(doc, options, callback) {\n  if (doc[OBJECT_ID] !== ROOT_ID) {\n    throw new TypeError('The first argument to Automerge.change must be the document root')\n  }\n  if (doc[CHANGE]) {\n    throw new TypeError('Calls to Automerge.change cannot be nested')\n  }\n  if (typeof options === 'function' && callback === undefined) {\n    ;[options, callback] = [callback, options]\n  }\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const context = new Context(doc, actorId)\n  callback(rootObjectProxy(context))\n\n  if (Object.keys(context.updated).length === 0) {\n    // If the callback didn't change anything, return the original document object unchanged\n    return [doc, null]\n  } else {\n    return makeChange(doc, 'change', context, options)\n  }\n}\n\n/**\n * Triggers a new change request on the document `doc` without actually\n * modifying its data. `options` is an object as described in the documentation\n * for the `change` function. This function can be useful for acknowledging the\n * receipt of some message (as it's incorported into the `deps` field of the\n * change). Returns a two-element array `[doc, request]` where `doc` is the\n * updated document, and `request` is the change request to send to the backend.\n */\nfunction emptyChange(doc, options) {\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  return makeChange(doc, 'change', new Context(doc, actorId), options)\n}\n\n/**\n * Applies `patch` to the document root object `doc`. This patch must come\n * from the backend; it may be the result of a local change or a remote change.\n * If it is the result of a local change, the `seq` field from the change\n * request should be included in the patch, so that we can match them up here.\n */\nfunction applyPatch(doc, patch) {\n  const state = copyObject(doc[STATE])\n\n  if (doc[OPTIONS].backend) {\n    if (!patch.state) {\n      throw new RangeError('When an immediate backend is used, a patch must contain the new backend state')\n    }\n    state.backendState = patch.state\n    return applyPatchToDoc(doc, patch, state, true)\n  }\n\n  let baseDoc\n\n  if (state.requests.length > 0) {\n    baseDoc = state.requests[0].before\n    if (patch.actor === getActorId(doc) && patch.seq !== undefined) {\n      if (state.requests[0].seq !== patch.seq) {\n        throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`)\n      }\n      state.requests = state.requests.slice(1).map(copyObject)\n    } else {\n      state.requests = state.requests.slice().map(copyObject)\n    }\n  } else {\n    baseDoc = doc\n    state.requests = []\n  }\n\n  let newDoc = applyPatchToDoc(baseDoc, patch, state, true)\n  if (state.requests.length === 0) {\n    return newDoc\n  } else {\n    state.requests[0].before = newDoc\n    return updateRootObject(doc, {}, state)\n  }\n}\n\n/**\n * Returns `true` if undo is currently possible on the document `doc` (because\n * there is a local change that has not already been undone); `false` if not.\n */\nfunction canUndo(doc) {\n  return !!doc[STATE].canUndo && !isUndoRedoInFlight(doc)\n}\n\n/**\n * Returns `true` if one of the pending requests is an undo or redo.\n */\nfunction isUndoRedoInFlight(doc) {\n  return doc[STATE].requests.some(req => ['undo', 'redo'].includes(req.requestType))\n}\n\n/**\n * Creates a request to perform an undo on the document `doc`, returning a\n * two-element array `[doc, request]` where `doc` is the updated document, and\n * `request` needs to be sent to the backend. `options` is an object as\n * described in the documentation for the `change` function; it may contain a\n * `message` property with an optional change description to attach to the undo.\n * Note that the undo does not take effect immediately: only after the request\n * is sent to the backend, and the backend responds with a patch, does the\n * user-visible document update actually happen.\n */\nfunction undo(doc, options) {\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n  if (!doc[STATE].canUndo) {\n    throw new Error('Cannot undo: there is nothing to be undone')\n  }\n  if (isUndoRedoInFlight(doc)) {\n    throw new Error('Can only have one undo in flight at any one time')\n  }\n  return makeChange(doc, 'undo', null, options)\n}\n\n/**\n * Returns `true` if redo is currently possible on the document `doc` (because\n * a prior action was an undo that has not already been redone); `false` if not.\n */\nfunction canRedo(doc) {\n  return !!doc[STATE].canRedo && !isUndoRedoInFlight(doc)\n}\n\n/**\n * Creates a request to perform a redo of a prior undo on the document `doc`,\n * returning a two-element array `[doc, request]` where `doc` is the updated\n * document, and `request` needs to be sent to the backend. `options` is an\n * object as described in the documentation for the `change` function; it may\n * contain a `message` property with an optional change description to attach\n * to the redo. Note that the redo does not take effect immediately: only\n * after the request is sent to the backend, and the backend responds with a\n * patch, does the user-visible document update actually happen.\n */\nfunction redo(doc, options) {\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n  if (!doc[STATE].canRedo) {\n    throw new Error('Cannot redo: there is no prior undo')\n  }\n  if (isUndoRedoInFlight(doc)) {\n    throw new Error('Can only have one redo in flight at any one time')\n  }\n  return makeChange(doc, 'redo', null, options)\n}\n\n/**\n * Returns the Automerge object ID of the given object.\n */\nfunction getObjectId(object) {\n  return object[OBJECT_ID]\n}\n\n/**\n * Returns the object with the given Automerge object ID. Note: when called\n * within a change callback, the returned object is read-only (not a mutable\n * proxy object).\n */\nfunction getObjectById(doc, objectId) {\n  // It would be nice to return a proxied object in a change callback.\n  // However, that requires knowing the path from the root to the current\n  // object, which we don't have if we jumped straight to the object by its ID.\n  // If we maintained an index from object ID to parent ID we could work out the path.\n  if (doc[CHANGE]) {\n    throw new TypeError('Cannot use getObjectById in a change callback')\n  }\n  return doc[CACHE][objectId]\n}\n\n/**\n * Returns the Automerge actor ID of the given document.\n */\nfunction getActorId(doc) {\n  return doc[STATE].actorId || doc[OPTIONS].actorId\n}\n\n/**\n * Sets the Automerge actor ID on the document object `doc`, returning a\n * document object with updated metadata.\n */\nfunction setActorId(doc, actorId) {\n  checkActorId(actorId)\n  const state = Object.assign({}, doc[STATE], {actorId})\n  return updateRootObject(doc, {}, state)\n}\n\n/**\n * Returns an array of hashes of the \"head\" changes (i.e. those changes that\n * are not depended on by any other change), according to the current doc state.\n */\nfunction getDeps(doc) {\n  return doc[STATE].deps\n}\n\n/**\n * Fetches the conflicts on the property `key` of `object`, which may be any\n * object in a document. If `object` is a list, then `key` must be a list\n * index; if `object` is a map, then `key` must be a property name.\n */\nfunction getConflicts(object, key) {\n  if (object[CONFLICTS] && object[CONFLICTS][key] &&\n      Object.keys(object[CONFLICTS][key]).length > 1) {\n    return object[CONFLICTS][key]\n  }\n}\n\n/**\n * Returns the backend state associated with the document `doc` (only used if\n * a backend implementation is passed to `init()`).\n */\nfunction getBackendState(doc) {\n  return doc[STATE].backendState\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, applyPatch,\n  canUndo, undo, canRedo, redo,\n  getObjectId, getObjectById, getActorId, setActorId, getDeps, getConflicts,\n  getBackendState,\n  Text, Table, Counter\n}\n","const { ROOT_ID } = require('../src/common')\nconst { OBJECT_ID, CHANGE, STATE } = require('./constants')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\n\nfunction parseListIndex(key) {\n  if (typeof key === 'string' && /^[0-9]+$/.test(key)) key = parseInt(key)\n  if (typeof key !== 'number') {\n    throw new TypeError('A list index must be a number, but you passed ' + JSON.stringify(key))\n  }\n  if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n    throw new RangeError('A list index must be positive, but you passed ' + key)\n  }\n  return key\n}\n\nfunction listMethods(context, listId, path) {\n  const methods = {\n    deleteAt(index, numDelete) {\n      context.splice(path, parseListIndex(index), numDelete || 1, [])\n      return this\n    },\n\n    fill(value, start, end) {\n      let list = context.getObject(listId)\n      for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {\n        context.setListIndex(path, index, value)\n      }\n      return this\n    },\n\n    insertAt(index, ...values) {\n      context.splice(path, parseListIndex(index), 0, values)\n      return this\n    },\n\n    pop() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const last = context.getObjectField(path, listId, list.length - 1)\n      context.splice(path, list.length - 1, 1, [])\n      return last\n    },\n\n    push(...values) {\n      let list = context.getObject(listId)\n      context.splice(path, list.length, 0, values)\n      // need to getObject() again because the list object above may be immutable\n      return context.getObject(listId).length\n    },\n\n    shift() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const first = context.getObjectField(path, listId, 0)\n      context.splice(path, 0, 1, [])\n      return first\n    },\n\n    splice(start, deleteCount, ...values) {\n      let list = context.getObject(listId)\n      start = parseListIndex(start)\n      if (deleteCount === undefined) {\n        deleteCount = list.length - start\n      }\n      const deleted = []\n      for (let n = 0; n < deleteCount; n++) {\n        deleted.push(context.getObjectField(path, listId, start + n))\n      }\n      context.splice(path, start, deleteCount, values)\n      return deleted\n    },\n\n    unshift(...values) {\n      context.splice(path, 0, 0, values)\n      return context.getObject(listId).length\n    }\n  }\n\n  for (let iterator of ['entries', 'keys', 'values']) {\n    let list = context.getObject(listId)\n    methods[iterator] = () => list[iterator]()\n  }\n\n  // Read-only methods that can delegate to the JavaScript built-in implementations\n  for (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                      'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                      'slice', 'some', 'toLocaleString', 'toString']) {\n    methods[method] = (...args) => {\n      const list = context.getObject(listId)\n        .map((item, index) => context.getObjectField(path, listId, index))\n      return list[method].call(list, ...args)\n    }\n  }\n\n  return methods\n}\n\nconst MapHandler = {\n  get (target, key) {\n    const { context, objectId, path } = target\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === STATE) return {actorId: context.actorId}\n    return context.getObjectField(path, objectId, key)\n  },\n\n  set (target, key, value) {\n    const { context, objectId, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.setMapKey(path, key, value)\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const { context, objectId, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.deleteMapKey(path, key)\n    return true\n  },\n\n  has (target, key) {\n    const { context, objectId } = target\n    return [OBJECT_ID, CHANGE].includes(key) || (key in context.getObject(objectId))\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    const { context, objectId } = target\n    const object = context.getObject(objectId)\n    if (key in object) {\n      return {configurable: true, enumerable: true}\n    }\n  },\n\n  ownKeys (target) {\n    const { context, objectId } = target\n    return Object.keys(context.getObject(objectId))\n  }\n}\n\nconst ListHandler = {\n  get (target, key) {\n    const [context, objectId, path] = target\n    if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator]\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === 'length') return context.getObject(objectId).length\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return context.getObjectField(path, objectId, parseListIndex(key))\n    }\n    return listMethods(context, objectId, path)[key]\n  },\n\n  set (target, key, value) {\n    const [context, objectId, path] = target\n    context.setListIndex(path, parseListIndex(key), value)\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const [context, objectId, path] = target\n    context.splice(path, parseListIndex(key), 1, [])\n    return true\n  },\n\n  has (target, key) {\n    const [context, objectId, path] = target\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return parseListIndex(key) < context.getObject(objectId).length\n    }\n    return ['length', OBJECT_ID, CHANGE].includes(key)\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    if (key === 'length') return {writable: true}\n    if (key === OBJECT_ID) return {configurable: false, enumerable: false}\n\n    const [context, objectId, path] = target\n    const object = context.getObject(objectId)\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      const index = parseListIndex(key)\n      if (index < object.length) return {configurable: true, enumerable: true}\n    }\n  },\n\n  ownKeys (target) {\n    const [context, objectId, path] = target\n    const object = context.getObject(objectId)\n    let keys = ['length']\n    for (let key of Object.keys(object)) keys.push(key)\n    return keys\n  }\n}\n\nfunction mapProxy(context, objectId, path, readonly) {\n  return new Proxy({context, objectId, path, readonly}, MapHandler)\n}\n\nfunction listProxy(context, objectId, path) {\n  return new Proxy([context, objectId, path], ListHandler)\n}\n\n/**\n * Instantiates a proxy object for the given `objectId`.\n * This function is added as a method to the context object by rootObjectProxy().\n * When it is called, `this` is the context object.\n * `readonly` is a list of map property names that cannot be modified.\n */\nfunction instantiateProxy(path, objectId, readonly) {\n  const object = this.getObject(objectId)\n  if (Array.isArray(object)) {\n    return listProxy(this, objectId, path)\n  } else if (object instanceof Text || object instanceof Table) {\n    return object.getWriteable(this, path)\n  } else {\n    return mapProxy(this, objectId, path, readonly)\n  }\n}\n\nfunction rootObjectProxy(context) {\n  context.instantiateObject = instantiateProxy\n  return mapProxy(context, ROOT_ID, [])\n}\n\nmodule.exports = { rootObjectProxy }\n","const { OBJECT_ID, CONFLICTS } = require('./constants')\nconst { isObject, copyObject } = require('../src/common')\n\nfunction compareRows(properties, row1, row2) {\n  for (let prop of properties) {\n    if (row1[prop] === row2[prop]) continue\n\n    if (typeof row1[prop] === 'number' && typeof row2[prop] === 'number') {\n      return row1[prop] - row2[prop]\n    } else {\n      const prop1 = '' + row1[prop], prop2 = '' + row2[prop]\n      if (prop1 === prop2) continue\n      if (prop1 < prop2) return -1; else return +1\n    }\n  }\n  return 0\n}\n\n\n/**\n * A relational-style unordered collection of records (rows). Each row is an\n * object that maps column names to values. The set of rows is represented by\n * a map from object ID to row object.\n */\nclass Table {\n  /**\n   * This constructor is used by application code when creating a new Table\n   * object within a change callback.\n   */\n  constructor() {\n    this.entries = Object.freeze({})\n    Object.freeze(this)\n  }\n\n  /**\n   * Looks up a row in the table by its unique ID.\n   */\n  byId(id) {\n    return this.entries[id]\n  }\n\n  /**\n   * Returns an array containing the unique IDs of all rows in the table, in no\n   * particular order.\n   */\n  get ids() {\n    return Object.keys(this.entries).filter(key => {\n      const entry = this.entries[key]\n      return isObject(entry) && entry.id === key\n    })\n  }\n\n  /**\n   * Returns the number of rows in the table.\n   */\n  get count() {\n    return this.ids.length\n  }\n\n  /**\n   * Returns an array containing all of the rows in the table, in no particular\n   * order.\n   */\n  get rows() {\n    return this.ids.map(id => this.byId(id))\n  }\n\n  /**\n   * The standard JavaScript `filter()` method, which passes each row to the\n   * callback function and returns all rows for which the it returns true.\n   */\n  filter(callback, thisArg) {\n    return this.rows.filter(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `find()` method, which passes each row to the\n   * callback function and returns the first row for which it returns true.\n   */\n  find(callback, thisArg) {\n    return this.rows.find(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `map()` method, which passes each row to the\n   * callback function and returns a list of its return values.\n   */\n  map(callback, thisArg) {\n    return this.rows.map(callback, thisArg)\n  }\n\n  /**\n  * Returns the list of rows, sorted by one of the following:\n  * - If a function argument is given, it compares rows as per\n  *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description\n  * - If a string argument is given, it is interpreted as a column name and\n  *   rows are sorted according to that column.\n  * - If an array of strings is given, it is interpreted as a list of column\n  *   names, and rows are sorted lexicographically by those columns.\n  * - If no argument is given, it sorts by row ID by default.\n  */\n  sort(arg) {\n    if (typeof arg === 'function') {\n      return this.rows.sort(arg)\n    } else if (typeof arg === 'string') {\n      return this.rows.sort((row1, row2) => compareRows([arg], row1, row2))\n    } else if (Array.isArray(arg)) {\n      return this.rows.sort((row1, row2) => compareRows(arg, row1, row2))\n    } else if (arg === undefined) {\n      return this.rows.sort((row1, row2) => compareRows(['id'], row1, row2))\n    } else {\n      throw new TypeError(`Unsupported sorting argument: ${arg}`)\n    }\n  }\n\n  /**\n   * When iterating over a table, you get all rows in the table, in no\n   * particular order.\n   */\n  [Symbol.iterator] () {\n    let rows = this.rows, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < rows.length) {\n          return {done: false, value: rows[index]}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a shallow clone of this object. This clone is used while applying\n   * a patch to the table, and `freeze()` is called on it when we have finished\n   * applying the patch.\n   */\n  _clone() {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('clone() requires the objectId to be set')\n    }\n    return instantiateTable(this[OBJECT_ID], copyObject(this.entries))\n  }\n\n  /**\n   * Sets the entry with key `id` to `value`. This method is for internal use\n   * only; it is not part of the public API of Automerge.Table.\n   */\n  _set(id, value) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    if (isObject(value) && !Array.isArray(value)) {\n      Object.defineProperty(value, 'id', {value: id, enumerable: true})\n    }\n    this.entries[id] = value\n  }\n\n  /**\n   * Removes the row with unique ID `id` from the table.\n   */\n  remove(id) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    delete this.entries[id]\n  }\n\n  /**\n   * Makes this object immutable. This is called after a change has been made.\n   */\n  _freeze() {\n    Object.freeze(this.entries)\n    Object.freeze(this)\n  }\n\n  /**\n   * Returns a writeable instance of this table. This instance is returned when\n   * the table is accessed within a change callback. `context` is the proxy\n   * context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = Object.create(WriteableTable.prototype)\n    instance[OBJECT_ID] = this[OBJECT_ID]\n    instance.context = context\n    instance.entries = this.entries\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Returns an object containing the table entries, indexed by objectID,\n   * for serializing an Automerge document to JSON.\n   */\n  toJSON() {\n    const rows = {}\n    for (let id of this.ids) rows[id] = this.byId(id)\n    return rows\n  }\n}\n\n/**\n * An instance of this class is used when a table is accessed within a change\n * callback.\n */\nclass WriteableTable extends Table {\n  /**\n   * Returns a proxied version of the row with ID `id`. This row object can be\n   * modified within a change callback.\n   */\n  byId(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      const objectId = this.entries[id][OBJECT_ID]\n      const path = this.path.concat([{key: id, objectId}])\n      return this.context.instantiateObject(path, objectId, ['id'])\n    }\n  }\n\n  /**\n   * Adds a new row to the table. The row is given as a map from\n   * column name to value. Returns the objectId of the new row.\n   */\n  add(row) {\n    return this.context.addTableRow(this.path, row)\n  }\n\n  /**\n   * Removes the row with ID `id` from the table. Throws an exception if the row\n   * does not exist in the table.\n   */\n  remove(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      this.context.deleteTableRow(this.path, id)\n    } else {\n      throw new RangeError(`There is no row with ID ${id} in this table`)\n    }\n  }\n}\n\n/**\n * This function is used to instantiate a Table object in the context of\n * applying a patch (see apply_patch.js).\n */\nfunction instantiateTable(objectId, entries) {\n  const instance = Object.create(Table.prototype)\n  if (!objectId) {\n    throw new RangeError('instantiateTable requires an objectId to be given')\n  }\n  instance[OBJECT_ID] = objectId\n  instance[CONFLICTS] = Object.freeze({})\n  instance.entries = entries || {}\n  return instance\n}\n\nmodule.exports = { Table, instantiateTable }\n","const { OBJECT_ID } = require('./constants')\n\nclass Text {\n  constructor (text) {\n    if (typeof text === 'string') {\n      const elems = text.split('').map(value => ({value}))\n      return instantiateText(undefined, elems)\n    } else if (Array.isArray(text)) {\n      const elems = text.map(value => ({value}))\n      return instantiateText(undefined, elems)\n    } else if (text === undefined) {\n      return instantiateText(undefined, [])\n    } else {\n      throw new TypeError(`Unsupported initial value for Text: ${text}`)\n    }\n  }\n\n  get length () {\n    return this.elems.length\n  }\n\n  get (index) {\n    return this.elems[index].value\n  }\n\n  /**\n   * Iterates over the text elements character by character, including any\n   * inline objects.\n   */\n  [Symbol.iterator] () {\n    let elems = this.elems, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < elems.length) {\n          return {done: false, value: elems[index].value}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, ignoring any\n   * non-character elements.\n   */\n  toString() {\n    // Concatting to a string is faster than creating an array and then\n    // .join()ing for small (<100KB) arrays.\n    // https://jsperf.com/join-vs-loop-w-type-test\n    let str = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') str += elem.value\n    }\n    return str\n  }\n\n  /**\n   * Returns the content of the Text object as a sequence of strings,\n   * interleaved with non-character elements.\n   *\n   * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:\n   * => ['ab', {x: 3}, 'cd']\n   */\n  toSpans() {\n    let spans = []\n    let chars = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') {\n        chars += elem.value\n      } else {\n        if (chars.length > 0) {\n          spans.push(chars)\n          chars = ''\n        }\n        spans.push(elem.value)\n      }\n    }\n    if (chars.length > 0) {\n      spans.push(chars)\n    }\n    return spans\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, so that the\n   * JSON serialization of an Automerge document represents text nicely.\n   */\n  toJSON() {\n    return this.toString()\n  }\n\n  /**\n   * Returns a writeable instance of this object. This instance is returned when\n   * the text object is accessed within a change callback. `context` is the\n   * proxy context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = instantiateText(this[OBJECT_ID], this.elems)\n    instance.context = context\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Updates the list item at position `index` to a new value `value`.\n   */\n  set (index, value) {\n    if (this.context) {\n      this.context.setListIndex(this.path, index, value)\n    } else if (!this[OBJECT_ID]) {\n      this.elems[index].value = value\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Inserts new list items `values` starting at position `index`.\n   */\n  insertAt(index, ...values) {\n    if (this.context) {\n      this.context.splice(this.path, index, 0, values)\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, 0, ...values.map(value => ({value})))\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Deletes `numDelete` list items starting at position `index`.\n   * if `numDelete` is not given, one item is deleted.\n   */\n  deleteAt(index, numDelete = 1) {\n    if (this.context) {\n      this.context.splice(this.path, index, numDelete, [])\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, numDelete)\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n}\n\n// Read-only methods that can delegate to the JavaScript built-in array\nfor (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                    'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                    'slice', 'some', 'toLocaleString']) {\n  Text.prototype[method] = function (...args) {\n    const array = [...this]\n    return array[method].call(array, ...args)\n  }\n}\n\nfunction instantiateText(objectId, elems) {\n  const instance = Object.create(Text.prototype)\n  instance[OBJECT_ID] = objectId\n  instance.elems = elems\n  return instance\n}\n\nmodule.exports = { Text, instantiateText }\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |\n                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^\n                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^\n                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len < dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var transit = require('transit-js');\nvar Immutable = require('immutable');\n\nfunction createReader(handlers) {\n  return transit.reader('json', {\n    mapBuilder: {\n      init: function() {\n        return {};\n      },\n      add: function(m, k, v) {\n        m[k] = v;\n        return m;\n      },\n      finalize: function(m) {\n        return m;\n      }\n    },\n    handlers: handlers\n  });\n}\n\nfunction createReaderHandlers(extras, recordMap, missingRecordHandler) {\n  var handlers = {\n    iM: function(v) {\n      var m = Immutable.Map().asMutable();\n      for (var i = 0; i < v.length; i += 2) {\n        m = m.set(v[i], v[i + 1]);\n      }\n      return m.asImmutable();\n    },\n    iOM: function(v) {\n      var m = Immutable.OrderedMap().asMutable();\n      for (var i = 0; i < v.length; i += 2) {\n        m = m.set(v[i], v[i + 1]);\n      }\n      return m.asImmutable();\n    },\n    iL: function(v) {\n      return Immutable.List(v);\n    },\n    iS: function(v) {\n      return Immutable.Set(v);\n    },\n    iOS: function(v) {\n      return Immutable.OrderedSet(v);\n    },\n    iR: function(v) {\n      var RecordType = recordMap[v.n];\n      if (!RecordType) {\n        return missingRecordHandler(v.n, v.v);\n      }\n\n      return new RecordType(v.v);\n    }\n  };\n  extras.forEach(function(extra) {\n    handlers[extra.tag] = extra.read;\n  });\n  return handlers;\n}\n\nfunction createWriter(handlers) {\n  return transit.writer('json', {\n    handlers: handlers\n  });\n}\n\nfunction createWriterHandlers(extras, recordMap, predicate) {\n  function mapSerializer(m) {\n    var i = 0;\n    if (predicate) {\n      m = m.filter(predicate);\n    }\n    var a = new Array(2 * m.size);\n    m.forEach(function(v, k) {\n      a[i++] = k;\n      a[i++] = v;\n    });\n    return a;\n  }\n\n  var handlers = transit.map([\n    Immutable.Map, transit.makeWriteHandler({\n      tag: function() {\n        return 'iM';\n      },\n      rep: mapSerializer\n    }),\n    Immutable.OrderedMap, transit.makeWriteHandler({\n      tag: function() {\n        return 'iOM';\n      },\n      rep: mapSerializer\n    }),\n    Immutable.List, transit.makeWriteHandler({\n      tag: function() {\n        return \"iL\";\n      },\n      rep: function(v) {\n        if (predicate) {\n          v = v.filter(predicate);\n        }\n        return v.toArray();\n      }\n    }),\n    Immutable.Set, transit.makeWriteHandler({\n      tag: function() {\n        return \"iS\";\n      },\n      rep: function(v) {\n        if (predicate) {\n          v = v.filter(predicate);\n        }\n        return v.toArray();\n      }\n    }),\n    Immutable.OrderedSet, transit.makeWriteHandler({\n      tag: function() {\n        return \"iOS\";\n      },\n      rep: function(v) {\n        if (predicate) {\n          v = v.filter(predicate);\n        }\n        return v.toArray();\n      }\n    }),\n    Function, transit.makeWriteHandler({\n      tag: function() {\n        return '_';\n      },\n      rep: function() {\n        return null;\n      }\n    }),\n    \"default\", transit.makeWriteHandler({\n      tag: function() {\n        return 'iM';\n      },\n      rep: function(m) {\n        if (!('toMap' in m)) {\n          var e = \"Error serializing unrecognized object \" + m.toString();\n          throw new Error(e);\n        }\n        return mapSerializer(m.toMap());\n      }\n    })\n  ]);\n\n  Object.keys(recordMap).forEach(function(name) {\n    handlers.set(recordMap[name], makeRecordHandler(name, predicate));\n  });\n\n  extras.forEach(function(extra) {\n    handlers.set(extra.class, transit.makeWriteHandler({\n      tag: function() { return extra.tag; },\n      rep: extra.write\n    }));\n  });\n\n  return handlers;\n}\n\nfunction validateExtras(extras) {\n  if (!Array.isArray(extras)) {\n    invalidExtras(extras, \"Expected array of handlers, got %j\");\n  }\n  extras.forEach(function(extra) {\n    if (typeof extra.tag !== \"string\") {\n      invalidExtras(extra,\n        \"Expected %j to have property 'tag' which is a string\");\n    }\n    if (typeof extra.class !== \"function\") {\n      invalidExtras(extra,\n        \"Expected %j to have property 'class' which is a constructor function\");\n    }\n    if (typeof extra.write !== \"function\") {\n      invalidExtras(extra,\n        \"Expected %j to have property 'write' which is a function\");\n    }\n    if (typeof extra.read !== \"function\") {\n      invalidExtras(extra,\n        \"Expected %j to have property 'write' which is a function\");\n    }\n  });\n}\nfunction invalidExtras(data, msg) {\n  var json = JSON.stringify(data);\n  throw new Error(msg.replace(\"%j\", json));\n}\n\nfunction recordName(record) {\n  /* eslint no-underscore-dangle: 0 */\n  return record._name || record.constructor.name || 'Record';\n}\n\nfunction makeRecordHandler(name) {\n  return transit.makeWriteHandler({\n    tag: function() {\n      return 'iR';\n    },\n    rep: function(m) {\n      return {\n        n: name,\n        v: m.toObject()\n      };\n    }\n  });\n}\n\nfunction buildRecordMap(recordClasses) {\n  var recordMap = {};\n\n  recordClasses.forEach(function(RecordType) {\n    var rec = new RecordType({});\n    var recName = recordName(rec);\n\n    if (!recName || recName === 'Record') {\n      throw new Error('Cannot (de)serialize Record() without a name');\n    }\n\n    if (recordMap[recName]) {\n      throw new Error('There\\'s already a constructor for a Record named ' +\n                      recName);\n    }\n    recordMap[recName] = RecordType;\n  });\n\n  return recordMap;\n}\n\nfunction defaultMissingRecordHandler(recName) {\n  var msg = 'Tried to deserialize Record type named `' + recName + '`, ' +\n            'but no type with that name was passed to withRecords()';\n  throw new Error(msg);\n}\n\nfunction createInstanceFromHandlers(handlers) {\n  var reader = createReader(handlers.read);\n  var writer = createWriter(handlers.write);\n\n  return {\n    toJSON: function toJSON(data) {\n      return writer.write(data);\n    },\n    fromJSON: function fromJSON(json) {\n      return reader.read(json);\n    },\n    withExtraHandlers: function(extra) {\n      return createInstanceFromHandlers(handlers.withExtraHandlers(extra));\n    },\n    withFilter: function(predicate) {\n      return createInstanceFromHandlers(handlers.withFilter(predicate));\n    },\n    withRecords: function(recordClasses, missingRecordHandler) {\n      return createInstanceFromHandlers(\n        handlers.withRecords(recordClasses, missingRecordHandler)\n      );\n    }\n  };\n}\n\nfunction createHandlers(options) {\n  var records = options.records || {};\n  var filter = options.filter || false;\n  var missingRecordFn = options.missingRecordHandler\n                          || defaultMissingRecordHandler;\n  var extras = options.extras || [];\n\n  return {\n    read: createReaderHandlers(extras, records, missingRecordFn),\n    write: createWriterHandlers(extras, records, filter),\n    withExtraHandlers: function(moreExtras) {\n      validateExtras(moreExtras);\n\n      return createHandlers({\n        extras: extras.concat(moreExtras),\n        records: records,\n        filter: filter,\n        missingRecordHandler: missingRecordFn\n      });\n    },\n    withFilter: function(newFilter) {\n      return createHandlers({\n        extras: extras,\n        records: records,\n        filter: newFilter,\n        missingRecordHandler: missingRecordFn\n      });\n    },\n    withRecords: function(recordClasses, missingRecordHandler) {\n      var recordMap = buildRecordMap(recordClasses);\n      return createHandlers({\n        extras: extras,\n        records: recordMap,\n        filter: filter,\n        missingRecordHandler: missingRecordHandler\n      });\n    }\n  };\n}\n\nmodule.exports = createInstanceFromHandlers(createHandlers({}));\nmodule.exports.handlers = createHandlers({});\n","// transit-js 0.8.862\n// http://transit-format.org\n// \n// Copyright 2014 Cognitect. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License..\nvar $jscomp = $jscomp || {};\n$jscomp.scope = {};\n$jscomp.checkStringArgs = function(a, b, c) {\n  if (null == a) {\n    throw new TypeError(\"The 'this' value for String.prototype.\" + c + \" must not be null or undefined\");\n  }\n  if (b instanceof RegExp) {\n    throw new TypeError(\"First argument to String.prototype.\" + c + \" must not be a regular expression\");\n  }\n  return a + \"\";\n};\n$jscomp.defineProperty = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {\n  a != Array.prototype && a != Object.prototype && (a[b] = c.value);\n};\n$jscomp.getGlobal = function(a) {\n  return \"undefined\" != typeof window && window === a ? a : \"undefined\" != typeof global && null != global ? global : a;\n};\n$jscomp.global = $jscomp.getGlobal(this);\n$jscomp.polyfill = function(a, b, c, d) {\n  if (b) {\n    c = $jscomp.global;\n    a = a.split(\".\");\n    for (d = 0; d < a.length - 1; d++) {\n      var e = a[d];\n      e in c || (c[e] = {});\n      c = c[e];\n    }\n    a = a[a.length - 1];\n    d = c[a];\n    b = b(d);\n    b != d && null != b && $jscomp.defineProperty(c, a, {configurable:!0, writable:!0, value:b});\n  }\n};\n$jscomp.polyfill(\"String.prototype.repeat\", function(a) {\n  return a ? a : function(a) {\n    var b = $jscomp.checkStringArgs(this, null, \"repeat\");\n    if (0 > a || 1342177279 < a) {\n      throw new RangeError(\"Invalid count value\");\n    }\n    a |= 0;\n    for (var d = \"\"; a;) {\n      if (a & 1 && (d += b), a >>>= 1) {\n        b += b;\n      }\n    }\n    return d;\n  };\n}, \"es6-impl\", \"es3\");\n$jscomp.SYMBOL_PREFIX = \"jscomp_symbol_\";\n$jscomp.initSymbol = function() {\n  $jscomp.initSymbol = function() {\n  };\n  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);\n};\n$jscomp.symbolCounter_ = 0;\n$jscomp.Symbol = function(a) {\n  return $jscomp.SYMBOL_PREFIX + (a || \"\") + $jscomp.symbolCounter_++;\n};\n$jscomp.initSymbolIterator = function() {\n  $jscomp.initSymbol();\n  var a = $jscomp.global.Symbol.iterator;\n  a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(\"iterator\"));\n  \"function\" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {configurable:!0, writable:!0, value:function() {\n    return $jscomp.arrayIterator(this);\n  }});\n  $jscomp.initSymbolIterator = function() {\n  };\n};\n$jscomp.arrayIterator = function(a) {\n  var b = 0;\n  return $jscomp.iteratorPrototype(function() {\n    return b < a.length ? {done:!1, value:a[b++]} : {done:!0};\n  });\n};\n$jscomp.iteratorPrototype = function(a) {\n  $jscomp.initSymbolIterator();\n  a = {next:a};\n  a[$jscomp.global.Symbol.iterator] = function() {\n    return this;\n  };\n  return a;\n};\n$jscomp.iteratorFromArray = function(a, b) {\n  $jscomp.initSymbolIterator();\n  a instanceof String && (a += \"\");\n  var c = 0, d = {next:function() {\n    if (c < a.length) {\n      var e = c++;\n      return {value:b(e, a[e]), done:!1};\n    }\n    d.next = function() {\n      return {done:!0, value:void 0};\n    };\n    return d.next();\n  }};\n  d[Symbol.iterator] = function() {\n    return d;\n  };\n  return d;\n};\n$jscomp.polyfill(\"Array.prototype.entries\", function(a) {\n  return a ? a : function() {\n    return $jscomp.iteratorFromArray(this, function(a, c) {\n      return [a, c];\n    });\n  };\n}, \"es6-impl\", \"es3\");\n$jscomp.polyfill(\"Array.prototype.keys\", function(a) {\n  return a ? a : function() {\n    return $jscomp.iteratorFromArray(this, function(a) {\n      return a;\n    });\n  };\n}, \"es6-impl\", \"es3\");\n$jscomp.polyfill(\"Array.prototype.values\", function(a) {\n  return a ? a : function() {\n    return $jscomp.iteratorFromArray(this, function(a, c) {\n      return c;\n    });\n  };\n}, \"es6\", \"es3\");\nvar COMPILED = !0, goog = goog || {};\ngoog.global = this;\ngoog.isDef = function(a) {\n  return void 0 !== a;\n};\ngoog.exportPath_ = function(a, b, c) {\n  a = a.split(\".\");\n  c = c || goog.global;\n  a[0] in c || !c.execScript || c.execScript(\"var \" + a[0]);\n  for (var d; a.length && (d = a.shift());) {\n    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] && c[d] !== Object.prototype[d] ? c[d] : c[d] = {};\n  }\n};\ngoog.define = function(a, b) {\n  var c = b;\n  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));\n  goog.exportPath_(a, c);\n};\ngoog.DEBUG = !0;\ngoog.LOCALE = \"en\";\ngoog.TRUSTED_SITE = !0;\ngoog.STRICT_MODE_COMPATIBLE = !1;\ngoog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;\ngoog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;\ngoog.provide = function(a) {\n  if (goog.isInModuleLoader_()) {\n    throw Error(\"goog.provide can not be used within a goog.module.\");\n  }\n  if (!COMPILED && goog.isProvided_(a)) {\n    throw Error('Namespace \"' + a + '\" already declared.');\n  }\n  goog.constructNamespace_(a);\n};\ngoog.constructNamespace_ = function(a, b) {\n  if (!COMPILED) {\n    delete goog.implicitNamespaces_[a];\n    for (var c = a; (c = c.substring(0, c.lastIndexOf(\".\"))) && !goog.getObjectByName(c);) {\n      goog.implicitNamespaces_[c] = !0;\n    }\n  }\n  goog.exportPath_(a, b);\n};\ngoog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;\ngoog.module = function(a) {\n  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {\n    throw Error(\"Invalid module identifier\");\n  }\n  if (!goog.isInModuleLoader_()) {\n    throw Error(\"Module \" + a + \" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.\");\n  }\n  if (goog.moduleLoaderState_.moduleName) {\n    throw Error(\"goog.module may only be called once per module.\");\n  }\n  goog.moduleLoaderState_.moduleName = a;\n  if (!COMPILED) {\n    if (goog.isProvided_(a)) {\n      throw Error('Namespace \"' + a + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[a];\n  }\n};\ngoog.module.get = function(a) {\n  return goog.module.getInternal_(a);\n};\ngoog.module.getInternal_ = function(a) {\n  if (!COMPILED) {\n    if (a in goog.loadedModules_) {\n      return goog.loadedModules_[a];\n    }\n    if (!goog.implicitNamespaces_[a]) {\n      return a = goog.getObjectByName(a), null != a ? a : null;\n    }\n  }\n  return null;\n};\ngoog.moduleLoaderState_ = null;\ngoog.isInModuleLoader_ = function() {\n  return null != goog.moduleLoaderState_;\n};\ngoog.module.declareLegacyNamespace = function() {\n  if (!COMPILED && !goog.isInModuleLoader_()) {\n    throw Error(\"goog.module.declareLegacyNamespace must be called from within a goog.module\");\n  }\n  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {\n    throw Error(\"goog.module must be called prior to goog.module.declareLegacyNamespace.\");\n  }\n  goog.moduleLoaderState_.declareLegacyNamespace = !0;\n};\ngoog.setTestOnly = function(a) {\n  if (goog.DISALLOW_TEST_ONLY_CODE) {\n    throw a = a || \"\", Error(\"Importing test-only code into non-debug environment\" + (a ? \": \" + a : \".\"));\n  }\n};\ngoog.forwardDeclare = function(a) {\n};\nCOMPILED || (goog.isProvided_ = function(a) {\n  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));\n}, goog.implicitNamespaces_ = {\"goog.module\":!0});\ngoog.getObjectByName = function(a, b) {\n  for (var c = a.split(\".\"), d = b || goog.global, e; e = c.shift();) {\n    if (goog.isDefAndNotNull(d[e])) {\n      d = d[e];\n    } else {\n      return null;\n    }\n  }\n  return d;\n};\ngoog.globalize = function(a, b) {\n  var c = b || goog.global, d;\n  for (d in a) {\n    c[d] = a[d];\n  }\n};\ngoog.addDependency = function(a, b, c, d) {\n  if (goog.DEPENDENCIES_ENABLED) {\n    var e;\n    a = a.replace(/\\\\/g, \"/\");\n    var f = goog.dependencies_;\n    d && \"boolean\" !== typeof d || (d = d ? {module:\"goog\"} : {});\n    for (var g = 0; e = b[g]; g++) {\n      f.nameToPath[e] = a, f.loadFlags[a] = d;\n    }\n    for (d = 0; b = c[d]; d++) {\n      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;\n    }\n  }\n};\ngoog.ENABLE_DEBUG_LOADER = !0;\ngoog.logToConsole_ = function(a) {\n  goog.global.console && goog.global.console.error(a);\n};\ngoog.require = function(a) {\n  if (!COMPILED) {\n    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);\n    if (goog.isProvided_(a)) {\n      if (goog.isInModuleLoader_()) {\n        return goog.module.getInternal_(a);\n      }\n    } else {\n      if (goog.ENABLE_DEBUG_LOADER) {\n        var b = goog.getPathFromDeps_(a);\n        if (b) {\n          goog.writeScripts_(b);\n        } else {\n          throw a = \"goog.require could not find: \" + a, goog.logToConsole_(a), Error(a);\n        }\n      }\n    }\n    return null;\n  }\n};\ngoog.basePath = \"\";\ngoog.nullFunction = function() {\n};\ngoog.abstractMethod = function() {\n  throw Error(\"unimplemented abstract method\");\n};\ngoog.addSingletonGetter = function(a) {\n  a.instance_ = void 0;\n  a.getInstance = function() {\n    if (a.instance_) {\n      return a.instance_;\n    }\n    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);\n    return a.instance_ = new a;\n  };\n};\ngoog.instantiatedSingletons_ = [];\ngoog.LOAD_MODULE_USING_EVAL = !0;\ngoog.SEAL_MODULE_EXPORTS = goog.DEBUG;\ngoog.loadedModules_ = {};\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\ngoog.TRANSPILE = \"detect\";\ngoog.TRANSPILER = \"transpile.js\";\ngoog.DEPENDENCIES_ENABLED && (goog.dependencies_ = {loadFlags:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {\n  var a = goog.global.document;\n  return null != a && \"write\" in a;\n}, goog.findBasePath_ = function() {\n  if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {\n    goog.basePath = goog.global.CLOSURE_BASE_PATH;\n  } else {\n    if (goog.inHtmlDocument_()) {\n      for (var a = goog.global.document.getElementsByTagName(\"SCRIPT\"), b = a.length - 1; 0 <= b; --b) {\n        var c = a[b].src, d = c.lastIndexOf(\"?\"), d = -1 == d ? c.length : d;\n        if (\"base.js\" == c.substr(d - 7, 7)) {\n          goog.basePath = c.substr(0, d - 7);\n          break;\n        }\n      }\n    }\n  }\n}, goog.importScript_ = function(a, b) {\n  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);\n}, goog.IS_OLD_IE_ = !(goog.global.atob || !goog.global.document || !goog.global.document.all), goog.oldIeWaiting_ = !1, goog.importProcessedScript_ = function(a, b, c) {\n  goog.importScript_(\"\", 'goog.retrieveAndExec_(\"' + a + '\", ' + b + \", \" + c + \");\");\n}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {\n  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? \"goog.loadModule(\" + goog.global.JSON.stringify(b + \"\\n//# sourceURL=\" + a + \"\\n\") + \");\" : 'goog.loadModule(function(exports) {\"use strict\";' + b + \"\\n;return exports});\\n//# sourceURL=\" + a + \"\\n\";\n}, goog.loadQueuedModules_ = function() {\n  var a = goog.queuedModules_.length;\n  if (0 < a) {\n    var b = goog.queuedModules_;\n    goog.queuedModules_ = [];\n    for (var c = 0; c < a; c++) {\n      goog.maybeProcessDeferredPath_(b[c]);\n    }\n  }\n  goog.oldIeWaiting_ = !1;\n}, goog.maybeProcessDeferredDep_ = function(a) {\n  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));\n}, goog.isDeferredModule_ = function(a) {\n  var b = (a = goog.getPathFromDeps_(a)) && goog.dependencies_.loadFlags[a] || {}, c = b.lang || \"es3\";\n  return a && (\"goog\" == b.module || goog.needsTranspile_(c)) ? goog.basePath + a in goog.dependencies_.deferred : !1;\n}, goog.allDepsAreAvailable_ = function(a) {\n  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {\n    for (var b in goog.dependencies_.requires[a]) {\n      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {\n        return !1;\n      }\n    }\n  }\n  return !0;\n}, goog.maybeProcessDeferredPath_ = function(a) {\n  if (a in goog.dependencies_.deferred) {\n    var b = goog.dependencies_.deferred[a];\n    delete goog.dependencies_.deferred[a];\n    goog.globalEval(b);\n  }\n}, goog.loadModuleFromUrl = function(a) {\n  goog.retrieveAndExec_(a, !0, !1);\n}, goog.writeScriptSrcNode_ = function(a) {\n  goog.global.document.write('<script type=\"text/javascript\" src=\"' + a + '\">\\x3c/script>');\n}, goog.appendScriptSrcNode_ = function(a) {\n  var b = goog.global.document, c = b.createElement(\"script\");\n  c.type = \"text/javascript\";\n  c.src = a;\n  c.defer = !1;\n  c.async = !1;\n  b.head.appendChild(c);\n}, goog.writeScriptTag_ = function(a, b) {\n  if (goog.inHtmlDocument_()) {\n    var c = goog.global.document;\n    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && \"complete\" == c.readyState) {\n      if (/\\bdeps.js$/.test(a)) {\n        return !1;\n      }\n      throw Error('Cannot write \"' + a + '\" after document load');\n    }\n    if (void 0 === b) {\n      if (goog.IS_OLD_IE_) {\n        goog.oldIeWaiting_ = !0;\n        var d = \" onreadystatechange='goog.onScriptLoad_(this, \" + ++goog.lastNonModuleScriptIndex_ + \")' \";\n        c.write('<script type=\"text/javascript\" src=\"' + a + '\"' + d + \">\\x3c/script>\");\n      } else {\n        goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a);\n      }\n    } else {\n      c.write('<script type=\"text/javascript\">' + goog.protectScriptTag_(b) + \"\\x3c/script>\");\n    }\n    return !0;\n  }\n  return !1;\n}, goog.protectScriptTag_ = function(a) {\n  return a.replace(/<\\/(SCRIPT)/ig, \"\\\\x3c/$1\");\n}, goog.needsTranspile_ = function(a) {\n  if (\"always\" == goog.TRANSPILE) {\n    return !0;\n  }\n  if (\"never\" == goog.TRANSPILE) {\n    return !1;\n  }\n  goog.requiresTranspilation_ || (goog.requiresTranspilation_ = goog.createRequiresTranspilation_());\n  if (a in goog.requiresTranspilation_) {\n    return goog.requiresTranspilation_[a];\n  }\n  throw Error(\"Unknown language mode: \" + a);\n}, goog.requiresTranspilation_ = null, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {\n  \"complete\" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();\n  return !0;\n}, goog.writeScripts_ = function(a) {\n  function b(a) {\n    if (!(a in e.written || a in e.visited)) {\n      e.visited[a] = !0;\n      if (a in e.requires) {\n        for (var f in e.requires[a]) {\n          if (!goog.isProvided_(f)) {\n            if (f in e.nameToPath) {\n              b(e.nameToPath[f]);\n            } else {\n              throw Error(\"Undefined nameToPath for \" + f);\n            }\n          }\n        }\n      }\n      a in d || (d[a] = !0, c.push(a));\n    }\n  }\n  var c = [], d = {}, e = goog.dependencies_;\n  b(a);\n  for (var f = 0; f < c.length; f++) {\n    a = c[f], goog.dependencies_.written[a] = !0;\n  }\n  var g = goog.moduleLoaderState_;\n  goog.moduleLoaderState_ = null;\n  for (f = 0; f < c.length; f++) {\n    if (a = c[f]) {\n      var h = e.loadFlags[a] || {}, k = goog.needsTranspile_(h.lang || \"es3\");\n      \"goog\" == h.module || k ? goog.importProcessedScript_(goog.basePath + a, \"goog\" == h.module, k) : goog.importScript_(goog.basePath + a);\n    } else {\n      throw goog.moduleLoaderState_ = g, Error(\"Undefined script input\");\n    }\n  }\n  goog.moduleLoaderState_ = g;\n}, goog.getPathFromDeps_ = function(a) {\n  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;\n}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + \"deps.js\"));\ngoog.hasBadLetScoping = null;\ngoog.useSafari10Workaround = function() {\n  if (null == goog.hasBadLetScoping) {\n    try {\n      var a = !eval('\"use strict\";let x = 1; function f() { return typeof x; };f() == \"number\";');\n    } catch (b) {\n      a = !1;\n    }\n    goog.hasBadLetScoping = a;\n  }\n  return goog.hasBadLetScoping;\n};\ngoog.workaroundSafari10EvalBug = function(a) {\n  return \"(function(){\" + a + \"\\n;})();\\n\";\n};\ngoog.loadModule = function(a) {\n  var b = goog.moduleLoaderState_;\n  try {\n    goog.moduleLoaderState_ = {moduleName:void 0, declareLegacyNamespace:!1};\n    if (goog.isFunction(a)) {\n      var c = a.call(void 0, {});\n    } else {\n      if (goog.isString(a)) {\n        goog.useSafari10Workaround() && (a = goog.workaroundSafari10EvalBug(a)), c = goog.loadModuleFromSource_.call(void 0, a);\n      } else {\n        throw Error(\"Invalid module definition\");\n      }\n    }\n    var d = goog.moduleLoaderState_.moduleName;\n    if (!goog.isString(d) || !d) {\n      throw Error('Invalid module name \"' + d + '\"');\n    }\n    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && \"object\" == typeof c && null != c && Object.seal(c);\n    goog.loadedModules_[d] = c;\n  } finally {\n    goog.moduleLoaderState_ = b;\n  }\n};\ngoog.loadModuleFromSource_ = function(a) {\n  eval(a);\n  return {};\n};\ngoog.normalizePath_ = function(a) {\n  a = a.split(\"/\");\n  for (var b = 0; b < a.length;) {\n    \".\" == a[b] ? a.splice(b, 1) : b && \"..\" == a[b] && a[b - 1] && \"..\" != a[b - 1] ? a.splice(--b, 2) : b++;\n  }\n  return a.join(\"/\");\n};\ngoog.loadFileSync_ = function(a) {\n  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {\n    return goog.global.CLOSURE_LOAD_FILE_SYNC(a);\n  }\n  try {\n    var b = new goog.global.XMLHttpRequest;\n    b.open(\"get\", a, !1);\n    b.send();\n    return 0 == b.status || 200 == b.status ? b.responseText : null;\n  } catch (c) {\n    return null;\n  }\n};\ngoog.retrieveAndExec_ = function(a, b, c) {\n  if (!COMPILED) {\n    var d = a;\n    a = goog.normalizePath_(a);\n    var e = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, f = goog.loadFileSync_(a);\n    if (null == f) {\n      throw Error('Load of \"' + a + '\" failed');\n    }\n    c && (f = goog.transpile_.call(goog.global, f, a));\n    f = b ? goog.wrapModule_(a, f) : f + (\"\\n//# sourceURL=\" + a);\n    goog.IS_OLD_IE_ && goog.oldIeWaiting_ ? (goog.dependencies_.deferred[d] = f, goog.queuedModules_.push(d)) : e(a, f);\n  }\n};\ngoog.transpile_ = function(a, b) {\n  var c = goog.global.$jscomp;\n  c || (goog.global.$jscomp = c = {});\n  var d = c.transpile;\n  if (!d) {\n    var e = goog.basePath + goog.TRANSPILER, f = goog.loadFileSync_(e);\n    if (f) {\n      eval(f + \"\\n//# sourceURL=\" + e);\n      if (goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile) {\n        throw Error('The transpiler did not properly export the \"transpile\" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));\n      }\n      goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile;\n      c = goog.global.$jscomp;\n      d = c.transpile;\n    }\n  }\n  d || (d = c.transpile = function(a, b) {\n    goog.logToConsole_(b + \" requires transpilation but no transpiler was found.\");\n    return a;\n  });\n  return d(a, b);\n};\ngoog.typeOf = function(a) {\n  var b = typeof a;\n  if (\"object\" == b) {\n    if (a) {\n      if (a instanceof Array) {\n        return \"array\";\n      }\n      if (a instanceof Object) {\n        return b;\n      }\n      var c = Object.prototype.toString.call(a);\n      if (\"[object Window]\" == c) {\n        return \"object\";\n      }\n      if (\"[object Array]\" == c || \"number\" == typeof a.length && \"undefined\" != typeof a.splice && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"splice\")) {\n        return \"array\";\n      }\n      if (\"[object Function]\" == c || \"undefined\" != typeof a.call && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"call\")) {\n        return \"function\";\n      }\n    } else {\n      return \"null\";\n    }\n  } else {\n    if (\"function\" == b && \"undefined\" == typeof a.call) {\n      return \"object\";\n    }\n  }\n  return b;\n};\ngoog.isNull = function(a) {\n  return null === a;\n};\ngoog.isDefAndNotNull = function(a) {\n  return null != a;\n};\ngoog.isArray = function(a) {\n  return \"array\" == goog.typeOf(a);\n};\ngoog.isArrayLike = function(a) {\n  var b = goog.typeOf(a);\n  return \"array\" == b || \"object\" == b && \"number\" == typeof a.length;\n};\ngoog.isDateLike = function(a) {\n  return goog.isObject(a) && \"function\" == typeof a.getFullYear;\n};\ngoog.isString = function(a) {\n  return \"string\" == typeof a;\n};\ngoog.isBoolean = function(a) {\n  return \"boolean\" == typeof a;\n};\ngoog.isNumber = function(a) {\n  return \"number\" == typeof a;\n};\ngoog.isFunction = function(a) {\n  return \"function\" == goog.typeOf(a);\n};\ngoog.isObject = function(a) {\n  var b = typeof a;\n  return \"object\" == b && null != a || \"function\" == b;\n};\ngoog.getUid = function(a) {\n  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n};\ngoog.hasUid = function(a) {\n  return !!a[goog.UID_PROPERTY_];\n};\ngoog.removeUid = function(a) {\n  null !== a && \"removeAttribute\" in a && a.removeAttribute(goog.UID_PROPERTY_);\n  try {\n    delete a[goog.UID_PROPERTY_];\n  } catch (b) {\n  }\n};\ngoog.UID_PROPERTY_ = \"closure_uid_\" + (1e9 * Math.random() >>> 0);\ngoog.uidCounter_ = 0;\ngoog.getHashCode = goog.getUid;\ngoog.removeHashCode = goog.removeUid;\ngoog.cloneObject = function(a) {\n  var b = goog.typeOf(a);\n  if (\"object\" == b || \"array\" == b) {\n    if (a.clone) {\n      return a.clone();\n    }\n    var b = \"array\" == b ? [] : {}, c;\n    for (c in a) {\n      b[c] = goog.cloneObject(a[c]);\n    }\n    return b;\n  }\n  return a;\n};\ngoog.bindNative_ = function(a, b, c) {\n  return a.call.apply(a.bind, arguments);\n};\ngoog.bindJs_ = function(a, b, c) {\n  if (!a) {\n    throw Error();\n  }\n  if (2 < arguments.length) {\n    var d = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      var c = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(c, d);\n      return a.apply(b, c);\n    };\n  }\n  return function() {\n    return a.apply(b, arguments);\n  };\n};\ngoog.bind = function(a, b, c) {\n  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;\n  return goog.bind.apply(null, arguments);\n};\ngoog.partial = function(a, b) {\n  var c = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    var b = c.slice();\n    b.push.apply(b, arguments);\n    return a.apply(this, b);\n  };\n};\ngoog.mixin = function(a, b) {\n  for (var c in b) {\n    a[c] = b[c];\n  }\n};\ngoog.now = goog.TRUSTED_SITE && Date.now || function() {\n  return +new Date;\n};\ngoog.globalEval = function(a) {\n  if (goog.global.execScript) {\n    goog.global.execScript(a, \"JavaScript\");\n  } else {\n    if (goog.global.eval) {\n      if (null == goog.evalWorksForGlobals_) {\n        if (goog.global.eval(\"var _evalTest_ = 1;\"), \"undefined\" != typeof goog.global._evalTest_) {\n          try {\n            delete goog.global._evalTest_;\n          } catch (d) {\n          }\n          goog.evalWorksForGlobals_ = !0;\n        } else {\n          goog.evalWorksForGlobals_ = !1;\n        }\n      }\n      if (goog.evalWorksForGlobals_) {\n        goog.global.eval(a);\n      } else {\n        var b = goog.global.document, c = b.createElement(\"SCRIPT\");\n        c.type = \"text/javascript\";\n        c.defer = !1;\n        c.appendChild(b.createTextNode(a));\n        b.body.appendChild(c);\n        b.body.removeChild(c);\n      }\n    } else {\n      throw Error(\"goog.globalEval not available\");\n    }\n  }\n};\ngoog.evalWorksForGlobals_ = null;\ngoog.getCssName = function(a, b) {\n  if (\".\" == String(a).charAt(0)) {\n    throw Error('className passed in goog.getCssName must not start with \".\". You passed: ' + a);\n  }\n  var c = function(a) {\n    return goog.cssNameMapping_[a] || a;\n  }, d = function(a) {\n    a = a.split(\"-\");\n    for (var b = [], d = 0; d < a.length; d++) {\n      b.push(c(a[d]));\n    }\n    return b.join(\"-\");\n  }, d = goog.cssNameMapping_ ? \"BY_WHOLE\" == goog.cssNameMappingStyle_ ? c : d : function(a) {\n    return a;\n  }, d = b ? a + \"-\" + d(b) : d(a);\n  return goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(d) : d;\n};\ngoog.setCssNameMapping = function(a, b) {\n  goog.cssNameMapping_ = a;\n  goog.cssNameMappingStyle_ = b;\n};\n!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);\ngoog.getMsg = function(a, b) {\n  b && (a = a.replace(/\\{\\$([^}]+)}/g, function(a, d) {\n    return null != b && d in b ? b[d] : a;\n  }));\n  return a;\n};\ngoog.getMsgWithFallback = function(a, b) {\n  return a;\n};\ngoog.exportSymbol = function(a, b, c) {\n  goog.exportPath_(a, b, c);\n};\ngoog.exportProperty = function(a, b, c) {\n  a[b] = c;\n};\ngoog.inherits = function(a, b) {\n  function c() {\n  }\n  c.prototype = b.prototype;\n  a.superClass_ = b.prototype;\n  a.prototype = new c;\n  a.prototype.constructor = a;\n  a.base = function(a, c, f) {\n    for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++) {\n      d[e - 2] = arguments[e];\n    }\n    return b.prototype[c].apply(a, d);\n  };\n};\ngoog.base = function(a, b, c) {\n  var d = arguments.callee.caller;\n  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {\n    throw Error(\"arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C\");\n  }\n  if (d.superClass_) {\n    for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++) {\n      e[f - 1] = arguments[f];\n    }\n    return d.superClass_.constructor.apply(a, e);\n  }\n  e = Array(arguments.length - 2);\n  for (f = 2; f < arguments.length; f++) {\n    e[f - 2] = arguments[f];\n  }\n  for (var f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor) {\n    if (g.prototype[b] === d) {\n      f = !0;\n    } else {\n      if (f) {\n        return g.prototype[b].apply(a, e);\n      }\n    }\n  }\n  if (a[b] === d) {\n    return a.constructor.prototype[b].apply(a, e);\n  }\n  throw Error(\"goog.base called from a method of one name to a method of a different name\");\n};\ngoog.scope = function(a) {\n  if (goog.isInModuleLoader_()) {\n    throw Error(\"goog.scope is not supported within a goog.module.\");\n  }\n  a.call(goog.global);\n};\nCOMPILED || (goog.global.COMPILED = COMPILED);\ngoog.defineClass = function(a, b) {\n  var c = b.constructor, d = b.statics;\n  c && c != Object.prototype.constructor || (c = function() {\n    throw Error(\"cannot instantiate an interface (no constructor defined).\");\n  });\n  c = goog.defineClass.createSealingConstructor_(c, a);\n  a && goog.inherits(c, a);\n  delete b.constructor;\n  delete b.statics;\n  goog.defineClass.applyProperties_(c.prototype, b);\n  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));\n  return c;\n};\ngoog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;\ngoog.defineClass.createSealingConstructor_ = function(a, b) {\n  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {\n    return a;\n  }\n  var c = !goog.defineClass.isUnsealable_(b), d = function() {\n    var b = a.apply(this, arguments) || this;\n    b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];\n    this.constructor === d && c && Object.seal instanceof Function && Object.seal(b);\n    return b;\n  };\n  return d;\n};\ngoog.defineClass.isUnsealable_ = function(a) {\n  return a && a.prototype && a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];\n};\ngoog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\ngoog.defineClass.applyProperties_ = function(a, b) {\n  for (var c in b) {\n    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);\n  }\n  for (var d = 0; d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d++) {\n    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);\n  }\n};\ngoog.tagUnsealableClass = function(a) {\n  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);\n};\ngoog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = \"goog_defineClass_legacy_unsealable\";\ngoog.createRequiresTranspilation_ = function() {\n  function a(a, b) {\n    d ? c[a] = !0 : b() ? c[a] = !1 : d = c[a] = !0;\n  }\n  function b(a) {\n    try {\n      return !!eval(a);\n    } catch (g) {\n      return !1;\n    }\n  }\n  var c = {es3:!1}, d = !1, e = goog.global.navigator && goog.global.navigator.userAgent ? goog.global.navigator.userAgent : \"\";\n  a(\"es5\", function() {\n    return b(\"[1,].length==1\");\n  });\n  a(\"es6\", function() {\n    var a = e.match(/Edge\\/(\\d+)(\\.\\d)*/i);\n    return a && 15 > Number(a[1]) ? !1 : b('(()=>{\"use strict\";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()');\n  });\n  a(\"es6-impl\", function() {\n    return !0;\n  });\n  a(\"es7\", function() {\n    return b(\"2 ** 2 == 4\");\n  });\n  a(\"es8\", function() {\n    return b(\"async () => 1, true\");\n  });\n  return c;\n};\ngoog.debug = {};\ngoog.debug.Error = function(a) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, goog.debug.Error);\n  } else {\n    var b = Error().stack;\n    b && (this.stack = b);\n  }\n  a && (this.message = String(a));\n  this.reportErrorToServer = !0;\n};\ngoog.inherits(goog.debug.Error, Error);\ngoog.debug.Error.prototype.name = \"CustomError\";\ngoog.dom = {};\ngoog.dom.NodeType = {ELEMENT:1, ATTRIBUTE:2, TEXT:3, CDATA_SECTION:4, ENTITY_REFERENCE:5, ENTITY:6, PROCESSING_INSTRUCTION:7, COMMENT:8, DOCUMENT:9, DOCUMENT_TYPE:10, DOCUMENT_FRAGMENT:11, NOTATION:12};\ngoog.string = {};\ngoog.string.DETECT_DOUBLE_ESCAPING = !1;\ngoog.string.FORCE_NON_DOM_HTML_UNESCAPING = !1;\ngoog.string.Unicode = {NBSP:\"\\u00a0\"};\ngoog.string.startsWith = function(a, b) {\n  return 0 == a.lastIndexOf(b, 0);\n};\ngoog.string.endsWith = function(a, b) {\n  var c = a.length - b.length;\n  return 0 <= c && a.indexOf(b, c) == c;\n};\ngoog.string.caseInsensitiveStartsWith = function(a, b) {\n  return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length));\n};\ngoog.string.caseInsensitiveEndsWith = function(a, b) {\n  return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length));\n};\ngoog.string.caseInsensitiveEquals = function(a, b) {\n  return a.toLowerCase() == b.toLowerCase();\n};\ngoog.string.subs = function(a, b) {\n  for (var c = a.split(\"%s\"), d = \"\", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;) {\n    d += c.shift() + e.shift();\n  }\n  return d + c.join(\"%s\");\n};\ngoog.string.collapseWhitespace = function(a) {\n  return a.replace(/[\\s\\xa0]+/g, \" \").replace(/^\\s+|\\s+$/g, \"\");\n};\ngoog.string.isEmptyOrWhitespace = function(a) {\n  return /^[\\s\\xa0]*$/.test(a);\n};\ngoog.string.isEmptyString = function(a) {\n  return 0 == a.length;\n};\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\ngoog.string.isEmptyOrWhitespaceSafe = function(a) {\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a));\n};\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\ngoog.string.isBreakingWhitespace = function(a) {\n  return !/[^\\t\\n\\r ]/.test(a);\n};\ngoog.string.isAlpha = function(a) {\n  return !/[^a-zA-Z]/.test(a);\n};\ngoog.string.isNumeric = function(a) {\n  return !/[^0-9]/.test(a);\n};\ngoog.string.isAlphaNumeric = function(a) {\n  return !/[^a-zA-Z0-9]/.test(a);\n};\ngoog.string.isSpace = function(a) {\n  return \" \" == a;\n};\ngoog.string.isUnicodeChar = function(a) {\n  return 1 == a.length && \" \" <= a && \"~\" >= a || \"\\u0080\" <= a && \"\\ufffd\" >= a;\n};\ngoog.string.stripNewlines = function(a) {\n  return a.replace(/(\\r\\n|\\r|\\n)+/g, \" \");\n};\ngoog.string.canonicalizeNewlines = function(a) {\n  return a.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\");\n};\ngoog.string.normalizeWhitespace = function(a) {\n  return a.replace(/\\xa0|\\s/g, \" \");\n};\ngoog.string.normalizeSpaces = function(a) {\n  return a.replace(/\\xa0|[ \\t]+/g, \" \");\n};\ngoog.string.collapseBreakingSpaces = function(a) {\n  return a.replace(/[\\t\\r\\n ]+/g, \" \").replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, \"\");\n};\ngoog.string.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(a) {\n  return a.trim();\n} : function(a) {\n  return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\");\n};\ngoog.string.trimLeft = function(a) {\n  return a.replace(/^[\\s\\xa0]+/, \"\");\n};\ngoog.string.trimRight = function(a) {\n  return a.replace(/[\\s\\xa0]+$/, \"\");\n};\ngoog.string.caseInsensitiveCompare = function(a, b) {\n  var c = String(a).toLowerCase(), d = String(b).toLowerCase();\n  return c < d ? -1 : c == d ? 0 : 1;\n};\ngoog.string.numberAwareCompare_ = function(a, b, c) {\n  if (a == b) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  for (var d = a.toLowerCase().match(c), e = b.toLowerCase().match(c), f = Math.min(d.length, e.length), g = 0; g < f; g++) {\n    c = d[g];\n    var h = e[g];\n    if (c != h) {\n      return a = parseInt(c, 10), !isNaN(a) && (b = parseInt(h, 10), !isNaN(b) && a - b) ? a - b : c < h ? -1 : 1;\n    }\n  }\n  return d.length != e.length ? d.length - e.length : a < b ? -1 : 1;\n};\ngoog.string.intAwareCompare = function(a, b) {\n  return goog.string.numberAwareCompare_(a, b, /\\d+|\\D+/g);\n};\ngoog.string.floatAwareCompare = function(a, b) {\n  return goog.string.numberAwareCompare_(a, b, /\\d+|\\.\\d+|\\D+/g);\n};\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\ngoog.string.urlEncode = function(a) {\n  return encodeURIComponent(String(a));\n};\ngoog.string.urlDecode = function(a) {\n  return decodeURIComponent(a.replace(/\\+/g, \" \"));\n};\ngoog.string.newLineToBr = function(a, b) {\n  return a.replace(/(\\r\\n|\\r|\\n)/g, b ? \"<br />\" : \"<br>\");\n};\ngoog.string.htmlEscape = function(a, b) {\n  if (b) {\n    a = a.replace(goog.string.AMP_RE_, \"&amp;\").replace(goog.string.LT_RE_, \"&lt;\").replace(goog.string.GT_RE_, \"&gt;\").replace(goog.string.QUOT_RE_, \"&quot;\").replace(goog.string.SINGLE_QUOTE_RE_, \"&#39;\").replace(goog.string.NULL_RE_, \"&#0;\"), goog.string.DETECT_DOUBLE_ESCAPING && (a = a.replace(goog.string.E_RE_, \"&#101;\"));\n  } else {\n    if (!goog.string.ALL_RE_.test(a)) {\n      return a;\n    }\n    -1 != a.indexOf(\"&\") && (a = a.replace(goog.string.AMP_RE_, \"&amp;\"));\n    -1 != a.indexOf(\"<\") && (a = a.replace(goog.string.LT_RE_, \"&lt;\"));\n    -1 != a.indexOf(\">\") && (a = a.replace(goog.string.GT_RE_, \"&gt;\"));\n    -1 != a.indexOf('\"') && (a = a.replace(goog.string.QUOT_RE_, \"&quot;\"));\n    -1 != a.indexOf(\"'\") && (a = a.replace(goog.string.SINGLE_QUOTE_RE_, \"&#39;\"));\n    -1 != a.indexOf(\"\\x00\") && (a = a.replace(goog.string.NULL_RE_, \"&#0;\"));\n    goog.string.DETECT_DOUBLE_ESCAPING && -1 != a.indexOf(\"e\") && (a = a.replace(goog.string.E_RE_, \"&#101;\"));\n  }\n  return a;\n};\ngoog.string.AMP_RE_ = /&/g;\ngoog.string.LT_RE_ = /</g;\ngoog.string.GT_RE_ = />/g;\ngoog.string.QUOT_RE_ = /\"/g;\ngoog.string.SINGLE_QUOTE_RE_ = /'/g;\ngoog.string.NULL_RE_ = /\\x00/g;\ngoog.string.E_RE_ = /e/g;\ngoog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\\x00&<>\"'e]/ : /[\\x00&<>\"']/;\ngoog.string.unescapeEntities = function(a) {\n  return goog.string.contains(a, \"&\") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && \"document\" in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a;\n};\ngoog.string.unescapeEntitiesWithDocument = function(a, b) {\n  return goog.string.contains(a, \"&\") ? goog.string.unescapeEntitiesUsingDom_(a, b) : a;\n};\ngoog.string.unescapeEntitiesUsingDom_ = function(a, b) {\n  var c = {\"&amp;\":\"&\", \"&lt;\":\"<\", \"&gt;\":\">\", \"&quot;\":'\"'};\n  var d = b ? b.createElement(\"div\") : goog.global.document.createElement(\"div\");\n  return a.replace(goog.string.HTML_ENTITY_PATTERN_, function(a, b) {\n    var e = c[a];\n    if (e) {\n      return e;\n    }\n    if (\"#\" == b.charAt(0)) {\n      var f = Number(\"0\" + b.substr(1));\n      isNaN(f) || (e = String.fromCharCode(f));\n    }\n    e || (d.innerHTML = a + \" \", e = d.firstChild.nodeValue.slice(0, -1));\n    return c[a] = e;\n  });\n};\ngoog.string.unescapePureXmlEntities_ = function(a) {\n  return a.replace(/&([^;]+);/g, function(a, c) {\n    switch(c) {\n      case \"amp\":\n        return \"&\";\n      case \"lt\":\n        return \"<\";\n      case \"gt\":\n        return \">\";\n      case \"quot\":\n        return '\"';\n      default:\n        if (\"#\" == c.charAt(0)) {\n          var b = Number(\"0\" + c.substr(1));\n          if (!isNaN(b)) {\n            return String.fromCharCode(b);\n          }\n        }\n        return a;\n    }\n  });\n};\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\ngoog.string.whitespaceEscape = function(a, b) {\n  return goog.string.newLineToBr(a.replace(/  /g, \" &#160;\"), b);\n};\ngoog.string.preserveSpaces = function(a) {\n  return a.replace(/(^|[\\n ]) /g, \"$1\" + goog.string.Unicode.NBSP);\n};\ngoog.string.stripQuotes = function(a, b) {\n  for (var c = b.length, d = 0; d < c; d++) {\n    var e = 1 == c ? b : b.charAt(d);\n    if (a.charAt(0) == e && a.charAt(a.length - 1) == e) {\n      return a.substring(1, a.length - 1);\n    }\n  }\n  return a;\n};\ngoog.string.truncate = function(a, b, c) {\n  c && (a = goog.string.unescapeEntities(a));\n  a.length > b && (a = a.substring(0, b - 3) + \"...\");\n  c && (a = goog.string.htmlEscape(a));\n  return a;\n};\ngoog.string.truncateMiddle = function(a, b, c, d) {\n  c && (a = goog.string.unescapeEntities(a));\n  if (d && a.length > b) {\n    d > b && (d = b);\n    var e = a.length - d;\n    a = a.substring(0, b - d) + \"...\" + a.substring(e);\n  } else {\n    a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + \"...\" + a.substring(e));\n  }\n  c && (a = goog.string.htmlEscape(a));\n  return a;\n};\ngoog.string.specialEscapeChars_ = {\"\\x00\":\"\\\\0\", \"\\b\":\"\\\\b\", \"\\f\":\"\\\\f\", \"\\n\":\"\\\\n\", \"\\r\":\"\\\\r\", \"\\t\":\"\\\\t\", \"\\x0B\":\"\\\\x0B\", '\"':'\\\\\"', \"\\\\\":\"\\\\\\\\\", \"<\":\"<\"};\ngoog.string.jsEscapeCache_ = {\"'\":\"\\\\'\"};\ngoog.string.quote = function(a) {\n  a = String(a);\n  for (var b = ['\"'], c = 0; c < a.length; c++) {\n    var d = a.charAt(c), e = d.charCodeAt(0);\n    b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d));\n  }\n  b.push('\"');\n  return b.join(\"\");\n};\ngoog.string.escapeString = function(a) {\n  for (var b = [], c = 0; c < a.length; c++) {\n    b[c] = goog.string.escapeChar(a.charAt(c));\n  }\n  return b.join(\"\");\n};\ngoog.string.escapeChar = function(a) {\n  if (a in goog.string.jsEscapeCache_) {\n    return goog.string.jsEscapeCache_[a];\n  }\n  if (a in goog.string.specialEscapeChars_) {\n    return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];\n  }\n  var b = a.charCodeAt(0);\n  if (31 < b && 127 > b) {\n    var c = a;\n  } else {\n    if (256 > b) {\n      if (c = \"\\\\x\", 16 > b || 256 < b) {\n        c += \"0\";\n      }\n    } else {\n      c = \"\\\\u\", 4096 > b && (c += \"0\");\n    }\n    c += b.toString(16).toUpperCase();\n  }\n  return goog.string.jsEscapeCache_[a] = c;\n};\ngoog.string.contains = function(a, b) {\n  return -1 != a.indexOf(b);\n};\ngoog.string.caseInsensitiveContains = function(a, b) {\n  return goog.string.contains(a.toLowerCase(), b.toLowerCase());\n};\ngoog.string.countOf = function(a, b) {\n  return a && b ? a.split(b).length - 1 : 0;\n};\ngoog.string.removeAt = function(a, b, c) {\n  var d = a;\n  0 <= b && b < a.length && 0 < c && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));\n  return d;\n};\ngoog.string.remove = function(a, b) {\n  return a.replace(b, \"\");\n};\ngoog.string.removeAll = function(a, b) {\n  var c = new RegExp(goog.string.regExpEscape(b), \"g\");\n  return a.replace(c, \"\");\n};\ngoog.string.replaceAll = function(a, b, c) {\n  b = new RegExp(goog.string.regExpEscape(b), \"g\");\n  return a.replace(b, c.replace(/\\$/g, \"$$$$\"));\n};\ngoog.string.regExpEscape = function(a) {\n  return String(a).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\").replace(/\\x08/g, \"\\\\x08\");\n};\ngoog.string.repeat = String.prototype.repeat ? function(a, b) {\n  return a.repeat(b);\n} : function(a, b) {\n  return Array(b + 1).join(a);\n};\ngoog.string.padNumber = function(a, b, c) {\n  a = goog.isDef(c) ? a.toFixed(c) : String(a);\n  c = a.indexOf(\".\");\n  -1 == c && (c = a.length);\n  return goog.string.repeat(\"0\", Math.max(0, b - c)) + a;\n};\ngoog.string.makeSafe = function(a) {\n  return null == a ? \"\" : String(a);\n};\ngoog.string.buildString = function(a) {\n  return Array.prototype.join.call(arguments, \"\");\n};\ngoog.string.getRandomString = function() {\n  return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);\n};\ngoog.string.compareVersions = function(a, b) {\n  for (var c = 0, d = goog.string.trim(String(a)).split(\".\"), e = goog.string.trim(String(b)).split(\".\"), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++) {\n    var h = d[g] || \"\", k = e[g] || \"\";\n    do {\n      h = /(\\d*)(\\D*)(.*)/.exec(h) || [\"\", \"\", \"\", \"\"];\n      k = /(\\d*)(\\D*)(.*)/.exec(k) || [\"\", \"\", \"\", \"\"];\n      if (0 == h[0].length && 0 == k[0].length) {\n        break;\n      }\n      var c = 0 == h[1].length ? 0 : parseInt(h[1], 10), m = 0 == k[1].length ? 0 : parseInt(k[1], 10), c = goog.string.compareElements_(c, m) || goog.string.compareElements_(0 == h[2].length, 0 == k[2].length) || goog.string.compareElements_(h[2], k[2]), h = h[3], k = k[3];\n    } while (0 == c);\n  }\n  return c;\n};\ngoog.string.compareElements_ = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n};\ngoog.string.hashCode = function(a) {\n  for (var b = 0, c = 0; c < a.length; ++c) {\n    b = 31 * b + a.charCodeAt(c) >>> 0;\n  }\n  return b;\n};\ngoog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;\ngoog.string.createUniqueString = function() {\n  return \"goog_\" + goog.string.uniqueStringCounter_++;\n};\ngoog.string.toNumber = function(a) {\n  var b = Number(a);\n  return 0 == b && goog.string.isEmptyOrWhitespace(a) ? NaN : b;\n};\ngoog.string.isLowerCamelCase = function(a) {\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(a);\n};\ngoog.string.isUpperCamelCase = function(a) {\n  return /^([A-Z][a-z]*)+$/.test(a);\n};\ngoog.string.toCamelCase = function(a) {\n  return String(a).replace(/\\-([a-z])/g, function(a, c) {\n    return c.toUpperCase();\n  });\n};\ngoog.string.toSelectorCase = function(a) {\n  return String(a).replace(/([A-Z])/g, \"-$1\").toLowerCase();\n};\ngoog.string.toTitleCase = function(a, b) {\n  var c = goog.isString(b) ? goog.string.regExpEscape(b) : \"\\\\s\";\n  return a.replace(new RegExp(\"(^\" + (c ? \"|[\" + c + \"]+\" : \"\") + \")([a-z])\", \"g\"), function(a, b, c) {\n    return b + c.toUpperCase();\n  });\n};\ngoog.string.capitalize = function(a) {\n  return String(a.charAt(0)).toUpperCase() + String(a.substr(1)).toLowerCase();\n};\ngoog.string.parseInt = function(a) {\n  isFinite(a) && (a = String(a));\n  return goog.isString(a) ? /^\\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN;\n};\ngoog.string.splitLimit = function(a, b, c) {\n  a = a.split(b);\n  for (var d = []; 0 < c && a.length;) {\n    d.push(a.shift()), c--;\n  }\n  a.length && d.push(a.join(b));\n  return d;\n};\ngoog.string.lastComponent = function(a, b) {\n  if (b) {\n    \"string\" == typeof b && (b = [b]);\n  } else {\n    return a;\n  }\n  for (var c = -1, d = 0; d < b.length; d++) {\n    if (\"\" != b[d]) {\n      var e = a.lastIndexOf(b[d]);\n      e > c && (c = e);\n    }\n  }\n  return -1 == c ? a : a.slice(c + 1);\n};\ngoog.string.editDistance = function(a, b) {\n  var c = [], d = [];\n  if (a == b) {\n    return 0;\n  }\n  if (!a.length || !b.length) {\n    return Math.max(a.length, b.length);\n  }\n  for (var e = 0; e < b.length + 1; e++) {\n    c[e] = e;\n  }\n  for (e = 0; e < a.length; e++) {\n    d[0] = e + 1;\n    for (var f = 0; f < b.length; f++) {\n      d[f + 1] = Math.min(d[f] + 1, c[f + 1] + 1, c[f] + Number(a[e] != b[f]));\n    }\n    for (f = 0; f < c.length; f++) {\n      c[f] = d[f];\n    }\n  }\n  return d[b.length];\n};\ngoog.asserts = {};\ngoog.asserts.ENABLE_ASSERTS = goog.DEBUG;\ngoog.asserts.AssertionError = function(a, b) {\n  b.unshift(a);\n  goog.debug.Error.call(this, goog.string.subs.apply(null, b));\n  b.shift();\n  this.messagePattern = a;\n};\ngoog.inherits(goog.asserts.AssertionError, goog.debug.Error);\ngoog.asserts.AssertionError.prototype.name = \"AssertionError\";\ngoog.asserts.DEFAULT_ERROR_HANDLER = function(a) {\n  throw a;\n};\ngoog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;\ngoog.asserts.doAssertFailure_ = function(a, b, c, d) {\n  var e = \"Assertion failed\";\n  if (c) {\n    e += \": \" + c;\n    var f = d;\n  } else {\n    a && (e += \": \" + a, f = b);\n  }\n  a = new goog.asserts.AssertionError(\"\" + e, f || []);\n  goog.asserts.errorHandler_(a);\n};\ngoog.asserts.setErrorHandler = function(a) {\n  goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = a);\n};\ngoog.asserts.assert = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_(\"\", null, b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.fail = function(a, b) {\n  goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError(\"Failure\" + (a ? \": \" + a : \"\"), Array.prototype.slice.call(arguments, 1)));\n};\ngoog.asserts.assertNumber = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_(\"Expected number but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertString = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_(\"Expected string but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertFunction = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_(\"Expected function but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertObject = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_(\"Expected object but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertArray = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_(\"Expected array but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertBoolean = function(a, b, c) {\n  goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_(\"Expected boolean but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertElement = function(a, b, c) {\n  !goog.asserts.ENABLE_ASSERTS || goog.isObject(a) && a.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_(\"Expected Element but got %s: %s.\", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));\n  return a;\n};\ngoog.asserts.assertInstanceof = function(a, b, c, d) {\n  !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_(\"Expected instanceof %s but got %s.\", [goog.asserts.getType_(b), goog.asserts.getType_(a)], c, Array.prototype.slice.call(arguments, 3));\n  return a;\n};\ngoog.asserts.assertObjectPrototypeIsIntact = function() {\n  for (var a in Object.prototype) {\n    goog.asserts.fail(a + \" should not be enumerable in Object.prototype.\");\n  }\n};\ngoog.asserts.getType_ = function(a) {\n  return a instanceof Function ? a.displayName || a.name || \"unknown type name\" : a instanceof Object ? a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a) : null === a ? \"null\" : typeof a;\n};\ngoog.object = {};\ngoog.object.is = function(a, b) {\n  return a === b ? 0 !== a || 1 / a === 1 / b : a !== a && b !== b;\n};\ngoog.object.forEach = function(a, b, c) {\n  for (var d in a) {\n    b.call(c, a[d], d, a);\n  }\n};\ngoog.object.filter = function(a, b, c) {\n  var d = {}, e;\n  for (e in a) {\n    b.call(c, a[e], e, a) && (d[e] = a[e]);\n  }\n  return d;\n};\ngoog.object.map = function(a, b, c) {\n  var d = {}, e;\n  for (e in a) {\n    d[e] = b.call(c, a[e], e, a);\n  }\n  return d;\n};\ngoog.object.some = function(a, b, c) {\n  for (var d in a) {\n    if (b.call(c, a[d], d, a)) {\n      return !0;\n    }\n  }\n  return !1;\n};\ngoog.object.every = function(a, b, c) {\n  for (var d in a) {\n    if (!b.call(c, a[d], d, a)) {\n      return !1;\n    }\n  }\n  return !0;\n};\ngoog.object.getCount = function(a) {\n  var b = 0, c;\n  for (c in a) {\n    b++;\n  }\n  return b;\n};\ngoog.object.getAnyKey = function(a) {\n  for (var b in a) {\n    return b;\n  }\n};\ngoog.object.getAnyValue = function(a) {\n  for (var b in a) {\n    return a[b];\n  }\n};\ngoog.object.contains = function(a, b) {\n  return goog.object.containsValue(a, b);\n};\ngoog.object.getValues = function(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = a[d];\n  }\n  return b;\n};\ngoog.object.getKeys = function(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = d;\n  }\n  return b;\n};\ngoog.object.getValueByKeys = function(a, b) {\n  for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1; c < d.length && (a = a[d[c]], goog.isDef(a)); c++) {\n  }\n  return a;\n};\ngoog.object.containsKey = function(a, b) {\n  return null !== a && b in a;\n};\ngoog.object.containsValue = function(a, b) {\n  for (var c in a) {\n    if (a[c] == b) {\n      return !0;\n    }\n  }\n  return !1;\n};\ngoog.object.findKey = function(a, b, c) {\n  for (var d in a) {\n    if (b.call(c, a[d], d, a)) {\n      return d;\n    }\n  }\n};\ngoog.object.findValue = function(a, b, c) {\n  return (b = goog.object.findKey(a, b, c)) && a[b];\n};\ngoog.object.isEmpty = function(a) {\n  for (var b in a) {\n    return !1;\n  }\n  return !0;\n};\ngoog.object.clear = function(a) {\n  for (var b in a) {\n    delete a[b];\n  }\n};\ngoog.object.remove = function(a, b) {\n  var c;\n  (c = b in a) && delete a[b];\n  return c;\n};\ngoog.object.add = function(a, b, c) {\n  if (null !== a && b in a) {\n    throw Error('The object already contains the key \"' + b + '\"');\n  }\n  goog.object.set(a, b, c);\n};\ngoog.object.get = function(a, b, c) {\n  return null !== a && b in a ? a[b] : c;\n};\ngoog.object.set = function(a, b, c) {\n  a[b] = c;\n};\ngoog.object.setIfUndefined = function(a, b, c) {\n  return b in a ? a[b] : a[b] = c;\n};\ngoog.object.setWithReturnValueIfNotSet = function(a, b, c) {\n  if (b in a) {\n    return a[b];\n  }\n  c = c();\n  return a[b] = c;\n};\ngoog.object.equals = function(a, b) {\n  for (var c in a) {\n    if (!(c in b) || a[c] !== b[c]) {\n      return !1;\n    }\n  }\n  for (c in b) {\n    if (!(c in a)) {\n      return !1;\n    }\n  }\n  return !0;\n};\ngoog.object.clone = function(a) {\n  var b = {}, c;\n  for (c in a) {\n    b[c] = a[c];\n  }\n  return b;\n};\ngoog.object.unsafeClone = function(a) {\n  var b = goog.typeOf(a);\n  if (\"object\" == b || \"array\" == b) {\n    if (goog.isFunction(a.clone)) {\n      return a.clone();\n    }\n    var b = \"array\" == b ? [] : {}, c;\n    for (c in a) {\n      b[c] = goog.object.unsafeClone(a[c]);\n    }\n    return b;\n  }\n  return a;\n};\ngoog.object.transpose = function(a) {\n  var b = {}, c;\n  for (c in a) {\n    b[a[c]] = c;\n  }\n  return b;\n};\ngoog.object.PROTOTYPE_FIELDS_ = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\ngoog.object.extend = function(a, b) {\n  for (var c, d, e = 1; e < arguments.length; e++) {\n    d = arguments[e];\n    for (c in d) {\n      a[c] = d[c];\n    }\n    for (var f = 0; f < goog.object.PROTOTYPE_FIELDS_.length; f++) {\n      c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);\n    }\n  }\n};\ngoog.object.create = function(a) {\n  var b = arguments.length;\n  if (1 == b && goog.isArray(arguments[0])) {\n    return goog.object.create.apply(null, arguments[0]);\n  }\n  if (b % 2) {\n    throw Error(\"Uneven number of arguments\");\n  }\n  for (var c = {}, d = 0; d < b; d += 2) {\n    c[arguments[d]] = arguments[d + 1];\n  }\n  return c;\n};\ngoog.object.createSet = function(a) {\n  var b = arguments.length;\n  if (1 == b && goog.isArray(arguments[0])) {\n    return goog.object.createSet.apply(null, arguments[0]);\n  }\n  for (var c = {}, d = 0; d < b; d++) {\n    c[arguments[d]] = !0;\n  }\n  return c;\n};\ngoog.object.createImmutableView = function(a) {\n  var b = a;\n  Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));\n  return b;\n};\ngoog.object.isImmutableView = function(a) {\n  return !!Object.isFrozen && Object.isFrozen(a);\n};\ngoog.object.getAllPropertyNames = function(a, b, c) {\n  if (!a) {\n    return [];\n  }\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n    return goog.object.getKeys(a);\n  }\n  for (var d = {}; a && (a !== Object.prototype || b) && (a !== Function.prototype || c);) {\n    for (var e = Object.getOwnPropertyNames(a), f = 0; f < e.length; f++) {\n      d[e[f]] = !0;\n    }\n    a = Object.getPrototypeOf(a);\n  }\n  return goog.object.getKeys(d);\n};\ngoog.reflect = {};\ngoog.reflect.object = function(a, b) {\n  return b;\n};\ngoog.reflect.objectProperty = function(a, b) {\n  return a;\n};\ngoog.reflect.sinkValue = function(a) {\n  goog.reflect.sinkValue[\" \"](a);\n  return a;\n};\ngoog.reflect.sinkValue[\" \"] = goog.nullFunction;\ngoog.reflect.canAccessProperty = function(a, b) {\n  try {\n    return goog.reflect.sinkValue(a[b]), !0;\n  } catch (c) {\n  }\n  return !1;\n};\ngoog.reflect.cache = function(a, b, c, d) {\n  d = d ? d(b) : b;\n  return Object.prototype.hasOwnProperty.call(a, d) ? a[d] : a[d] = c(b);\n};\ngoog.math = {};\ngoog.math.Long = function(a, b) {\n  this.low_ = a | 0;\n  this.high_ = b | 0;\n};\ngoog.math.Long.IntCache_ = {};\ngoog.math.Long.valueCache_ = {};\ngoog.math.Long.getCachedIntValue_ = function(a) {\n  return goog.reflect.cache(goog.math.Long.IntCache_, a, function(a) {\n    return new goog.math.Long(a, 0 > a ? -1 : 0);\n  });\n};\ngoog.math.Long.MAX_VALUE_FOR_RADIX_ = \"  111111111111111111111111111111111111111111111111111111111111111 2021110011022210012102010021220101220221 13333333333333333333333333333333 1104332401304422434310311212 1540241003031030222122211 22341010611245052052300 777777777777777777777 67404283172107811827 9223372036854775807 1728002635214590697 41a792678515120367 10b269549075433c37 4340724c6c71dc7a7 160e2ad3246366807 7fffffffffffffff 33d3d8307b214008 16agh595df825fa7 ba643dci0ffeehh 5cbfjia3fh26ja7 2heiciiie82dh97 1adaibb21dckfa7 i6k448cf4192c2 acd772jnc9l0l7 64ie1focnn5g77 3igoecjbmca687 27c48l5b37oaop 1bk39f3ah3dmq7 q1se8f0m04isb hajppbc1fc207 bm03i95hia437 7vvvvvvvvvvvv 5hg4ck9jd4u37 3tdtk1v8j6tpp 2pijmikexrxp7 1y2p0ij32e8e7\".split(\" \");\ngoog.math.Long.MIN_VALUE_FOR_RADIX_ = \"  -1000000000000000000000000000000000000000000000000000000000000000 -2021110011022210012102010021220101220222 -20000000000000000000000000000000 -1104332401304422434310311213 -1540241003031030222122212 -22341010611245052052301 -1000000000000000000000 -67404283172107811828 -9223372036854775808 -1728002635214590698 -41a792678515120368 -10b269549075433c38 -4340724c6c71dc7a8 -160e2ad3246366808 -8000000000000000 -33d3d8307b214009 -16agh595df825fa8 -ba643dci0ffeehi -5cbfjia3fh26ja8 -2heiciiie82dh98 -1adaibb21dckfa8 -i6k448cf4192c3 -acd772jnc9l0l8 -64ie1focnn5g78 -3igoecjbmca688 -27c48l5b37oaoq -1bk39f3ah3dmq8 -q1se8f0m04isc -hajppbc1fc208 -bm03i95hia438 -8000000000000 -5hg4ck9jd4u38 -3tdtk1v8j6tpq -2pijmikexrxp8 -1y2p0ij32e8e8\".split(\" \");\ngoog.math.Long.fromInt = function(a) {\n  var b = a | 0;\n  goog.asserts.assert(a === b, \"value should be a 32-bit integer\");\n  return -128 <= b && 128 > b ? goog.math.Long.getCachedIntValue_(b) : new goog.math.Long(b, 0 > b ? -1 : 0);\n};\ngoog.math.Long.fromNumber = function(a) {\n  return isNaN(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);\n};\ngoog.math.Long.fromBits = function(a, b) {\n  return new goog.math.Long(a, b);\n};\ngoog.math.Long.fromString = function(a, b) {\n  if (0 == a.length) {\n    throw Error(\"number format error: empty string\");\n  }\n  var c = b || 10;\n  if (2 > c || 36 < c) {\n    throw Error(\"radix out of range: \" + c);\n  }\n  if (\"-\" == a.charAt(0)) {\n    return goog.math.Long.fromString(a.substring(1), c).negate();\n  }\n  if (0 <= a.indexOf(\"-\")) {\n    throw Error('number format error: interior \"-\" character: ' + a);\n  }\n  for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0; f < a.length; f += 8) {\n    var g = Math.min(8, a.length - f), h = parseInt(a.substring(f, f + g), c);\n    8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));\n  }\n  return e;\n};\ngoog.math.Long.isStringInRange = function(a, b) {\n  var c = b || 10;\n  if (2 > c || 36 < c) {\n    throw Error(\"radix out of range: \" + c);\n  }\n  c = \"-\" == a.charAt(0) ? goog.math.Long.MIN_VALUE_FOR_RADIX_[c] : goog.math.Long.MAX_VALUE_FOR_RADIX_[c];\n  return a.length < c.length ? !0 : a.length == c.length && a <= c ? !0 : !1;\n};\ngoog.math.Long.TWO_PWR_16_DBL_ = 65536;\ngoog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;\ngoog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;\ngoog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;\ngoog.math.Long.getZero = function() {\n  return goog.math.Long.getCachedIntValue_(0);\n};\ngoog.math.Long.getOne = function() {\n  return goog.math.Long.getCachedIntValue_(1);\n};\ngoog.math.Long.getNegOne = function() {\n  return goog.math.Long.getCachedIntValue_(-1);\n};\ngoog.math.Long.getMaxValue = function() {\n  return goog.reflect.cache(goog.math.Long.valueCache_, goog.math.Long.ValueCacheId_.MAX_VALUE, function() {\n    return goog.math.Long.fromBits(-1, 2147483647);\n  });\n};\ngoog.math.Long.getMinValue = function() {\n  return goog.reflect.cache(goog.math.Long.valueCache_, goog.math.Long.ValueCacheId_.MIN_VALUE, function() {\n    return goog.math.Long.fromBits(0, -2147483648);\n  });\n};\ngoog.math.Long.getTwoPwr24 = function() {\n  return goog.reflect.cache(goog.math.Long.valueCache_, goog.math.Long.ValueCacheId_.TWO_PWR_24, function() {\n    return goog.math.Long.fromInt(16777216);\n  });\n};\ngoog.math.Long.prototype.toInt = function() {\n  return this.low_;\n};\ngoog.math.Long.prototype.toNumber = function() {\n  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\n};\ngoog.math.Long.prototype.toString = function(a) {\n  a = a || 10;\n  if (2 > a || 36 < a) {\n    throw Error(\"radix out of range: \" + a);\n  }\n  if (this.isZero()) {\n    return \"0\";\n  }\n  if (this.isNegative()) {\n    if (this.equals(goog.math.Long.getMinValue())) {\n      var b = goog.math.Long.fromNumber(a);\n      var c = this.div(b);\n      b = c.multiply(b).subtract(this);\n      return c.toString(a) + b.toInt().toString(a);\n    }\n    return \"-\" + this.negate().toString(a);\n  }\n  c = goog.math.Long.fromNumber(Math.pow(a, 6));\n  b = this;\n  for (var d = \"\";;) {\n    var e = b.div(c), f = (b.subtract(e.multiply(c)).toInt() >>> 0).toString(a);\n    b = e;\n    if (b.isZero()) {\n      return f + d;\n    }\n    for (; 6 > f.length;) {\n      f = \"0\" + f;\n    }\n    d = \"\" + f + d;\n  }\n};\ngoog.math.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\ngoog.math.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\ngoog.math.Long.prototype.getLowBitsUnsigned = function() {\n  return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;\n};\ngoog.math.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();\n  }\n  for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31; 0 < b && 0 == (a & 1 << b); b--) {\n  }\n  return 0 != this.high_ ? b + 33 : b + 1;\n};\ngoog.math.Long.prototype.isZero = function() {\n  return 0 == this.high_ && 0 == this.low_;\n};\ngoog.math.Long.prototype.isNegative = function() {\n  return 0 > this.high_;\n};\ngoog.math.Long.prototype.isOdd = function() {\n  return 1 == (this.low_ & 1);\n};\ngoog.math.Long.prototype.equals = function(a) {\n  return this.high_ == a.high_ && this.low_ == a.low_;\n};\ngoog.math.Long.prototype.notEquals = function(a) {\n  return this.high_ != a.high_ || this.low_ != a.low_;\n};\ngoog.math.Long.prototype.lessThan = function(a) {\n  return 0 > this.compare(a);\n};\ngoog.math.Long.prototype.lessThanOrEqual = function(a) {\n  return 0 >= this.compare(a);\n};\ngoog.math.Long.prototype.greaterThan = function(a) {\n  return 0 < this.compare(a);\n};\ngoog.math.Long.prototype.greaterThanOrEqual = function(a) {\n  return 0 <= this.compare(a);\n};\ngoog.math.Long.prototype.compare = function(a) {\n  if (this.equals(a)) {\n    return 0;\n  }\n  var b = this.isNegative(), c = a.isNegative();\n  return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;\n};\ngoog.math.Long.prototype.negate = function() {\n  return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());\n};\ngoog.math.Long.prototype.add = function(a) {\n  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = a.high_ >>> 16, f = a.high_ & 65535, g = a.low_ >>> 16;\n  a = 0 + ((this.low_ & 65535) + (a.low_ & 65535));\n  g = 0 + (a >>> 16) + (d + g);\n  d = 0 + (g >>> 16);\n  d += c + f;\n  b = 0 + (d >>> 16) + (b + e) & 65535;\n  return goog.math.Long.fromBits((g & 65535) << 16 | a & 65535, b << 16 | d & 65535);\n};\ngoog.math.Long.prototype.subtract = function(a) {\n  return this.add(a.negate());\n};\ngoog.math.Long.prototype.multiply = function(a) {\n  if (this.isZero() || a.isZero()) {\n    return goog.math.Long.getZero();\n  }\n  if (this.equals(goog.math.Long.getMinValue())) {\n    return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();\n  }\n  if (a.equals(goog.math.Long.getMinValue())) {\n    return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();\n  }\n  if (this.isNegative()) {\n    return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();\n  }\n  if (a.isNegative()) {\n    return this.multiply(a.negate()).negate();\n  }\n  if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {\n    return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());\n  }\n  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = this.low_ & 65535, f = a.high_ >>> 16, g = a.high_ & 65535, h = a.low_ >>> 16;\n  a = a.low_ & 65535;\n  var k = 0 + e * a;\n  var m = 0 + (k >>> 16) + d * a;\n  var l = 0 + (m >>> 16);\n  m = (m & 65535) + e * h;\n  l += m >>> 16;\n  l += c * a;\n  var n = 0 + (l >>> 16);\n  l = (l & 65535) + d * h;\n  n += l >>> 16;\n  l = (l & 65535) + e * g;\n  n = n + (l >>> 16) + (b * a + c * h + d * g + e * f) & 65535;\n  return goog.math.Long.fromBits((m & 65535) << 16 | k & 65535, n << 16 | l & 65535);\n};\ngoog.math.Long.prototype.div = function(a) {\n  if (a.isZero()) {\n    throw Error(\"division by zero\");\n  }\n  if (this.isZero()) {\n    return goog.math.Long.getZero();\n  }\n  if (this.equals(goog.math.Long.getMinValue())) {\n    if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {\n      return goog.math.Long.getMinValue();\n    }\n    if (a.equals(goog.math.Long.getMinValue())) {\n      return goog.math.Long.getOne();\n    }\n    var b = this.shiftRight(1);\n    b = b.div(a).shiftLeft(1);\n    if (b.equals(goog.math.Long.getZero())) {\n      return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();\n    }\n    var c = this.subtract(a.multiply(b));\n    return b.add(c.div(a));\n  }\n  if (a.equals(goog.math.Long.getMinValue())) {\n    return goog.math.Long.getZero();\n  }\n  if (this.isNegative()) {\n    return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();\n  }\n  if (a.isNegative()) {\n    return this.div(a.negate()).negate();\n  }\n  var d = goog.math.Long.getZero();\n  for (c = this; c.greaterThanOrEqual(a);) {\n    b = Math.max(1, Math.floor(c.toNumber() / a.toNumber()));\n    for (var e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a); g.isNegative() || g.greaterThan(c);) {\n      b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);\n    }\n    f.isZero() && (f = goog.math.Long.getOne());\n    d = d.add(f);\n    c = c.subtract(g);\n  }\n  return d;\n};\ngoog.math.Long.prototype.modulo = function(a) {\n  return this.subtract(this.div(a).multiply(a));\n};\ngoog.math.Long.prototype.not = function() {\n  return goog.math.Long.fromBits(~this.low_, ~this.high_);\n};\ngoog.math.Long.prototype.and = function(a) {\n  return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);\n};\ngoog.math.Long.prototype.or = function(a) {\n  return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);\n};\ngoog.math.Long.prototype.xor = function(a) {\n  return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);\n};\ngoog.math.Long.prototype.shiftLeft = function(a) {\n  a &= 63;\n  if (0 == a) {\n    return this;\n  }\n  var b = this.low_;\n  return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);\n};\ngoog.math.Long.prototype.shiftRight = function(a) {\n  a &= 63;\n  if (0 == a) {\n    return this;\n  }\n  var b = this.high_;\n  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);\n};\ngoog.math.Long.prototype.shiftRightUnsigned = function(a) {\n  a &= 63;\n  if (0 == a) {\n    return this;\n  }\n  var b = this.high_;\n  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);\n};\ngoog.math.Long.ValueCacheId_ = {MAX_VALUE:1, MIN_VALUE:2, TWO_PWR_24:6};\nvar com = {cognitect:{}};\ncom.cognitect.transit = {};\ncom.cognitect.transit.delimiters = {};\ncom.cognitect.transit.delimiters.ESC = \"~\";\ncom.cognitect.transit.delimiters.TAG = \"#\";\ncom.cognitect.transit.delimiters.SUB = \"^\";\ncom.cognitect.transit.delimiters.RES = \"`\";\ncom.cognitect.transit.delimiters.ESC_TAG = \"~#\";\ncom.cognitect.transit.caching = {};\ncom.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;\ncom.cognitect.transit.caching.BASE_CHAR_IDX = 48;\ncom.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;\ncom.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;\ncom.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;\ncom.cognitect.transit.caching.isCacheable = function(a, b) {\n  if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {\n    if (b) {\n      return !0;\n    }\n    var c = a.charAt(0), d = a.charAt(1);\n    return c === com.cognitect.transit.delimiters.ESC ? \":\" === d || \"$\" === d || \"#\" === d : !1;\n  }\n  return !1;\n};\ncom.cognitect.transit.caching.idxToCode = function(a) {\n  var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);\n  a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);\n  return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;\n};\ncom.cognitect.transit.caching.WriteCache = function() {\n  this.cacheSize = this.gen = this.idx = 0;\n  this.cache = {};\n};\ncom.cognitect.transit.caching.WriteCache.prototype.write = function(a, b) {\n  if (com.cognitect.transit.caching.isCacheable(a, b)) {\n    this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();\n    var c = this.cache[a];\n    return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];\n  }\n  return a;\n};\ncom.cognitect.transit.caching.WriteCache.prototype.clear = function() {\n  this.idx = 0;\n  this.gen++;\n};\ncom.cognitect.transit.caching.writeCache = function() {\n  return new com.cognitect.transit.caching.WriteCache;\n};\ncom.cognitect.transit.caching.isCacheCode = function(a) {\n  return a.charAt(0) === com.cognitect.transit.delimiters.SUB && \" \" !== a.charAt(1);\n};\ncom.cognitect.transit.caching.codeToIdx = function(a) {\n  if (2 === a.length) {\n    return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;\n  }\n  var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;\n  a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;\n  return b + a;\n};\ncom.cognitect.transit.caching.ReadCache = function() {\n  this.idx = 0;\n  this.cache = [];\n};\ncom.cognitect.transit.caching.ReadCache.prototype.write = function(a, b) {\n  this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);\n  this.cache[this.idx] = a;\n  this.idx++;\n  return a;\n};\ncom.cognitect.transit.caching.ReadCache.prototype.read = function(a, b) {\n  return this.cache[com.cognitect.transit.caching.codeToIdx(a)];\n};\ncom.cognitect.transit.caching.ReadCache.prototype.clear = function() {\n  this.idx = 0;\n};\ncom.cognitect.transit.caching.readCache = function() {\n  return new com.cognitect.transit.caching.ReadCache;\n};\ncom.cognitect.transit.util = {};\ncom.cognitect.transit.util.objectKeys = \"undefined\" != typeof Object.keys ? function(a) {\n  return Object.keys(a);\n} : function(a) {\n  return goog.object.getKeys(a);\n};\ncom.cognitect.transit.util.isArray = \"undefined\" != typeof Array.isArray ? function(a) {\n  return Array.isArray(a);\n} : function(a) {\n  return \"array\" === goog.typeOf(a);\n};\ncom.cognitect.transit.util.chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\ncom.cognitect.transit.util.randInt = function(a) {\n  return Math.round(Math.random() * a);\n};\ncom.cognitect.transit.util.randHex = function() {\n  return com.cognitect.transit.util.randInt(15).toString(16);\n};\ncom.cognitect.transit.util.randomUUID = function() {\n  var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);\n  return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + \"-\" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + \"-4\" + com.cognitect.transit.util.randHex() + \n  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + \"-\" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + \"-\" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + \n  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();\n};\ncom.cognitect.transit.util.btoa = function(a) {\n  if (\"undefined\" != typeof btoa) {\n    return btoa(a);\n  }\n  a = String(a);\n  for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = \"\"; a.charAt(d | 0) || (e = \"=\", d % 1); f += e.charAt(63 & b >> 8 - d % 1 * 8)) {\n    c = a.charCodeAt(d += .75);\n    if (255 < c) {\n      throw Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n    }\n    b = b << 8 | c;\n  }\n  return f;\n};\ncom.cognitect.transit.util.atob = function(a) {\n  if (\"undefined\" != typeof atob) {\n    return atob(a);\n  }\n  a = String(a).replace(/=+$/, \"\");\n  if (1 == a.length % 4) {\n    throw Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  }\n  for (var b = 0, c, d, e = 0, f = \"\"; d = a.charAt(e++); ~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {\n    d = com.cognitect.transit.util.chars.indexOf(d);\n  }\n  return f;\n};\ncom.cognitect.transit.util.Uint8ToBase64 = function(a) {\n  for (var b = 0, c = a.length, d = \"\", e; b < c;) {\n    e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;\n  }\n  return com.cognitect.transit.util.btoa(d);\n};\ncom.cognitect.transit.util.Base64ToUint8 = function(a) {\n  a = com.cognitect.transit.util.atob(a);\n  for (var b = a.length, c = new Uint8Array(b), d = 0; d < b; d++) {\n    var e = a.charCodeAt(d);\n    c[d] = e;\n  }\n  return c;\n};\ncom.cognitect.transit.eq = {};\ncom.cognitect.transit.eq.hashCodeProperty = \"transit$hashCode$\";\ncom.cognitect.transit.eq.hashCodeCounter = 1;\ncom.cognitect.transit.eq.equals = function(a, b) {\n  if (null == a) {\n    return null == b;\n  }\n  if (a === b) {\n    return !0;\n  }\n  if (\"object\" === typeof a) {\n    if (com.cognitect.transit.util.isArray(a)) {\n      if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {\n        for (var c = 0; c < a.length; c++) {\n          if (!com.cognitect.transit.eq.equals(a[c], b[c])) {\n            return !1;\n          }\n        }\n        return !0;\n      }\n      return !1;\n    }\n    if (a.com$cognitect$transit$equals) {\n      return a.com$cognitect$transit$equals(b);\n    }\n    if (null != b && \"object\" === typeof b) {\n      if (b.com$cognitect$transit$equals) {\n        return b.com$cognitect$transit$equals(a);\n      }\n      var c = 0, d = com.cognitect.transit.util.objectKeys(b).length, e;\n      for (e in a) {\n        if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {\n          return !1;\n        }\n      }\n      return c === d;\n    }\n  }\n  return !1;\n};\ncom.cognitect.transit.eq.hashCombine = function(a, b) {\n  return a ^ b + 2654435769 + (a << 6) + (a >> 2);\n};\ncom.cognitect.transit.eq.stringCodeCache = {};\ncom.cognitect.transit.eq.stringCodeCacheSize = 0;\ncom.cognitect.transit.eq.STR_CACHE_MAX = 256;\ncom.cognitect.transit.eq.hashString = function(a) {\n  var b = com.cognitect.transit.eq.stringCodeCache[a];\n  if (null != b) {\n    return b;\n  }\n  for (var c = b = 0; c < a.length; ++c) {\n    b = 31 * b + a.charCodeAt(c), b %= 4294967296;\n  }\n  com.cognitect.transit.eq.stringCodeCacheSize++;\n  com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);\n  return com.cognitect.transit.eq.stringCodeCache[a] = b;\n};\ncom.cognitect.transit.eq.hashMapLike = function(a) {\n  var b = 0;\n  if (null != a.forEach) {\n    a.forEach(function(a, c, d) {\n      b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;\n    });\n  } else {\n    for (var c = com.cognitect.transit.util.objectKeys(a), d = 0; d < c.length; d++) {\n      var e = c[d], f = a[e], b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496;\n    }\n  }\n  return b;\n};\ncom.cognitect.transit.eq.hashArrayLike = function(a) {\n  var b = 0;\n  if (com.cognitect.transit.util.isArray(a)) {\n    for (var c = 0; c < a.length; c++) {\n      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));\n    }\n  } else {\n    a.forEach && a.forEach(function(a, c) {\n      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));\n    });\n  }\n  return b;\n};\ncom.cognitect.transit.eq.hashCode = function(a) {\n  if (null == a) {\n    return 0;\n  }\n  switch(typeof a) {\n    case \"number\":\n      return a;\n    case \"boolean\":\n      return !0 === a ? 1 : 0;\n    case \"string\":\n      return com.cognitect.transit.eq.hashString(a);\n    case \"function\":\n      var b = a[com.cognitect.transit.eq.hashCodeProperty];\n      b || (b = com.cognitect.transit.eq.hashCodeCounter, \"undefined\" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, {value:b, enumerable:!1}) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);\n      return b;\n    default:\n      return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);\n  }\n};\ncom.cognitect.transit.eq.extendToEQ = function(a, b) {\n  a.com$cognitect$transit$hashCode = b.hashCode;\n  a.com$cognitect$transit$equals = b.equals;\n  return a;\n};\ncom.cognitect.transit.types = {};\ncom.cognitect.transit.types.ITERATOR = \"undefined\" != typeof Symbol ? Symbol.iterator : \"@@iterator\";\ncom.cognitect.transit.types.TaggedValue = function(a, b) {\n  this.tag = a;\n  this.rep = b;\n  this.hashCode = -1;\n};\ncom.cognitect.transit.types.TaggedValue.prototype.toString = function() {\n  return \"[TaggedValue: \" + this.tag + \", \" + this.rep + \"]\";\n};\ncom.cognitect.transit.types.TaggedValue.prototype.equiv = function(a) {\n  return com.cognitect.transit.eq.equals(this, a);\n};\ncom.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;\ncom.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;\n};\ncom.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.taggedValue = function(a, b) {\n  return new com.cognitect.transit.types.TaggedValue(a, b);\n};\ncom.cognitect.transit.types.isTaggedValue = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue;\n};\ncom.cognitect.transit.types.nullValue = function() {\n  return null;\n};\ncom.cognitect.transit.types.boolValue = function(a) {\n  return \"t\" === a;\n};\ncom.cognitect.transit.types.MAX_INT = goog.math.Long.fromString(\"9007199254740991\");\ncom.cognitect.transit.types.MIN_INT = goog.math.Long.fromString(\"-9007199254740991\");\ncom.cognitect.transit.types.intValue = function(a) {\n  if (\"number\" === typeof a || a instanceof goog.math.Long) {\n    return a;\n  }\n  a = goog.math.Long.fromString(a, 10);\n  return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();\n};\ngoog.math.Long.prototype.equiv = function(a) {\n  return com.cognitect.transit.eq.equals(this, a);\n};\ngoog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;\ngoog.math.Long.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof goog.math.Long && this.equals(a);\n};\ngoog.math.Long.prototype.com$cognitect$transit$hashCode = function() {\n  return this.toInt();\n};\ncom.cognitect.transit.types.isInteger = function(a) {\n  return a instanceof goog.math.Long ? !0 : \"number\" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);\n};\ncom.cognitect.transit.types.floatValue = function(a) {\n  return parseFloat(a);\n};\ncom.cognitect.transit.types.bigInteger = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"n\", a);\n};\ncom.cognitect.transit.types.isBigInteger = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"n\" === a.tag;\n};\ncom.cognitect.transit.types.bigDecimalValue = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"f\", a);\n};\ncom.cognitect.transit.types.isBigDecimal = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"f\" === a.tag;\n};\ncom.cognitect.transit.types.charValue = function(a) {\n  return a;\n};\ncom.cognitect.transit.types.Keyword = function(a) {\n  this._name = a;\n  this.hashCode = -1;\n};\ncom.cognitect.transit.types.Keyword.prototype.toString = function() {\n  return \":\" + this._name;\n};\ncom.cognitect.transit.types.Keyword.prototype.namespace = function() {\n  var a = this._name.indexOf(\"/\");\n  return -1 != a ? this._name.substring(0, a) : null;\n};\ncom.cognitect.transit.types.Keyword.prototype.name = function() {\n  var a = this._name.indexOf(\"/\");\n  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;\n};\ncom.cognitect.transit.types.Keyword.prototype.equiv = function(a) {\n  return com.cognitect.transit.eq.equals(this, a);\n};\ncom.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;\ncom.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;\n};\ncom.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.keyword = function(a) {\n  return new com.cognitect.transit.types.Keyword(a);\n};\ncom.cognitect.transit.types.isKeyword = function(a) {\n  return a instanceof com.cognitect.transit.types.Keyword;\n};\ncom.cognitect.transit.types.Symbol = function(a) {\n  this._name = a;\n  this.hashCode = -1;\n};\ncom.cognitect.transit.types.Symbol.prototype.namespace = function() {\n  var a = this._name.indexOf(\"/\");\n  return -1 != a ? this._name.substring(0, a) : null;\n};\ncom.cognitect.transit.types.Symbol.prototype.name = function() {\n  var a = this._name.indexOf(\"/\");\n  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;\n};\ncom.cognitect.transit.types.Symbol.prototype.toString = function() {\n  return this._name;\n};\ncom.cognitect.transit.types.Symbol.prototype.equiv = function(a) {\n  return com.cognitect.transit.eq.equals(this, a);\n};\ncom.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;\ncom.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;\n};\ncom.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.symbol = function(a) {\n  return new com.cognitect.transit.types.Symbol(a);\n};\ncom.cognitect.transit.types.isSymbol = function(a) {\n  return a instanceof com.cognitect.transit.types.Symbol;\n};\ncom.cognitect.transit.types.hexFor = function(a, b, c) {\n  var d = \"\";\n  c = c || b + 1;\n  for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e); b < c; b++, e -= 8, f = f.shiftRightUnsigned(8)) {\n    var g = a.and(f).shiftRightUnsigned(e).toString(16);\n    1 == g.length && (g = \"0\" + g);\n    d += g;\n  }\n  return d;\n};\ncom.cognitect.transit.types.UUID = function(a, b) {\n  this.high = a;\n  this.low = b;\n  this.hashCode = -1;\n};\ncom.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {\n  return this.low;\n};\ncom.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {\n  return this.high;\n};\ncom.cognitect.transit.types.UUID.prototype.toString = function() {\n  var a = this.high, b = this.low;\n  var c = \"\" + (com.cognitect.transit.types.hexFor(a, 0, 4) + \"-\");\n  c += com.cognitect.transit.types.hexFor(a, 4, 6) + \"-\";\n  c += com.cognitect.transit.types.hexFor(a, 6, 8) + \"-\";\n  c += com.cognitect.transit.types.hexFor(b, 0, 2) + \"-\";\n  return c += com.cognitect.transit.types.hexFor(b, 2, 8);\n};\ncom.cognitect.transit.types.UUID.prototype.equiv = function(a) {\n  return com.cognitect.transit.eq.equals(this, a);\n};\ncom.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;\ncom.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);\n};\ncom.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.UUIDfromString = function(a) {\n  a = a.replace(/-/g, \"\");\n  var b, c;\n  var d = b = 0;\n  for (c = 24; 8 > d; d += 2, c -= 8) {\n    b |= parseInt(a.substring(d, d + 2), 16) << c;\n  }\n  var e = 0;\n  d = 8;\n  for (c = 24; 16 > d; d += 2, c -= 8) {\n    e |= parseInt(a.substring(d, d + 2), 16) << c;\n  }\n  var f = goog.math.Long.fromBits(e, b);\n  b = 0;\n  d = 16;\n  for (c = 24; 24 > d; d += 2, c -= 8) {\n    b |= parseInt(a.substring(d, d + 2), 16) << c;\n  }\n  e = 0;\n  for (c = d = 24; 32 > d; d += 2, c -= 8) {\n    e |= parseInt(a.substring(d, d + 2), 16) << c;\n  }\n  a = goog.math.Long.fromBits(e, b);\n  return new com.cognitect.transit.types.UUID(f, a);\n};\ncom.cognitect.transit.types.uuid = function(a) {\n  return com.cognitect.transit.types.UUIDfromString(a);\n};\ncom.cognitect.transit.types.isUUID = function(a) {\n  return a instanceof com.cognitect.transit.types.UUID;\n};\ncom.cognitect.transit.types.date = function(a) {\n  a = \"number\" === typeof a ? a : parseInt(a, 10);\n  return new Date(a);\n};\ncom.cognitect.transit.types.verboseDate = function(a) {\n  return new Date(a);\n};\nDate.prototype.com$cognitect$transit$equals = function(a) {\n  return a instanceof Date ? this.valueOf() === a.valueOf() : !1;\n};\nDate.prototype.com$cognitect$transit$hashCode = function() {\n  return this.valueOf();\n};\ncom.cognitect.transit.types.binary = function(a, b) {\n  return b && !1 === b.preferBuffers || \"undefined\" == typeof goog.global.Buffer ? \"undefined\" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue(\"b\", a) : new goog.global.Buffer(a, \"base64\");\n};\ncom.cognitect.transit.types.isBinary = function(a) {\n  return \"undefined\" != typeof goog.global.Buffer && a instanceof goog.global.Buffer ? !0 : \"undefined\" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && \"b\" === a.tag;\n};\ncom.cognitect.transit.types.uri = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"r\", a);\n};\ncom.cognitect.transit.types.isURI = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"r\" === a.tag;\n};\ncom.cognitect.transit.types.KEYS = 0;\ncom.cognitect.transit.types.VALUES = 1;\ncom.cognitect.transit.types.ENTRIES = 2;\ncom.cognitect.transit.types.TransitArrayMapIterator = function(a, b) {\n  this.entries = a;\n  this.type = b || com.cognitect.transit.types.KEYS;\n  this.idx = 0;\n};\ncom.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {\n  if (this.idx < this.entries.length) {\n    var a = {value:this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], done:!1};\n    this.idx += 2;\n    return a;\n  }\n  return {value:null, done:!0};\n};\ncom.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;\ncom.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {\n  return this;\n};\ncom.cognitect.transit.types.TransitMapIterator = function(a, b) {\n  this.map = a;\n  this.type = b || com.cognitect.transit.types.KEYS;\n  this.keys = this.map.getKeys();\n  this.idx = 0;\n  this.bucket = null;\n  this.bucketIdx = 0;\n};\ncom.cognitect.transit.types.TransitMapIterator.prototype.next = function() {\n  if (this.idx < this.map.size) {\n    null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);\n    var a = {value:this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], done:!1};\n    this.idx++;\n    this.bucketIdx += 2;\n    return a;\n  }\n  return {value:null, done:!0};\n};\ncom.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;\ncom.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {\n  return this;\n};\ncom.cognitect.transit.types.mapEquals = function(a, b) {\n  if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {\n    if (a.size !== b.size) {\n      return !1;\n    }\n    for (var c in a.map) {\n      for (var d = a.map[c], e = 0; e < d.length; e += 2) {\n        if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {\n          return !1;\n        }\n      }\n    }\n    return !0;\n  }\n  if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {\n    if (a.size !== b.size) {\n      return !1;\n    }\n    c = a._entries;\n    for (e = 0; e < c.length; e += 2) {\n      if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {\n        return !1;\n      }\n    }\n    return !0;\n  }\n  if (null != b && \"object\" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {\n    for (d = 0; d < c; d++) {\n      var f = e[d];\n      if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {\n        return !1;\n      }\n    }\n    return !0;\n  }\n  return !1;\n};\ncom.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;\ncom.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;\ncom.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;\ncom.cognitect.transit.types.print = function(a) {\n  return null == a ? \"null\" : goog.isArray(a) ? \"[\" + a.toString() + \"]\" : goog.isString(a) ? '\"' + a + '\"' : a.toString();\n};\ncom.cognitect.transit.types.printMap = function(a) {\n  var b = 0, c = \"TransitMap {\";\n  a.forEach(function(d, e) {\n    c += com.cognitect.transit.types.print(e) + \" => \" + com.cognitect.transit.types.print(d);\n    b < a.size - 1 && (c += \", \");\n    b++;\n  });\n  return c + \"}\";\n};\ncom.cognitect.transit.types.printSet = function(a) {\n  var b = 0, c = \"TransitSet {\";\n  a.forEach(function(d) {\n    c += com.cognitect.transit.types.print(d);\n    b < a.size - 1 && (c += \", \");\n    b++;\n  });\n  return c + \"}\";\n};\ncom.cognitect.transit.types.TransitArrayMap = function(a) {\n  this._entries = a;\n  this.backingMap = null;\n  this.hashCode = -1;\n  this.size = a.length / 2;\n  this.accesses = 0;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {\n  return com.cognitect.transit.types.printMap(this);\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {\n  return this.toString();\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {\n  if (this.backingMap) {\n    throw Error(\"Invalid operation, already converted\");\n  }\n  if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {\n    return !1;\n  }\n  this.accesses++;\n  return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {\n  this.hashCode = -1;\n  this.backingMap ? this.backingMap.clear() : this._entries = [];\n  this.size = 0;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;\ncom.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {\n  return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;\ncom.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {\n  if (this.backingMap) {\n    return this.backingMap.keySet();\n  }\n  for (var a = [], b = 0, c = 0; c < this._entries.length; b++, c += 2) {\n    a[b] = this._entries[c];\n  }\n  return a;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;\ncom.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {\n  return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;\ncom.cognitect.transit.types.TransitArrayMap.prototype.values = function() {\n  return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;\ncom.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a) {\n  if (this.backingMap) {\n    this.backingMap.forEach(a);\n  } else {\n    for (var b = 0; b < this._entries.length; b += 2) {\n      a(this._entries[b + 1], this._entries[b]);\n    }\n  }\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;\ncom.cognitect.transit.types.TransitArrayMap.prototype.get = function(a, b) {\n  if (this.backingMap) {\n    return this.backingMap.get(a);\n  }\n  if (this.convert()) {\n    return this.get(a);\n  }\n  for (var c = 0; c < this._entries.length; c += 2) {\n    if (com.cognitect.transit.eq.equals(this._entries[c], a)) {\n      return this._entries[c + 1];\n    }\n  }\n  return b;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;\ncom.cognitect.transit.types.TransitArrayMap.prototype.has = function(a) {\n  if (this.backingMap) {\n    return this.backingMap.has(a);\n  }\n  if (this.convert()) {\n    return this.has(a);\n  }\n  for (var b = 0; b < this._entries.length; b += 2) {\n    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {\n      return !0;\n    }\n  }\n  return !1;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;\ncom.cognitect.transit.types.TransitArrayMap.prototype.set = function(a, b) {\n  this.hashCode = -1;\n  if (this.backingMap) {\n    this.backingMap.set(a, b), this.size = this.backingMap.size;\n  } else {\n    for (var c = 0; c < this._entries.length; c += 2) {\n      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {\n        this._entries[c + 1] = b;\n        return;\n      }\n    }\n    this._entries.push(a);\n    this._entries.push(b);\n    this.size++;\n    this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);\n  }\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;\ncom.cognitect.transit.types.TransitArrayMap.prototype[\"delete\"] = function(a) {\n  this.hashCode = -1;\n  if (this.backingMap) {\n    return a = this.backingMap[\"delete\"](a), this.size = this.backingMap.size, a;\n  }\n  for (var b = 0; b < this._entries.length; b += 2) {\n    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {\n      return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;\n    }\n  }\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {\n  var a = com.cognitect.transit.types.map();\n  this.forEach(function(b, c) {\n    a.set(c, b);\n  });\n  return a;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;\ncom.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {\n  return this.entries();\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {\n  if (this.backingMap) {\n    return this.backingMap.com$cognitect$transit$hashCode();\n  }\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a) {\n  return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);\n};\ncom.cognitect.transit.types.TransitMap = function(a, b, c) {\n  this.map = b || {};\n  this._keys = a || [];\n  this.size = c || 0;\n  this.hashCode = -1;\n};\ncom.cognitect.transit.types.TransitMap.prototype.toString = function() {\n  return com.cognitect.transit.types.printMap(this);\n};\ncom.cognitect.transit.types.TransitMap.prototype.inspect = function() {\n  return this.toString();\n};\ncom.cognitect.transit.types.TransitMap.prototype.clear = function() {\n  this.hashCode = -1;\n  this.map = {};\n  this._keys = [];\n  this.size = 0;\n};\ncom.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;\ncom.cognitect.transit.types.TransitMap.prototype.getKeys = function() {\n  return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);\n};\ncom.cognitect.transit.types.TransitMap.prototype[\"delete\"] = function(a) {\n  this.hashCode = -1;\n  this._keys = null;\n  for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0; d < c.length; d += 2) {\n    if (com.cognitect.transit.eq.equals(a, c[d])) {\n      return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;\n    }\n  }\n};\ncom.cognitect.transit.types.TransitMap.prototype.entries = function() {\n  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);\n};\ncom.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;\ncom.cognitect.transit.types.TransitMap.prototype.forEach = function(a) {\n  for (var b = this.getKeys(), c = 0; c < b.length; c++) {\n    for (var d = this.map[b[c]], e = 0; e < d.length; e += 2) {\n      a(d[e + 1], d[e], this);\n    }\n  }\n};\ncom.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;\ncom.cognitect.transit.types.TransitMap.prototype.get = function(a, b) {\n  var c = com.cognitect.transit.eq.hashCode(a), c = this.map[c];\n  if (null != c) {\n    for (var d = 0; d < c.length; d += 2) {\n      if (com.cognitect.transit.eq.equals(a, c[d])) {\n        return c[d + 1];\n      }\n    }\n  } else {\n    return b;\n  }\n};\ncom.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;\ncom.cognitect.transit.types.TransitMap.prototype.has = function(a) {\n  var b = com.cognitect.transit.eq.hashCode(a), b = this.map[b];\n  if (null != b) {\n    for (var c = 0; c < b.length; c += 2) {\n      if (com.cognitect.transit.eq.equals(a, b[c])) {\n        return !0;\n      }\n    }\n  }\n  return !1;\n};\ncom.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;\ncom.cognitect.transit.types.TransitMap.prototype.keys = function() {\n  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);\n};\ncom.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;\ncom.cognitect.transit.types.TransitMap.prototype.keySet = function() {\n  for (var a = this.getKeys(), b = [], c = 0; c < a.length; c++) {\n    for (var d = this.map[a[c]], e = 0; e < d.length; e += 2) {\n      b.push(d[e]);\n    }\n  }\n  return b;\n};\ncom.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;\ncom.cognitect.transit.types.TransitMap.prototype.set = function(a, b) {\n  this.hashCode = -1;\n  var c = com.cognitect.transit.eq.hashCode(a), d = this.map[c];\n  if (null == d) {\n    this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;\n  } else {\n    for (var c = !0, e = 0; e < d.length; e += 2) {\n      if (com.cognitect.transit.eq.equals(b, d[e])) {\n        c = !1;\n        d[e] = b;\n        break;\n      }\n    }\n    c && (d.push(a), d.push(b), this.size++);\n  }\n};\ncom.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;\ncom.cognitect.transit.types.TransitMap.prototype.values = function() {\n  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);\n};\ncom.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;\ncom.cognitect.transit.types.TransitMap.prototype.clone = function() {\n  var a = com.cognitect.transit.types.map();\n  this.forEach(function(b, c) {\n    a.set(c, b);\n  });\n  return a;\n};\ncom.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;\ncom.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {\n  return this.entries();\n};\ncom.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {\n  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));\n  return this.hashCode;\n};\ncom.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a) {\n  return com.cognitect.transit.types.mapEquals(this, a);\n};\ncom.cognitect.transit.types.map = function(a, b, c) {\n  a = a || [];\n  b = !1 === b ? b : !0;\n  if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {\n    if (b) {\n      var d = a;\n      a = [];\n      for (b = 0; b < d.length; b += 2) {\n        var e = !1;\n        for (c = 0; c < a.length; c += 2) {\n          if (com.cognitect.transit.eq.equals(a[c], d[b])) {\n            a[c + 1] = d[b + 1];\n            e = !0;\n            break;\n          }\n        }\n        e || (a.push(d[b]), a.push(d[b + 1]));\n      }\n    }\n    return new com.cognitect.transit.types.TransitArrayMap(a);\n  }\n  var d = {}, e = [], f = 0;\n  for (b = 0; b < a.length; b += 2) {\n    c = com.cognitect.transit.eq.hashCode(a[b]);\n    var g = d[c];\n    if (null == g) {\n      e.push(c), d[c] = [a[b], a[b + 1]], f++;\n    } else {\n      var h = !0;\n      for (c = 0; c < g.length; c += 2) {\n        if (com.cognitect.transit.eq.equals(g[c], a[b])) {\n          g[c + 1] = a[b + 1];\n          h = !1;\n          break;\n        }\n      }\n      h && (g.push(a[b]), g.push(a[b + 1]), f++);\n    }\n  }\n  return new com.cognitect.transit.types.TransitMap(e, d, f);\n};\ncom.cognitect.transit.types.isArrayMap = function(a) {\n  return a instanceof com.cognitect.transit.types.TransitArrayMap;\n};\ncom.cognitect.transit.types.isMap = function(a) {\n  return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;\n};\ncom.cognitect.transit.types.TransitSet = function(a) {\n  this.map = a;\n  this.size = a.size;\n};\ncom.cognitect.transit.types.TransitSet.prototype.toString = function() {\n  return com.cognitect.transit.types.printSet(this);\n};\ncom.cognitect.transit.types.TransitSet.prototype.inspect = function() {\n  return this.toString();\n};\ncom.cognitect.transit.types.TransitSet.prototype.add = function(a) {\n  this.map.set(a, a);\n  this.size = this.map.size;\n};\ncom.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;\ncom.cognitect.transit.types.TransitSet.prototype.clear = function() {\n  this.map = new com.cognitect.transit.types.TransitMap;\n  this.size = 0;\n};\ncom.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;\ncom.cognitect.transit.types.TransitSet.prototype[\"delete\"] = function(a) {\n  a = this.map[\"delete\"](a);\n  this.size = this.map.size;\n  return a;\n};\ncom.cognitect.transit.types.TransitSet.prototype.entries = function() {\n  return this.map.entries();\n};\ncom.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;\ncom.cognitect.transit.types.TransitSet.prototype.forEach = function(a, b) {\n  var c = this;\n  this.map.forEach(function(b, e, f) {\n    a(e, c);\n  });\n};\ncom.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;\ncom.cognitect.transit.types.TransitSet.prototype.has = function(a) {\n  return this.map.has(a);\n};\ncom.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;\ncom.cognitect.transit.types.TransitSet.prototype.keys = function() {\n  return this.map.keys();\n};\ncom.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;\ncom.cognitect.transit.types.TransitSet.prototype.keySet = function() {\n  return this.map.keySet();\n};\ncom.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;\ncom.cognitect.transit.types.TransitSet.prototype.values = function() {\n  return this.map.values();\n};\ncom.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;\ncom.cognitect.transit.types.TransitSet.prototype.clone = function() {\n  var a = com.cognitect.transit.types.set();\n  this.forEach(function(b) {\n    a.add(b);\n  });\n  return a;\n};\ncom.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;\ncom.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {\n  return this.values();\n};\ncom.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a) {\n  if (a instanceof com.cognitect.transit.types.TransitSet) {\n    if (this.size === a.size) {\n      return com.cognitect.transit.eq.equals(this.map, a.map);\n    }\n  } else {\n    return !1;\n  }\n};\ncom.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a) {\n  return com.cognitect.transit.eq.hashCode(this.map);\n};\ncom.cognitect.transit.types.set = function(a) {\n  a = a || [];\n  for (var b = {}, c = [], d = 0, e = 0; e < a.length; e++) {\n    var f = com.cognitect.transit.eq.hashCode(a[e]), g = b[f];\n    if (null == g) {\n      c.push(f), b[f] = [a[e], a[e]], d++;\n    } else {\n      for (var f = !0, h = 0; h < g.length; h += 2) {\n        if (com.cognitect.transit.eq.equals(g[h], a[e])) {\n          f = !1;\n          break;\n        }\n      }\n      f && (g.push(a[e]), g.push(a[e]), d++);\n    }\n  }\n  return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));\n};\ncom.cognitect.transit.types.isSet = function(a) {\n  return a instanceof com.cognitect.transit.types.TransitSet;\n};\ncom.cognitect.transit.types.quoted = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"'\", a);\n};\ncom.cognitect.transit.types.isQuoted = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"'\" === a.tag;\n};\ncom.cognitect.transit.types.list = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"list\", a);\n};\ncom.cognitect.transit.types.isList = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"list\" === a.tag;\n};\ncom.cognitect.transit.types.link = function(a) {\n  return com.cognitect.transit.types.taggedValue(\"link\", a);\n};\ncom.cognitect.transit.types.isLink = function(a) {\n  return a instanceof com.cognitect.transit.types.TaggedValue && \"link\" === a.tag;\n};\ncom.cognitect.transit.types.specialDouble = function(a) {\n  switch(a) {\n    case \"-INF\":\n      return -Infinity;\n    case \"INF\":\n      return Infinity;\n    case \"NaN\":\n      return NaN;\n    default:\n      throw Error(\"Invalid special double value \" + a);\n  }\n};\ncom.cognitect.transit.handlers = {};\ncom.cognitect.transit.handlers.ctorGuid = 0;\ncom.cognitect.transit.handlers.ctorGuidProperty = \"transit$guid$\" + com.cognitect.transit.util.randomUUID();\ncom.cognitect.transit.handlers.typeTag = function(a) {\n  if (null == a) {\n    return \"null\";\n  }\n  if (a === String) {\n    return \"string\";\n  }\n  if (a === Boolean) {\n    return \"boolean\";\n  }\n  if (a === Number) {\n    return \"number\";\n  }\n  if (a === Array) {\n    return \"array\";\n  }\n  if (a === Object) {\n    return \"map\";\n  }\n  var b = a[com.cognitect.transit.handlers.ctorGuidProperty];\n  null == b && (\"undefined\" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, {value:b, enumerable:!1})) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);\n  return b;\n};\ncom.cognitect.transit.handlers.constructor = function(a) {\n  return null == a ? null : a.constructor;\n};\ncom.cognitect.transit.handlers.padZeros = function(a, b) {\n  for (var c = a.toString(), d = c.length; d < b; d++) {\n    c = \"0\" + c;\n  }\n  return c;\n};\ncom.cognitect.transit.handlers.stringableKeys = function(a) {\n  a = com.cognitect.transit.util.objectKeys(a);\n  for (var b = 0; b < a.length; b++) {\n  }\n  return !0;\n};\ncom.cognitect.transit.handlers.NilHandler = function() {\n};\ncom.cognitect.transit.handlers.NilHandler.prototype.tag = function(a) {\n  return \"_\";\n};\ncom.cognitect.transit.handlers.NilHandler.prototype.rep = function(a) {\n  return null;\n};\ncom.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a) {\n  return \"null\";\n};\ncom.cognitect.transit.handlers.StringHandler = function() {\n};\ncom.cognitect.transit.handlers.StringHandler.prototype.tag = function(a) {\n  return \"s\";\n};\ncom.cognitect.transit.handlers.StringHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.NumberHandler = function() {\n};\ncom.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a) {\n  return \"i\";\n};\ncom.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.IntegerHandler = function() {\n};\ncom.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a) {\n  return \"i\";\n};\ncom.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.BooleanHandler = function() {\n};\ncom.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a) {\n  return \"?\";\n};\ncom.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.ArrayHandler = function() {\n};\ncom.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a) {\n  return \"array\";\n};\ncom.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a) {\n  return null;\n};\ncom.cognitect.transit.handlers.MapHandler = function() {\n};\ncom.cognitect.transit.handlers.MapHandler.prototype.tag = function(a) {\n  return \"map\";\n};\ncom.cognitect.transit.handlers.MapHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a) {\n  return null;\n};\ncom.cognitect.transit.handlers.VerboseDateHandler = function() {\n};\ncom.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a) {\n  return \"t\";\n};\ncom.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a) {\n  return a.getUTCFullYear() + \"-\" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + \"-\" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + \"T\" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + \":\" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + \":\" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + \".\" + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + \"Z\";\n};\ncom.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a, b) {\n  return b.rep(a);\n};\ncom.cognitect.transit.handlers.DateHandler = function() {\n};\ncom.cognitect.transit.handlers.DateHandler.prototype.tag = function(a) {\n  return \"m\";\n};\ncom.cognitect.transit.handlers.DateHandler.prototype.rep = function(a) {\n  return a.valueOf();\n};\ncom.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a) {\n  return a.valueOf().toString();\n};\ncom.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a) {\n  return new com.cognitect.transit.handlers.VerboseDateHandler;\n};\ncom.cognitect.transit.handlers.UUIDHandler = function() {\n};\ncom.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a) {\n  return \"u\";\n};\ncom.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a) {\n  return a.toString();\n};\ncom.cognitect.transit.handlers.KeywordHandler = function() {\n};\ncom.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a) {\n  return \":\";\n};\ncom.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a) {\n  return a._name;\n};\ncom.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a, b) {\n  return b.rep(a);\n};\ncom.cognitect.transit.handlers.SymbolHandler = function() {\n};\ncom.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a) {\n  return \"$\";\n};\ncom.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a) {\n  return a._name;\n};\ncom.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a, b) {\n  return b.rep(a);\n};\ncom.cognitect.transit.handlers.TaggedHandler = function() {\n};\ncom.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a) {\n  return a.tag;\n};\ncom.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a) {\n  return a.rep;\n};\ncom.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.TransitSetHandler = function() {\n};\ncom.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a) {\n  return \"set\";\n};\ncom.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a) {\n  var b = [];\n  a.forEach(function(a, d) {\n    b.push(a);\n  });\n  return com.cognitect.transit.types.taggedValue(\"array\", b);\n};\ncom.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.TransitArrayMapHandler = function() {\n};\ncom.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a) {\n  return \"map\";\n};\ncom.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.TransitMapHandler = function() {\n};\ncom.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a) {\n  return \"map\";\n};\ncom.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a) {\n  return a;\n};\ncom.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.BufferHandler = function() {\n};\ncom.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a) {\n  return \"b\";\n};\ncom.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a) {\n  return a.toString(\"base64\");\n};\ncom.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.Uint8ArrayHandler = function() {\n};\ncom.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a) {\n  return \"b\";\n};\ncom.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a) {\n  return com.cognitect.transit.util.Uint8ToBase64(a);\n};\ncom.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a, b) {\n  return null;\n};\ncom.cognitect.transit.handlers.defaultHandlers = function(a) {\n  a.set(null, new com.cognitect.transit.handlers.NilHandler);\n  a.set(String, new com.cognitect.transit.handlers.StringHandler);\n  a.set(Number, new com.cognitect.transit.handlers.NumberHandler);\n  a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler);\n  a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler);\n  a.set(Array, new com.cognitect.transit.handlers.ArrayHandler);\n  a.set(Object, new com.cognitect.transit.handlers.MapHandler);\n  a.set(Date, new com.cognitect.transit.handlers.DateHandler);\n  a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler);\n  a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler);\n  a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler);\n  a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler);\n  a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler);\n  a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler);\n  a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler);\n  \"undefined\" != typeof goog.global.Buffer && a.set(goog.global.Buffer, new com.cognitect.transit.handlers.BufferHandler);\n  \"undefined\" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler);\n  return a;\n};\ncom.cognitect.transit.handlers.Handlers = function() {\n  this.handlers = {};\n  com.cognitect.transit.handlers.defaultHandlers(this);\n};\ncom.cognitect.transit.handlers.Handlers.prototype.get = function(a) {\n  a = \"string\" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];\n  return null != a ? a : this.handlers[\"default\"];\n};\ncom.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;\ncom.cognitect.transit.handlers.validTag = function(a) {\n  switch(a) {\n    case \"null\":\n    case \"string\":\n    case \"boolean\":\n    case \"number\":\n    case \"array\":\n    case \"map\":\n      return !1;\n  }\n  return !0;\n};\ncom.cognitect.transit.handlers.Handlers.prototype.set = function(a, b) {\n  \"string\" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;\n};\ncom.cognitect.transit.impl = {};\ncom.cognitect.transit.impl.decoder = {};\ncom.cognitect.transit.impl.decoder.Tag = function(a) {\n  this.str = a;\n};\ncom.cognitect.transit.impl.decoder.tag = function(a) {\n  return new com.cognitect.transit.impl.decoder.Tag(a);\n};\ncom.cognitect.transit.impl.decoder.isTag = function(a) {\n  return a && a instanceof com.cognitect.transit.impl.decoder.Tag;\n};\ncom.cognitect.transit.impl.decoder.isGroundHandler = function(a) {\n  switch(a) {\n    case \"_\":\n    case \"s\":\n    case \"?\":\n    case \"i\":\n    case \"d\":\n    case \"b\":\n    case \"'\":\n    case \"array\":\n    case \"map\":\n      return !0;\n  }\n  return !1;\n};\ncom.cognitect.transit.impl.decoder.Decoder = function(a) {\n  this.options = a || {};\n  this.handlers = {};\n  for (var b in this.defaults.handlers) {\n    this.handlers[b] = this.defaults.handlers[b];\n  }\n  for (b in this.options.handlers) {\n    if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {\n      throw Error('Cannot override handler for ground type \"' + b + '\"');\n    }\n    this.handlers[b] = this.options.handlers[b];\n  }\n  this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;\n  this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;\n  this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;\n  this.mapBuilder = this.options.mapBuilder;\n  this.arrayBuilder = this.options.arrayBuilder;\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.defaults = {handlers:{_:function(a, b) {\n  return com.cognitect.transit.types.nullValue();\n}, \"?\":function(a, b) {\n  return com.cognitect.transit.types.boolValue(a);\n}, b:function(a, b) {\n  return com.cognitect.transit.types.binary(a, b);\n}, i:function(a, b) {\n  return com.cognitect.transit.types.intValue(a);\n}, n:function(a, b) {\n  return com.cognitect.transit.types.bigInteger(a);\n}, d:function(a, b) {\n  return com.cognitect.transit.types.floatValue(a);\n}, f:function(a, b) {\n  return com.cognitect.transit.types.bigDecimalValue(a);\n}, c:function(a, b) {\n  return com.cognitect.transit.types.charValue(a);\n}, \":\":function(a, b) {\n  return com.cognitect.transit.types.keyword(a);\n}, $:function(a, b) {\n  return com.cognitect.transit.types.symbol(a);\n}, r:function(a, b) {\n  return com.cognitect.transit.types.uri(a);\n}, z:function(a, b) {\n  return com.cognitect.transit.types.specialDouble(a);\n}, \"'\":function(a, b) {\n  return a;\n}, m:function(a, b) {\n  return com.cognitect.transit.types.date(a);\n}, t:function(a, b) {\n  return com.cognitect.transit.types.verboseDate(a);\n}, u:function(a, b) {\n  return com.cognitect.transit.types.uuid(a);\n}, set:function(a, b) {\n  return com.cognitect.transit.types.set(a);\n}, list:function(a, b) {\n  return com.cognitect.transit.types.list(a);\n}, link:function(a, b) {\n  return com.cognitect.transit.types.link(a);\n}, cmap:function(a, b) {\n  return com.cognitect.transit.types.map(a, !1);\n}}, defaultHandler:function(a, b) {\n  return com.cognitect.transit.types.taggedValue(a, b);\n}, preferStrings:!0, preferBuffers:!0};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a, b, c, d) {\n  if (null == a) {\n    return null;\n  }\n  switch(typeof a) {\n    case \"string\":\n      return this.decodeString(a, b, c, d);\n    case \"object\":\n      return com.cognitect.transit.util.isArray(a) ? \"^ \" === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);\n  }\n  return a;\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a, b, c, d) {\n  return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a, b, c, d) {\n  c = com.cognitect.transit.util.objectKeys(a);\n  var e = c[0];\n  d = 1 == c.length ? this.decode(e, b, !1, !1) : null;\n  if (com.cognitect.transit.impl.decoder.isTag(d)) {\n    return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));\n  }\n  if (this.mapBuilder) {\n    if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {\n      var f = [];\n      for (e = 0; e < c.length; e++) {\n        d = c[e], f.push(this.decode(d, b, !0, !1)), f.push(this.decode(a[d], b, !1, !1));\n      }\n      return this.mapBuilder.fromArray(f, a);\n    }\n    f = this.mapBuilder.init(a);\n    for (e = 0; e < c.length; e++) {\n      d = c[e], f = this.mapBuilder.add(f, this.decode(d, b, !0, !1), this.decode(a[d], b, !1, !1), a);\n    }\n    return this.mapBuilder.finalize(f, a);\n  }\n  f = [];\n  for (e = 0; e < c.length; e++) {\n    d = c[e], f.push(this.decode(d, b, !0, !1)), f.push(this.decode(a[d], b, !1, !1));\n  }\n  return com.cognitect.transit.types.map(f, !1);\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a, b, c, d) {\n  if (this.mapBuilder) {\n    if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {\n      d = [];\n      for (c = 1; c < a.length; c += 2) {\n        d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));\n      }\n      return this.mapBuilder.fromArray(d, a);\n    }\n    d = this.mapBuilder.init(a);\n    for (c = 1; c < a.length; c += 2) {\n      d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);\n    }\n    return this.mapBuilder.finalize(d, a);\n  }\n  d = [];\n  for (c = 1; c < a.length; c += 2) {\n    d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));\n  }\n  return com.cognitect.transit.types.map(d, !1);\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a, b, c, d) {\n  if (d) {\n    var e = [];\n    for (d = 0; d < a.length; d++) {\n      e.push(this.decode(a[d], b, c, !1));\n    }\n    return e;\n  }\n  e = b && b.idx;\n  if (2 === a.length && \"string\" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {\n    return e = a[1], a = this.handlers[d.str], null != a ? e = a(this.decode(e, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(e, b, c, !1));\n  }\n  b && e != b.idx && (b.idx = e);\n  if (this.arrayBuilder) {\n    if (32 >= a.length && this.arrayBuilder.fromArray) {\n      e = [];\n      for (d = 0; d < a.length; d++) {\n        e.push(this.decode(a[d], b, c, !1));\n      }\n      return this.arrayBuilder.fromArray(e, a);\n    }\n    e = this.arrayBuilder.init(a);\n    for (d = 0; d < a.length; d++) {\n      e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);\n    }\n    return this.arrayBuilder.finalize(e, a);\n  }\n  e = [];\n  for (d = 0; d < a.length; d++) {\n    e.push(this.decode(a[d], b, c, !1));\n  }\n  return e;\n};\ncom.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a, b, c) {\n  if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {\n    b = a.charAt(1);\n    if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {\n      return a.substring(1);\n    }\n    if (b === com.cognitect.transit.delimiters.TAG) {\n      return com.cognitect.transit.impl.decoder.tag(a.substring(2));\n    }\n    c = this.handlers[b];\n    return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);\n  }\n  return a;\n};\ncom.cognitect.transit.impl.decoder.decoder = function(a) {\n  return new com.cognitect.transit.impl.decoder.Decoder(a);\n};\ncom.cognitect.transit.impl.reader = {};\ncom.cognitect.transit.impl.reader.JSONUnmarshaller = function(a) {\n  this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);\n};\ncom.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a, b) {\n  return this.decoder.decode(JSON.parse(a), b);\n};\ncom.cognitect.transit.impl.reader.Reader = function(a, b) {\n  this.unmarshaller = a;\n  this.options = b || {};\n  this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache;\n};\ncom.cognitect.transit.impl.reader.Reader.prototype.read = function(a) {\n  a = this.unmarshaller.unmarshal(a, this.cache);\n  this.cache.clear();\n  return a;\n};\ncom.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;\ncom.cognitect.transit.impl.writer = {};\ncom.cognitect.transit.impl.writer.escape = function(a) {\n  if (0 < a.length) {\n    var b = a.charAt(0);\n    return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;\n  }\n  return a;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller = function(a) {\n  this.opts = a || {};\n  this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;\n  this.objectBuilder = this.opts.objectBuilder || null;\n  this.transform = this.opts.transform || null;\n  this.handlers = new com.cognitect.transit.handlers.Handlers;\n  if (a = this.opts.handlers) {\n    if (com.cognitect.transit.util.isArray(a) || !a.forEach) {\n      throw Error('transit writer \"handlers\" option must be a map');\n    }\n    var b = this;\n    a.forEach(function(a, d) {\n      if (void 0 !== d) {\n        b.handlers.set(d, a);\n      } else {\n        throw Error(\"Cannot create handler for JavaScript undefined\");\n      }\n    });\n  }\n  this.handlerForForeign = this.opts.handlerForForeign;\n  this.unpack = this.opts.unpack || function(a) {\n    return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;\n  };\n  this.verbose = this.opts && this.opts.verbose || !1;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a) {\n  var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));\n  return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a, b) {\n  this.handlers.set(a, b);\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a, b) {\n  return a ? this.emitString(com.cognitect.transit.delimiters.ESC, \"_\", \"\", a, b) : null;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a, b, c, d, e) {\n  a = a + b + c;\n  return e ? e.write(a, d) : a;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a, b, c) {\n  return b ? this.emitString(com.cognitect.transit.delimiters.ESC, \"?\", a.toString()[0], b, c) : a;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a, b, c) {\n  return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, \"z\", \"INF\", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, \"z\", \"-INF\", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, \"z\", \"NaN\", b, c) : b || \"string\" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, \"i\", a.toString(), b, c) : a;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a, b, c) {\n  return b ? this.emitString(a.ESC, \"d\", a, b, c) : a;\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a, b, c) {\n  return this.emitString(com.cognitect.transit.delimiters.ESC, \"b\", a, b, c);\n};\ncom.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a, b, c) {\n  if (a.verbose) {\n    a = {};\n    var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, \"'\", \"\", !0, c);\n    a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);\n    return a;\n  }\n  return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, \"'\", \"\", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];\n};\ncom.cognitect.transit.impl.writer.emitObjects = function(a, b, c) {\n  var d = [];\n  if (com.cognitect.transit.util.isArray(b)) {\n    for (var e = 0; e < b.length; e++) {\n      d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));\n    }\n  } else {\n    b.forEach(function(b, e) {\n      d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));\n    });\n  }\n  return d;\n};\ncom.cognitect.transit.impl.writer.emitArray = function(a, b, c, d) {\n  return com.cognitect.transit.impl.writer.emitObjects(a, b, d);\n};\ncom.cognitect.transit.impl.writer.isStringableKey = function(a, b) {\n  if (\"string\" !== typeof b) {\n    var c = a.handler(b);\n    return c && 1 === c.tag(b).length;\n  }\n  return !0;\n};\ncom.cognitect.transit.impl.writer.stringableKeys = function(a, b) {\n  var c = a.unpack(b), d = !0;\n  if (c) {\n    for (var e = 0; e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d); e += 2) {\n    }\n    return d;\n  }\n  if (b.keys && (c = b.keys(), e = null, c.next)) {\n    for (e = c.next(); !e.done;) {\n      d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);\n      if (!d) {\n        break;\n      }\n      e = c.next();\n    }\n    return d;\n  }\n  if (b.forEach) {\n    return b.forEach(function(b, c) {\n      d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);\n    }), d;\n  }\n  throw Error(\"Cannot walk keys of object type \" + com.cognitect.transit.handlers.constructor(b).name);\n};\ncom.cognitect.transit.impl.writer.isForeignObject = function(a) {\n  if (a.constructor.transit$isObject) {\n    return !0;\n  }\n  var b = a.constructor.toString(), b = b.substr(9), b = b.substr(0, b.indexOf(\"(\")), b = \"Object\" == b;\n  \"undefined\" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, \"transit$isObject\", {value:b, enumerable:!1}) : a.constructor.transit$isObject = b;\n  return b;\n};\ncom.cognitect.transit.impl.writer.emitMap = function(a, b, c, d) {\n  var e = null, f = null, g = null, e = null;\n  c = 0;\n  if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {\n    if (a.verbose) {\n      if (null != b.forEach) {\n        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {\n          var h = {};\n          b.forEach(function(b, c) {\n            h[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);\n          });\n        } else {\n          e = a.unpack(b);\n          f = [];\n          g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, \"cmap\", \"\", !0, d);\n          if (e) {\n            for (; c < e.length; c += 2) {\n              f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, !1)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));\n            }\n          } else {\n            b.forEach(function(b, c) {\n              f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, !1));\n              f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));\n            });\n          }\n          h = {};\n          h[g] = f;\n        }\n      } else {\n        for (e = com.cognitect.transit.util.objectKeys(b), h = {}; c < e.length; c++) {\n          h[com.cognitect.transit.impl.writer.marshal(a, e[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d);\n        }\n      }\n      return h;\n    }\n    if (null != b.forEach) {\n      if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {\n        e = a.unpack(b);\n        h = [\"^ \"];\n        if (e) {\n          for (; c < e.length; c += 2) {\n            h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));\n          }\n        } else {\n          b.forEach(function(b, c) {\n            h.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));\n            h.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));\n          });\n        }\n        return h;\n      }\n      e = a.unpack(b);\n      f = [];\n      g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, \"cmap\", \"\", !0, d);\n      if (e) {\n        for (; c < e.length; c += 2) {\n          f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, d)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));\n        }\n      } else {\n        b.forEach(function(b, c) {\n          f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, d));\n          f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));\n        });\n      }\n      return [g, f];\n    }\n    h = [\"^ \"];\n    for (e = com.cognitect.transit.util.objectKeys(b); c < e.length; c++) {\n      h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d));\n    }\n    return h;\n  }\n  if (null != a.objectBuilder) {\n    return a.objectBuilder(b, function(b) {\n      return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);\n    }, function(b) {\n      return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);\n    });\n  }\n  c = com.cognitect.transit.handlers.constructor(b).name;\n  e = Error(\"Cannot write \" + c);\n  e.data = {obj:b, type:c};\n  throw e;\n};\ncom.cognitect.transit.impl.writer.emitTaggedMap = function(a, b, c, d, e) {\n  return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, \"\", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, \"\", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];\n};\ncom.cognitect.transit.impl.writer.emitEncoded = function(a, b, c, d, e, f, g) {\n  if (1 === c.length) {\n    if (\"string\" === typeof d) {\n      return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);\n    }\n    if (f || a.preferStrings) {\n      (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);\n      if (null !== d) {\n        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);\n      }\n      a = Error('Tag \"' + c + '\" cannot be encoded as string');\n      a.data = {tag:c, rep:d, obj:e};\n      throw a;\n    }\n  }\n  return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);\n};\ncom.cognitect.transit.impl.writer.marshal = function(a, b, c, d) {\n  null !== a.transform && (b = a.transform(b));\n  var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null), f = e ? e.tag(b) : null, g = e ? e.rep(b) : null;\n  if (null != e && null != f) {\n    switch(f) {\n      case \"_\":\n        return a.emitNil(c, d);\n      case \"s\":\n        return a.emitString(\"\", \"\", com.cognitect.transit.impl.writer.escape(g), c, d);\n      case \"?\":\n        return a.emitBoolean(g, c, d);\n      case \"i\":\n        return a.emitInteger(g, c, d);\n      case \"d\":\n        return a.emitDouble(g, c, d);\n      case \"b\":\n        return a.emitBinary(g, c, d);\n      case \"'\":\n        return a.emitQuoted(a, g, d);\n      case \"array\":\n        return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);\n      case \"map\":\n        return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);\n      default:\n        return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);\n    }\n  } else {\n    throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error(\"Cannot write \" + a), c.data = {obj:b, type:a}, c;\n  }\n};\ncom.cognitect.transit.impl.writer.maybeQuoted = function(a, b) {\n  var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);\n  if (null != c) {\n    return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;\n  }\n  var c = com.cognitect.transit.handlers.constructor(b).name, d = Error(\"Cannot write \" + c);\n  d.data = {obj:b, type:c};\n  throw d;\n};\ncom.cognitect.transit.impl.writer.marshalTop = function(a, b, c, d) {\n  return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));\n};\ncom.cognitect.transit.impl.writer.Writer = function(a, b) {\n  this._marshaller = a;\n  this.options = b || {};\n  this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache;\n};\ncom.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {\n  return this._marshaller;\n};\ncom.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;\ncom.cognitect.transit.impl.writer.Writer.prototype.write = function(a, b) {\n  var c = b || {};\n  var d = c.asMapKey || !1, e = this._marshaller.verbose ? !1 : this.cache;\n  c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);\n  null != this.cache && this.cache.clear();\n  return c;\n};\ncom.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;\ncom.cognitect.transit.impl.writer.Writer.prototype.register = function(a, b) {\n  this._marshaller.registerHandler(a, b);\n};\ncom.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;\nvar TRANSIT_DEV = !0, TRANSIT_NODE_TARGET = !0, TRANSIT_BROWSER_TARGET = !1, TRANSIT_BROWSER_AMD_TARGET = !1;\ncom.cognitect.transit.reader = function(a, b) {\n  if (\"json\" === a || \"json-verbose\" === a || null == a) {\n    var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);\n    return new com.cognitect.transit.impl.reader.Reader(c, b);\n  }\n  throw Error(\"Cannot create reader of type \" + a);\n};\ncom.cognitect.transit.writer = function(a, b) {\n  if (\"json\" === a || \"json-verbose\" === a || null == a) {\n    \"json-verbose\" === a && (null == b && (b = {}), b.verbose = !0);\n    var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);\n    return new com.cognitect.transit.impl.writer.Writer(c, b);\n  }\n  c = Error('Type must be \"json\"');\n  c.data = {type:a};\n  throw c;\n};\ncom.cognitect.transit.makeWriteHandler = function(a) {\n  var b = function() {\n  };\n  b.prototype.tag = a.tag;\n  b.prototype.rep = a.rep;\n  b.prototype.stringRep = a.stringRep;\n  b.prototype.getVerboseHandler = a.getVerboseHandler;\n  return new b;\n};\ncom.cognitect.transit.makeBuilder = function(a) {\n  var b = function() {\n  };\n  b.prototype.init = a.init;\n  b.prototype.add = a.add;\n  b.prototype.finalize = a.finalize;\n  b.prototype.fromArray = a.fromArray;\n  return new b;\n};\ncom.cognitect.transit.date = com.cognitect.transit.types.date;\ncom.cognitect.transit.integer = com.cognitect.transit.types.intValue;\ncom.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;\ncom.cognitect.transit.uuid = com.cognitect.transit.types.uuid;\ncom.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;\ncom.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;\ncom.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;\ncom.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;\ncom.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;\ncom.cognitect.transit.keyword = com.cognitect.transit.types.keyword;\ncom.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;\ncom.cognitect.transit.symbol = com.cognitect.transit.types.symbol;\ncom.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;\ncom.cognitect.transit.binary = com.cognitect.transit.types.binary;\ncom.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;\ncom.cognitect.transit.uri = com.cognitect.transit.types.uri;\ncom.cognitect.transit.isURI = com.cognitect.transit.types.isURI;\ncom.cognitect.transit.map = com.cognitect.transit.types.map;\ncom.cognitect.transit.isMap = com.cognitect.transit.types.isMap;\ncom.cognitect.transit.set = com.cognitect.transit.types.set;\ncom.cognitect.transit.isSet = com.cognitect.transit.types.isSet;\ncom.cognitect.transit.list = com.cognitect.transit.types.list;\ncom.cognitect.transit.isList = com.cognitect.transit.types.isList;\ncom.cognitect.transit.quoted = com.cognitect.transit.types.quoted;\ncom.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;\ncom.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;\ncom.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;\ncom.cognitect.transit.link = com.cognitect.transit.types.link;\ncom.cognitect.transit.isLink = com.cognitect.transit.types.isLink;\ncom.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;\ncom.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;\ncom.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;\ncom.cognitect.transit.equals = com.cognitect.transit.eq.equals;\ncom.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;\ncom.cognitect.transit.mapToObject = function(a) {\n  var b = {};\n  a.forEach(function(a, d) {\n    if (\"string\" !== typeof d) {\n      throw Error(\"Cannot convert map with non-string keys\");\n    }\n    b[d] = a;\n  });\n  return b;\n};\ncom.cognitect.transit.objectToMap = function(a) {\n  var b = com.cognitect.transit.map(), c;\n  for (c in a) {\n    a.hasOwnProperty(c) && b.set(c, a[c]);\n  }\n  return b;\n};\ncom.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;\ncom.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;\ncom.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;\ncom.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;\ncom.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;\ncom.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;\nTRANSIT_BROWSER_TARGET && (goog.exportSymbol(\"transit.reader\", com.cognitect.transit.reader), goog.exportSymbol(\"transit.writer\", com.cognitect.transit.writer), goog.exportSymbol(\"transit.makeBuilder\", com.cognitect.transit.makeBuilder), goog.exportSymbol(\"transit.makeWriteHandler\", com.cognitect.transit.makeWriteHandler), goog.exportSymbol(\"transit.date\", com.cognitect.transit.types.date), goog.exportSymbol(\"transit.integer\", com.cognitect.transit.types.intValue), goog.exportSymbol(\"transit.isInteger\", \ncom.cognitect.transit.types.isInteger), goog.exportSymbol(\"transit.uuid\", com.cognitect.transit.types.uuid), goog.exportSymbol(\"transit.isUUID\", com.cognitect.transit.types.isUUID), goog.exportSymbol(\"transit.bigInt\", com.cognitect.transit.types.bigInteger), goog.exportSymbol(\"transit.isBigInt\", com.cognitect.transit.types.isBigInteger), goog.exportSymbol(\"transit.bigDec\", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol(\"transit.isBigDec\", com.cognitect.transit.types.isBigDecimal), \ngoog.exportSymbol(\"transit.keyword\", com.cognitect.transit.types.keyword), goog.exportSymbol(\"transit.isKeyword\", com.cognitect.transit.types.isKeyword), goog.exportSymbol(\"transit.symbol\", com.cognitect.transit.types.symbol), goog.exportSymbol(\"transit.isSymbol\", com.cognitect.transit.types.isSymbol), goog.exportSymbol(\"transit.binary\", com.cognitect.transit.types.binary), goog.exportSymbol(\"transit.isBinary\", com.cognitect.transit.types.isBinary), goog.exportSymbol(\"transit.uri\", com.cognitect.transit.types.uri), \ngoog.exportSymbol(\"transit.isURI\", com.cognitect.transit.types.isURI), goog.exportSymbol(\"transit.map\", com.cognitect.transit.types.map), goog.exportSymbol(\"transit.isMap\", com.cognitect.transit.types.isMap), goog.exportSymbol(\"transit.set\", com.cognitect.transit.types.set), goog.exportSymbol(\"transit.isSet\", com.cognitect.transit.types.isSet), goog.exportSymbol(\"transit.list\", com.cognitect.transit.types.list), goog.exportSymbol(\"transit.isList\", com.cognitect.transit.types.isList), goog.exportSymbol(\"transit.quoted\", \ncom.cognitect.transit.types.quoted), goog.exportSymbol(\"transit.isQuoted\", com.cognitect.transit.types.isQuoted), goog.exportSymbol(\"transit.tagged\", com.cognitect.transit.types.taggedValue), goog.exportSymbol(\"transit.isTaggedValue\", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol(\"transit.link\", com.cognitect.transit.types.link), goog.exportSymbol(\"transit.isLink\", com.cognitect.transit.types.isLink), goog.exportSymbol(\"transit.hash\", com.cognitect.transit.eq.hashCode), goog.exportSymbol(\"transit.hashMapLike\", \ncom.cognitect.transit.eq.hashMapLike), goog.exportSymbol(\"transit.hashArrayLike\", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol(\"transit.equals\", com.cognitect.transit.eq.equals), goog.exportSymbol(\"transit.extendToEQ\", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol(\"transit.mapToObject\", com.cognitect.transit.mapToObject), goog.exportSymbol(\"transit.objectToMap\", com.cognitect.transit.objectToMap), goog.exportSymbol(\"transit.decoder\", com.cognitect.transit.impl.decoder.decoder), \ngoog.exportSymbol(\"transit.UUIDfromString\", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol(\"transit.randomUUID\", com.cognitect.transit.util.randomUUID), goog.exportSymbol(\"transit.stringableKeys\", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol(\"transit.readCache\", com.cognitect.transit.caching.readCache), goog.exportSymbol(\"transit.writeCache\", com.cognitect.transit.caching.writeCache));\nTRANSIT_NODE_TARGET && (module.exports = {reader:com.cognitect.transit.reader, writer:com.cognitect.transit.writer, makeBuilder:com.cognitect.transit.makeBuilder, makeWriteHandler:com.cognitect.transit.makeWriteHandler, date:com.cognitect.transit.types.date, integer:com.cognitect.transit.types.intValue, isInteger:com.cognitect.transit.types.isInteger, uuid:com.cognitect.transit.types.uuid, isUUID:com.cognitect.transit.types.isUUID, bigInt:com.cognitect.transit.types.bigInteger, isBigInt:com.cognitect.transit.types.isBigInteger, \nbigDec:com.cognitect.transit.types.bigDecimalValue, isBigDec:com.cognitect.transit.types.isBigDecimal, keyword:com.cognitect.transit.types.keyword, isKeyword:com.cognitect.transit.types.isKeyword, symbol:com.cognitect.transit.types.symbol, isSymbol:com.cognitect.transit.types.isSymbol, binary:com.cognitect.transit.types.binary, isBinary:com.cognitect.transit.types.isBinary, uri:com.cognitect.transit.types.uri, isURI:com.cognitect.transit.types.isURI, map:com.cognitect.transit.types.map, isMap:com.cognitect.transit.types.isMap, \nset:com.cognitect.transit.types.set, isSet:com.cognitect.transit.types.isSet, list:com.cognitect.transit.types.list, isList:com.cognitect.transit.types.isList, quoted:com.cognitect.transit.types.quoted, isQuoted:com.cognitect.transit.types.isQuoted, tagged:com.cognitect.transit.types.taggedValue, isTaggedValue:com.cognitect.transit.types.isTaggedValue, link:com.cognitect.transit.types.link, isLink:com.cognitect.transit.types.isLink, hash:com.cognitect.transit.eq.hashCode, hashArrayLike:com.cognitect.transit.eq.hashArrayLike, \nhashMapLike:com.cognitect.transit.eq.hashMapLike, equals:com.cognitect.transit.eq.equals, extendToEQ:com.cognitect.transit.eq.extendToEQ, mapToObject:com.cognitect.transit.mapToObject, objectToMap:com.cognitect.transit.objectToMap, decoder:com.cognitect.transit.impl.decoder.decoder, UUIDfromString:com.cognitect.transit.types.UUIDfromString, randomUUID:com.cognitect.transit.util.randomUUID, stringableKeys:com.cognitect.transit.impl.writer.stringableKeys, readCache:com.cognitect.transit.caching.readCache, \nwriteCache:com.cognitect.transit.caching.writeCache});\n\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const transit = require('transit-immutable-js')\nconst uuid = require('./uuid')\nconst Frontend = require('../frontend')\nconst { encodeChange, decodeChange } = require('../backend/columnar')\nconst { isObject } = require('./common')\nlet backend = require('../backend') // mutable: can be overridden with setDefaultBackend()\n\n///// Automerge.* API\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported options for init(): ${options}`)\n  }\n  return Frontend.init(Object.assign({backend}, options))\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  const changeOpts = {message: 'Initialization', undoable: false}\n  return change(init(options), changeOpts, doc => Object.assign(doc, initialState))\n}\n\nfunction change(doc, options, callback) {\n  const [newDoc, change] = Frontend.change(doc, options, callback)\n  return newDoc\n}\n\nfunction emptyChange(doc, options) {\n  const [newDoc, change] = Frontend.emptyChange(doc, options)\n  return newDoc\n}\n\nfunction undo(doc, options) {\n  const [newDoc, change] = Frontend.undo(doc, options)\n  return newDoc\n}\n\nfunction redo(doc, options) {\n  const [newDoc, change] = Frontend.redo(doc, options)\n  return newDoc\n}\n\nfunction clone(doc) {\n  const state = backend.clone(Frontend.getBackendState(doc))\n  const patch = backend.getPatch(state)\n  patch.state = state\n  return Frontend.applyPatch(init(), patch)\n}\n\nfunction free(doc) {\n  backend.free(Frontend.getBackendState(doc))\n}\n\nfunction load(data, options) {\n  const state = backend.load(data)\n  const patch = backend.getPatch(state)\n  patch.state = state\n  return Frontend.applyPatch(init(options), patch)\n}\n\nfunction save(doc) {\n  return backend.save(Frontend.getBackendState(doc))\n}\n\nfunction merge(localDoc, remoteDoc) {\n  if (Frontend.getActorId(localDoc) === Frontend.getActorId(remoteDoc)) {\n    throw new RangeError('Cannot merge an actor with itself')\n  }\n  // Just copy all changes from the remote doc; any duplicates will be ignored\n  return applyChanges(localDoc, getAllChanges(remoteDoc))\n}\n\nfunction getChanges(oldDoc, newDoc) {\n  const newState = Frontend.getBackendState(newDoc)\n  return backend.getChanges(newState, Frontend.getDeps(oldDoc))\n}\n\nfunction getAllChanges(doc) {\n  return backend.getChanges(Frontend.getBackendState(doc), [])\n}\n\nfunction applyChanges(doc, changes) {\n  const oldState = Frontend.getBackendState(doc)\n  const [newState, patch] = backend.applyChanges(oldState, changes)\n  patch.state = newState\n  return Frontend.applyPatch(doc, patch)\n}\n\nfunction getMissingDeps(doc) {\n  return backend.getMissingDeps(Frontend.getBackendState(doc))\n}\n\nfunction equals(val1, val2) {\n  if (!isObject(val1) || !isObject(val2)) return val1 === val2\n  const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort()\n  if (keys1.length !== keys2.length) return false\n  for (let i = 0; i < keys1.length; i++) {\n    if (keys1[i] !== keys2[i]) return false\n    if (!equals(val1[keys1[i]], val2[keys2[i]])) return false\n  }\n  return true\n}\n\nfunction getHistory(doc) {\n  const actor = Frontend.getActorId(doc)\n  const history = getAllChanges(doc)\n  return history.map((change, index) => {\n    return {\n      get change () {\n        return decodeChange(change)\n      },\n      get snapshot () {\n        const state = backend.loadChanges(backend.init(), history.slice(0, index + 1))\n        const patch = backend.getPatch(state)\n        patch.state = state\n        return Frontend.applyPatch(init(actor), patch)\n      }\n    }\n  })\n}\n\n/**\n * Replaces the default backend implementation with a different one.\n * This allows you to switch to using the Rust/WebAssembly implementation.\n */\nfunction setDefaultBackend(newBackend) {\n  backend = newBackend\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, undo, redo, clone, free,\n  load, save, merge, getChanges, getAllChanges, applyChanges, getMissingDeps,\n  encodeChange, decodeChange, equals, getHistory, uuid,\n  Frontend, setDefaultBackend,\n  get Backend() { return backend }\n}\n\nfor (let name of ['canUndo', 'canRedo', 'getObjectId', 'getObjectById', 'getActorId',\n     'setActorId', 'getConflicts', 'Text', 'Table', 'Counter']) {\n  module.exports[name] = Frontend[name]\n}\n","const ROOT_ID   = '00000000-0000-0000-0000-000000000000'\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\n/**\n * Returns a shallow copy of the object `obj`. Faster than `Object.assign({}, obj)`.\n * https://jsperf.com/cloning-large-objects/1\n */\nfunction copyObject(obj) {\n  if (!isObject(obj)) return {}\n  let copy = {}\n  for (let key of Object.keys(obj)) {\n    copy[key] = obj[key]\n  }\n  return copy\n}\n\n/**\n * Takes a string in the form that is used to identify operations (a counter concatenated\n * with an actor ID, separated by an `@` sign) and returns an object `{counter, actorId}`.\n */\nfunction parseOpId(opId) {\n  const match = /^(\\d+)@(.*)$/.exec(opId || '')\n  if (!match) {\n    throw new RangeError(`Not a valid opId: ${opId}`)\n  }\n  return {counter: parseInt(match[1]), actorId: match[2]}\n}\n\n/**\n * Returns true if the two byte arrays contain the same data, false if not.\n */\nfunction equalBytes(array1, array2) {\n  if (!(array1 instanceof Uint8Array) || !(array2 instanceof Uint8Array)) {\n    throw new TypeError('equalBytes can only compare Uint8Arrays')\n  }\n  if (array1.byteLength !== array2.byteLength) return false\n  for (let i = 0; i < array1.byteLength; i++) {\n    if (array1[i] !== array2[i]) return false\n  }\n  return true\n}\n\nmodule.exports = {\n  ROOT_ID, isObject, copyObject, parseOpId, equalBytes\n}\n","const uuid = require('uuid/v4')\n\nfunction defaultFactory() {\n  return uuid().replace(/-/g, '')\n}\n\nlet factory = defaultFactory\n\nfunction makeUuid() {\n  return factory()\n}\n\nmakeUuid.setFactory = newFactory => { factory = newFactory }\nmakeUuid.reset = () => { factory = defaultFactory }\n\nmodule.exports = makeUuid\n"],"sourceRoot":""}